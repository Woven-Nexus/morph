import { m as Jl, l as ed, E as ZC, r as ne, M as qt, a as E, b as g, C as L, c as b, d as j, e as XC, f as $, g as de, A as rt, I as he, h as _e, i as Em, j as Kt, D as td, R as Q, k as ee, n as Z, o as x, S as z, p as Ue, q as xt, s as D, K as ye, t as W, u as Y, v as Se, O as ci, w as P, x as Re, y as S, P as F, z as pc, B as Gr, F as Si, G as Tm, H as hi, U as ce, J as eh, L as Te, N as QC, Q as Am, T as q, $ as O, V as oe, W as le, X as Le, Y as ft, Z as hr, _ as co, a0 as xe, a1 as id, a2 as pe, a3 as De, a4 as YC, a5 as mt, a6 as JC, a7 as Gt, a8 as bt, a9 as B, aa as M, ab as fc, ac as eS, ad as tS, ae as iS, af as ho, ag as V, ah as Ei, ai as nS, aj as Zu, ak as Om, al as nd, am as Pe, an as Ii, ao as Vs, ap as sS, aq as Zr, ar as uo, as as oS, at as Xu, au as rS, av as Cp, aw as Ie, ax as wi, ay as Ge, az as X, aA as Xi, aB as aS, aC as go, aD as jt, aE as nt, aF as Fe, aG as ui, aH as Je, aI as Qu, aJ as R, aK as G, aL as Fm, aM as lS, aN as Yu, aO as sd, aP as Ju, aQ as eg, aR as Mn, aS as dS, aT as Oe, aU as tg, aV as Wm, aW as Is, aX as Ti, aY as Ai, aZ as Us, a_ as ur, a$ as Xr, b0 as Hm, b1 as mc, b2 as ig, b3 as Qr, b4 as od, b5 as re, b6 as cS, b7 as Bm, b8 as gr, b9 as zs, ba as pr, bb as rd, bc as ng, bd as ie, be as vn, bf as Yr, bg as hS, bh as sg, bi as uS, bj as gS, bk as Cl, bl as Pt, bm as Vm, bn as $s, bo as fe, bp as pS, bq as K, br as js, bs as Jr, bt as Um, bu as Rt, bv as ea, bw as fS, bx as En, by as A, bz as Sp, bA as Ae, bB as ol, bC as zm, bD as Mt, bE as zt, bF as ae, bG as si, bH as og, bI as mS, bJ as rg, bK as _S, bL as Ds, bM as wp, bN as vS, bO as bS, bP as $i, bQ as th, bR as Di, bS as Hn, bT as Bn, bU as qs, bV as CS, bW as Qi, bX as Dt, bY as ut, bZ as SS, b_ as oi, b$ as ri, c0 as $e, c1 as yp, c2 as ta, c3 as Zt, c4 as fr, c5 as $m, c6 as wS, c7 as yS, c8 as ag, c9 as ad, ca as xS, cb as mr, cc as LS, cd as Et, ce as IS, cf as xp, cg as jm, ch as Lp, ci as wt, cj as DS, ck as kS, cl as gi, cm as NS, cn as qm, co as Km, cp as Gm, cq as lg, cr as Zm, cs as pi, ct as Xm, cu as Qm, cv as RS, cw as Ym, cx as dg, cy as PS, cz as Ip, cA as ia, cB as ld, cC as Jm, cD as ks, cE as MS, cF as lt, cG as ES, cH as po, cI as Dp, cJ as _r, cK as e_, cL as Sl, cM as t_, cN as je, cO as kp, cP as Sa, cQ as is, cR as yt, cS as wa, cT as cg, cU as hg, cV as TS, cW as AS, cX as OS, cY as FS, cZ as WS, c_ as HS, c$ as dd, d0 as BS, d1 as Np, d2 as it, d3 as Xe, d4 as ug, d5 as Ks, d6 as Gs, d7 as Ne, d8 as vr, d9 as ih, da as gg, db as i_, dc as n_, dd as Tn, de as VS, df as ue, dg as nh, dh as Zs, di as US, dj as zS, dk as Rp, dl as sh, dm as $S, dn as jS, dp as ns, dq as pg, dr as s_, ds as qS, dt as o_, du as KS, dv as r_, dw as GS, dx as ZS, dy as XS, dz as a_, dA as l_, dB as QS, dC as wl, dD as d_, dE as YS, dF as JS, dG as Vn, dH as fg, dI as ew, dJ as Pp, dK as Mp, dL as tw, dM as Ns, dN as c_, dO as iw, dP as nw, dQ as h_, dR as u_, dS as mg, dT as g_, dU as p_, dV as sw, dW as Ep, dX as ya, dY as ow, dZ as na, d_ as xa, d$ as f_, e0 as Tp, e1 as m_, e2 as br, e3 as sa, e4 as __, e5 as yl, e6 as rw, e7 as v_, e8 as aw, e9 as b_, ea as lw, eb as dw, ec as cw, ed as xl, ee as C_, ef as ai, eg as As, eh as hw, ei as uw, ej as S_, ek as w_, el as gw, em as pw, en as Rs, eo as y_, ep as x_, eq as Cr, er as fw, es as mw, et as _w, eu as Ro, ev as Ap, ew as vw, ex as bw, ey as Cw, ez as Sw, eA as L_, eB as Ee, eC as ww, eD as Ll, eE as ht, eF as yw, eG as I_, eH as D_, eI as xw, eJ as Yo, eK as Lw, eL as Iw, eM as Dw, eN as kw, eO as Op, eP as Fp, eQ as Wp, eR as fo, eS as k_, eT as Nw, eU as _c, eV as Rw, eW as Hp, eX as rl, eY as Pw, eZ as Mw, e_ as _g, e$ as Ew, f0 as Tw, f1 as N_, f2 as R_, f3 as Aw, f4 as Ow, f5 as Fw, f6 as Ww, f7 as Hw, f8 as Bw, f9 as Vw, fa as P_, fb as Uw, fc as Il, fd as Uo, fe as La, ff as Ia, fg as Da, fh as ka, fi as ji, fj as Na, fk as Bp, fl as zw, fm as Vp, fn as $w, fo as vc, fp as Up, fq as jw, fr as qw, fs as M_, ft as Kw, fu as E_, fv as Gw, fw as T_, fx as al, fy as Zw, fz as Nn, fA as Xw, fB as Jo, fC as A_, fD as Xs, fE as zp, fF as Qw, fG as Yw, fH as Jw, fI as ey, fJ as $p, fK as ty, fL as iy, fM as ny, fN as sy, fO as oy, fP as ry, fQ as vg, fR as bg, fS as ll, fT as Ra, fU as bc, fV as ay, fW as Cg, fX as ly, fY as Sg, fZ as dy, f_ as cy, f$ as zo, g0 as cd, g1 as hy, g2 as oh, g3 as jp, g4 as Yi, g5 as uy, g6 as gy, g7 as py, g8 as fy, g9 as my, ga as _y, gb as vy, gc as by, gd as Cy, ge as wg, gf as O_, gg as qp, gh as Kp, gi as Sy, gj as wy, gk as yy, gl as Gp, gm as Cc, gn as xy, go as Ly, gp as Iy, gq as Dy, gr as Sc, gs as F_, gt as W_, gu as H_, gv as B_, gw as V_, gx as ki, gy as yg, gz as U_, gA as ky, gB as Ny, gC as hd, gD as ud, gE as ss, gF as gd, gG as oa, gH as Ry, gI as pd, gJ as Py, gK as My, gL as Ey, gM as z_, gN as Ty, gO as Ay, gP as Oy, gQ as Fy, gR as Po, gS as ra, gT as Wy, gU as $_, gV as j_, gW as q_, gX as rh, gY as Hy, gZ as By, g_ as Vy, g$ as Uy, h0 as zy, h1 as ah, h2 as $y, h3 as jy, h4 as qy, h5 as Ky, h6 as Gy, h7 as Zy, h8 as Xy, h9 as K_, ha as Qy, hb as Zp, hc as Yy, hd as Jy, he as e0, hf as t0 } from "./editor.api-B2Cf7Ob7.js";
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var i0 = Object.defineProperty, n0 = Object.getOwnPropertyDescriptor, s0 = Object.getOwnPropertyNames, o0 = Object.prototype.hasOwnProperty, Xp = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of s0(e))
      !o0.call(r, n) && n !== t && i0(r, n, { get: () => e[n], enumerable: !(i = n0(e, n)) || i.enumerable });
  return r;
}, r0 = (r, e, t) => (Xp(r, e, "default"), t && Xp(t, e, "default")), $o = {};
r0($o, Jl);
var G_ = {}, wc = {}, a0 = class Z_ {
  static getOrCreate(e) {
    return wc[e] || (wc[e] = new Z_(e)), wc[e];
  }
  constructor(e) {
    this._languageId = e, this._loadingTriggered = !1, this._lazyLoadPromise = new Promise((t, i) => {
      this._lazyLoadPromiseResolve = t, this._lazyLoadPromiseReject = i;
    });
  }
  load() {
    return this._loadingTriggered || (this._loadingTriggered = !0, G_[this._languageId].loader().then(
      (e) => this._lazyLoadPromiseResolve(e),
      (e) => this._lazyLoadPromiseReject(e)
    )), this._lazyLoadPromise;
  }
};
function T(r) {
  const e = r.id;
  G_[e] = r, $o.languages.register(r);
  const t = a0.getOrCreate(e);
  $o.languages.registerTokensProviderFactory(e, {
    create: async () => (await t.load()).language
  }), $o.languages.onLanguageEncountered(e, async () => {
    const i = await t.load();
    $o.languages.setLanguageConfiguration(e, i.conf);
  });
}
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "abap",
  extensions: [".abap"],
  aliases: ["abap", "ABAP"],
  loader: () => import("./abap-BqcsHm_C.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "apex",
  extensions: [".cls"],
  aliases: ["Apex", "apex"],
  mimetypes: ["text/x-apex-source", "text/x-apex"],
  loader: () => import("./apex-qisLKCY2.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "azcli",
  extensions: [".azcli"],
  aliases: ["Azure CLI", "azcli"],
  loader: () => import("./azcli-ksZl_VeD.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "bat",
  extensions: [".bat", ".cmd"],
  aliases: ["Batch", "bat"],
  loader: () => import("./bat-toztT7PN.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "bicep",
  extensions: [".bicep"],
  aliases: ["Bicep"],
  loader: () => import("./bicep-jxUtWkEa.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "cameligo",
  extensions: [".mligo"],
  aliases: ["Cameligo"],
  loader: () => import("./cameligo--mnpevC2.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "clojure",
  extensions: [".clj", ".cljs", ".cljc", ".edn"],
  aliases: ["clojure", "Clojure"],
  loader: () => import("./clojure-DFTJHX75.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "coffeescript",
  extensions: [".coffee"],
  aliases: ["CoffeeScript", "coffeescript", "coffee"],
  mimetypes: ["text/x-coffeescript", "text/coffeescript"],
  loader: () => import("./coffee-sjsjwKFb.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "c",
  extensions: [".c", ".h"],
  aliases: ["C", "c"],
  loader: () => import("./cpp-Nax-tLe0.js")
});
T({
  id: "cpp",
  extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx"],
  aliases: ["C++", "Cpp", "cpp"],
  loader: () => import("./cpp-Nax-tLe0.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "csharp",
  extensions: [".cs", ".csx", ".cake"],
  aliases: ["C#", "csharp"],
  loader: () => import("./csharp-BK-0kSMg.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "csp",
  extensions: [],
  aliases: ["CSP", "csp"],
  loader: () => import("./csp-BrKJBURo.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "css",
  extensions: [".css"],
  aliases: ["CSS", "css"],
  mimetypes: ["text/css"],
  loader: () => import("./css-D4SiSmV0.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "cypher",
  extensions: [".cypher", ".cyp"],
  aliases: ["Cypher", "OpenCypher"],
  loader: () => import("./cypher-D0Mb7lRF.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "dart",
  extensions: [".dart"],
  aliases: ["Dart", "dart"],
  mimetypes: ["text/x-dart-source", "text/x-dart"],
  loader: () => import("./dart-DaJRvrIu.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "dockerfile",
  extensions: [".dockerfile"],
  filenames: ["Dockerfile"],
  aliases: ["Dockerfile"],
  loader: () => import("./dockerfile-Dn7tZ_7c.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "ecl",
  extensions: [".ecl"],
  aliases: ["ECL", "Ecl", "ecl"],
  loader: () => import("./ecl-CFRd1ucq.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "elixir",
  extensions: [".ex", ".exs"],
  aliases: ["Elixir", "elixir", "ex"],
  loader: () => import("./elixir-BWnp76zc.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "flow9",
  extensions: [".flow"],
  aliases: ["Flow9", "Flow", "flow9", "flow"],
  loader: () => import("./flow9-DF9s1zbR.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "fsharp",
  extensions: [".fs", ".fsi", ".ml", ".mli", ".fsx", ".fsscript"],
  aliases: ["F#", "FSharp", "fsharp"],
  loader: () => import("./fsharp-DyPHaXJ9.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "freemarker2",
  extensions: [".ftl", ".ftlh", ".ftlx"],
  aliases: ["FreeMarker2", "Apache FreeMarker2"],
  loader: () => import("./freemarker2-oO66GxJt.js").then((r) => r.TagAutoInterpolationDollar)
});
T({
  id: "freemarker2.tag-angle.interpolation-dollar",
  aliases: ["FreeMarker2 (Angle/Dollar)", "Apache FreeMarker2 (Angle/Dollar)"],
  loader: () => import("./freemarker2-oO66GxJt.js").then((r) => r.TagAngleInterpolationDollar)
});
T({
  id: "freemarker2.tag-bracket.interpolation-dollar",
  aliases: ["FreeMarker2 (Bracket/Dollar)", "Apache FreeMarker2 (Bracket/Dollar)"],
  loader: () => import("./freemarker2-oO66GxJt.js").then((r) => r.TagBracketInterpolationDollar)
});
T({
  id: "freemarker2.tag-angle.interpolation-bracket",
  aliases: ["FreeMarker2 (Angle/Bracket)", "Apache FreeMarker2 (Angle/Bracket)"],
  loader: () => import("./freemarker2-oO66GxJt.js").then((r) => r.TagAngleInterpolationBracket)
});
T({
  id: "freemarker2.tag-bracket.interpolation-bracket",
  aliases: ["FreeMarker2 (Bracket/Bracket)", "Apache FreeMarker2 (Bracket/Bracket)"],
  loader: () => import("./freemarker2-oO66GxJt.js").then((r) => r.TagBracketInterpolationBracket)
});
T({
  id: "freemarker2.tag-auto.interpolation-dollar",
  aliases: ["FreeMarker2 (Auto/Dollar)", "Apache FreeMarker2 (Auto/Dollar)"],
  loader: () => import("./freemarker2-oO66GxJt.js").then((r) => r.TagAutoInterpolationDollar)
});
T({
  id: "freemarker2.tag-auto.interpolation-bracket",
  aliases: ["FreeMarker2 (Auto/Bracket)", "Apache FreeMarker2 (Auto/Bracket)"],
  loader: () => import("./freemarker2-oO66GxJt.js").then((r) => r.TagAutoInterpolationBracket)
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "go",
  extensions: [".go"],
  aliases: ["Go"],
  loader: () => import("./go-a4f9Uf-F.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "graphql",
  extensions: [".graphql", ".gql"],
  aliases: ["GraphQL", "graphql", "gql"],
  mimetypes: ["application/graphql"],
  loader: () => import("./graphql-BEbjJbAH.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "handlebars",
  extensions: [".handlebars", ".hbs"],
  aliases: ["Handlebars", "handlebars", "hbs"],
  mimetypes: ["text/x-handlebars-template"],
  loader: () => import("./handlebars-CbmVcSdv.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "hcl",
  extensions: [".tf", ".tfvars", ".hcl"],
  aliases: ["Terraform", "tf", "HCL", "hcl"],
  loader: () => import("./hcl-BuQW8Q2A.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "html",
  extensions: [".html", ".htm", ".shtml", ".xhtml", ".mdoc", ".jsp", ".asp", ".aspx", ".jshtm"],
  aliases: ["HTML", "htm", "html", "xhtml"],
  mimetypes: ["text/html", "text/x-jshtm", "text/template", "text/ng-template"],
  loader: () => import("./html-CgWTovbQ.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "ini",
  extensions: [".ini", ".properties", ".gitconfig"],
  filenames: ["config", ".gitattributes", ".gitconfig", ".editorconfig"],
  aliases: ["Ini", "ini"],
  loader: () => import("./ini-BSYUNLvq.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "java",
  extensions: [".java", ".jav"],
  aliases: ["Java", "java"],
  mimetypes: ["text/x-java-source", "text/x-java"],
  loader: () => import("./java-DV4mYkM7.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "javascript",
  extensions: [".js", ".es6", ".jsx", ".mjs", ".cjs"],
  firstLine: "^#!.*\\bnode",
  filenames: ["jakefile"],
  aliases: ["JavaScript", "javascript", "js"],
  mimetypes: ["text/javascript"],
  loader: () => import("./javascript-BqDzarg5.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "julia",
  extensions: [".jl"],
  aliases: ["julia", "Julia"],
  loader: () => import("./julia-D8wxsVbk.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "kotlin",
  extensions: [".kt", ".kts"],
  aliases: ["Kotlin", "kotlin"],
  mimetypes: ["text/x-kotlin-source", "text/x-kotlin"],
  loader: () => import("./kotlin-DY9IF-Ts.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "less",
  extensions: [".less"],
  aliases: ["Less", "less"],
  mimetypes: ["text/x-less", "text/less"],
  loader: () => import("./less-AR6TBYns.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "lexon",
  extensions: [".lex"],
  aliases: ["Lexon"],
  loader: () => import("./lexon-BXIuHDZm.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "lua",
  extensions: [".lua"],
  aliases: ["Lua", "lua"],
  loader: () => import("./lua-BXM0V2sP.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "liquid",
  extensions: [".liquid", ".html.liquid"],
  aliases: ["Liquid", "liquid"],
  mimetypes: ["application/liquid"],
  loader: () => import("./liquid-O5yTmwXI.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "m3",
  extensions: [".m3", ".i3", ".mg", ".ig"],
  aliases: ["Modula-3", "Modula3", "modula3", "m3"],
  loader: () => import("./m3-BpL4ouTo.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "markdown",
  extensions: [".md", ".markdown", ".mdown", ".mkdn", ".mkd", ".mdwn", ".mdtxt", ".mdtext"],
  aliases: ["Markdown", "markdown"],
  loader: () => import("./markdown-oev5-MzD.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "mdx",
  extensions: [".mdx"],
  aliases: ["MDX", "mdx"],
  loader: () => import("./mdx-n-WiB-mQ.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "mips",
  extensions: [".s"],
  aliases: ["MIPS", "MIPS-V"],
  mimetypes: ["text/x-mips", "text/mips", "text/plaintext"],
  loader: () => import("./mips-Do80UkM_.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "msdax",
  extensions: [".dax", ".msdax"],
  aliases: ["DAX", "MSDAX"],
  loader: () => import("./msdax-BmKXrb_F.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "mysql",
  extensions: [],
  aliases: ["MySQL", "mysql"],
  loader: () => import("./mysql-DBpu5uqz.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "objective-c",
  extensions: [".m"],
  aliases: ["Objective-C"],
  loader: () => import("./objective-c-C0rDL9rz.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "pascal",
  extensions: [".pas", ".p", ".pp"],
  aliases: ["Pascal", "pas"],
  mimetypes: ["text/x-pascal-source", "text/x-pascal"],
  loader: () => import("./pascal-CEMvCQ86.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "pascaligo",
  extensions: [".ligo"],
  aliases: ["Pascaligo", "ligo"],
  loader: () => import("./pascaligo-BHmIehLY.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "perl",
  extensions: [".pl", ".pm"],
  aliases: ["Perl", "pl"],
  loader: () => import("./perl-88KpRufU.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "pgsql",
  extensions: [],
  aliases: ["PostgreSQL", "postgres", "pg", "postgre"],
  loader: () => import("./pgsql-CFP7_6OU.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "php",
  extensions: [".php", ".php4", ".php5", ".phtml", ".ctp"],
  aliases: ["PHP", "php"],
  mimetypes: ["application/x-php"],
  loader: () => import("./php-D-l7hR3h.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "pla",
  extensions: [".pla"],
  loader: () => import("./pla-CQwfaowp.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "postiats",
  extensions: [".dats", ".sats", ".hats"],
  aliases: ["ATS", "ATS/Postiats"],
  loader: () => import("./postiats-qCOBOZxF.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "powerquery",
  extensions: [".pq", ".pqm"],
  aliases: ["PQ", "M", "Power Query", "Power Query M"],
  loader: () => import("./powerquery-DwAm_MvG.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "powershell",
  extensions: [".ps1", ".psm1", ".psd1"],
  aliases: ["PowerShell", "powershell", "ps", "ps1"],
  loader: () => import("./powershell-DiGfWXCG.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "proto",
  extensions: [".proto"],
  aliases: ["protobuf", "Protocol Buffers"],
  loader: () => import("./protobuf-Dlfuu2nY.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "pug",
  extensions: [".jade", ".pug"],
  aliases: ["Pug", "Jade", "jade"],
  loader: () => import("./pug-wCjO1NX2.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "python",
  extensions: [".py", ".rpy", ".pyw", ".cpy", ".gyp", ".gypi"],
  aliases: ["Python", "py"],
  firstLine: "^#!/.*\\bpython[0-9.-]*\\b",
  loader: () => import("./python-DQo3GmgF.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "qsharp",
  extensions: [".qs"],
  aliases: ["Q#", "qsharp"],
  loader: () => import("./qsharp-Dl49KUif.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "r",
  extensions: [".r", ".rhistory", ".rmd", ".rprofile", ".rt"],
  aliases: ["R", "r"],
  loader: () => import("./r-BxHr22ii.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "razor",
  extensions: [".cshtml"],
  aliases: ["Razor", "razor"],
  mimetypes: ["text/x-cshtml"],
  loader: () => import("./razor-T7JWp4qR.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "redis",
  extensions: [".redis"],
  aliases: ["redis"],
  loader: () => import("./redis-d2SpqvE1.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "redshift",
  extensions: [],
  aliases: ["Redshift", "redshift"],
  loader: () => import("./redshift-p9-ym5zU.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "restructuredtext",
  extensions: [".rst"],
  aliases: ["reStructuredText", "restructuredtext"],
  loader: () => import("./restructuredtext-CEPqZH3y.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "ruby",
  extensions: [".rb", ".rbx", ".rjs", ".gemspec", ".pp"],
  filenames: ["rakefile", "Gemfile"],
  aliases: ["Ruby", "rb"],
  loader: () => import("./ruby-DhKNgZEY.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "rust",
  extensions: [".rs", ".rlib"],
  aliases: ["Rust", "rust"],
  loader: () => import("./rust-MCnfjcH3.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "sb",
  extensions: [".sb"],
  aliases: ["Small Basic", "sb"],
  loader: () => import("./sb-Dbfibbn2.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "scala",
  extensions: [".scala", ".sc", ".sbt"],
  aliases: ["Scala", "scala", "SBT", "Sbt", "sbt", "Dotty", "dotty"],
  mimetypes: ["text/x-scala-source", "text/x-scala", "text/x-sbt", "text/x-dotty"],
  loader: () => import("./scala-B42zPLKI.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "scheme",
  extensions: [".scm", ".ss", ".sch", ".rkt"],
  aliases: ["scheme", "Scheme"],
  loader: () => import("./scheme-qfd7ChH7.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "scss",
  extensions: [".scss"],
  aliases: ["Sass", "sass", "scss"],
  mimetypes: ["text/x-scss", "text/scss"],
  loader: () => import("./scss-COn4tZlM.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "shell",
  extensions: [".sh", ".bash"],
  aliases: ["Shell", "sh"],
  loader: () => import("./shell-BcASen3I.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "sol",
  extensions: [".sol"],
  aliases: ["sol", "solidity", "Solidity"],
  loader: () => import("./solidity-C6t2cKnp.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "aes",
  extensions: [".aes"],
  aliases: ["aes", "sophia", "Sophia"],
  loader: () => import("./sophia-1rZr7F0Q.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "sparql",
  extensions: [".rq"],
  aliases: ["sparql", "SPARQL"],
  loader: () => import("./sparql-C7-hgDqj.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "sql",
  extensions: [".sql"],
  aliases: ["SQL"],
  loader: () => import("./sql-Bwe7LIYc.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "st",
  extensions: [".st", ".iecst", ".iecplc", ".lc3lib", ".TcPOU", ".TcDUT", ".TcGVL", ".TcIO"],
  aliases: ["StructuredText", "scl", "stl"],
  loader: () => import("./st-BBLkcnFS.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "swift",
  aliases: ["Swift", "swift"],
  extensions: [".swift"],
  mimetypes: ["text/swift"],
  loader: () => import("./swift-B0WL7QEJ.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "systemverilog",
  extensions: [".sv", ".svh"],
  aliases: ["SV", "sv", "SystemVerilog", "systemverilog"],
  loader: () => import("./systemverilog-ByXNYGLF.js")
});
T({
  id: "verilog",
  extensions: [".v", ".vh"],
  aliases: ["V", "v", "Verilog", "verilog"],
  loader: () => import("./systemverilog-ByXNYGLF.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "tcl",
  extensions: [".tcl"],
  aliases: ["tcl", "Tcl", "tcltk", "TclTk", "tcl/tk", "Tcl/Tk"],
  loader: () => import("./tcl-CZN131IR.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "twig",
  extensions: [".twig"],
  aliases: ["Twig", "twig"],
  mimetypes: ["text/x-twig"],
  loader: () => import("./twig-JW2CRH1Y.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "typescript",
  extensions: [".ts", ".tsx", ".cts", ".mts"],
  aliases: ["TypeScript", "ts", "typescript"],
  mimetypes: ["text/typescript"],
  loader: () => import("./typescript-CPBoHdua.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "vb",
  extensions: [".vb"],
  aliases: ["Visual Basic", "vb"],
  loader: () => import("./vb-Ct6nRh19.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "wgsl",
  extensions: [".wgsl"],
  aliases: ["WebGPU Shading Language", "WGSL", "wgsl"],
  loader: () => import("./wgsl-CW2ZALad.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "xml",
  extensions: [
    ".xml",
    ".xsd",
    ".dtd",
    ".ascx",
    ".csproj",
    ".config",
    ".props",
    ".targets",
    ".wxi",
    ".wxl",
    ".wxs",
    ".xaml",
    ".svg",
    ".svgz",
    ".opf",
    ".xslt",
    ".xsl"
  ],
  firstLine: "(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",
  aliases: ["XML", "xml"],
  mimetypes: ["text/xml", "application/xml", "application/xaml+xml", "application/xml-dtd"],
  loader: () => import("./xml-CMIcoquQ.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
T({
  id: "yaml",
  extensions: [".yaml", ".yml"],
  aliases: ["YAML", "yaml", "YML", "yml"],
  mimetypes: ["application/x-yaml", "text/x-yaml"],
  loader: () => import("./yaml-gUo4SZV_.js")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var l0 = Object.defineProperty, d0 = Object.getOwnPropertyDescriptor, c0 = Object.getOwnPropertyNames, h0 = Object.prototype.hasOwnProperty, Qp = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of c0(e))
      !h0.call(r, n) && n !== t && l0(r, n, { get: () => e[n], enumerable: !(i = d0(e, n)) || i.enumerable });
  return r;
}, u0 = (r, e, t) => (Qp(r, e, "default"), t && Qp(t, e, "default")), mo = {};
u0(mo, Jl);
var xg = class {
  constructor(e, t, i) {
    this._onDidChange = new mo.Emitter(), this._languageId = e, this.setOptions(t), this.setModeConfiguration(i);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get diagnosticsOptions() {
    return this.options;
  }
  get options() {
    return this._options;
  }
  setOptions(e) {
    this._options = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
  setDiagnosticsOptions(e) {
    this.setOptions(e);
  }
  setModeConfiguration(e) {
    this._modeConfiguration = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
}, Lg = {
  validate: !0,
  lint: {
    compatibleVendorPrefixes: "ignore",
    vendorPrefix: "warning",
    duplicateProperties: "warning",
    emptyRules: "warning",
    importStatement: "ignore",
    boxModel: "ignore",
    universalSelector: "ignore",
    zeroUnits: "ignore",
    fontFaceProperties: "warning",
    hexColorLength: "error",
    argumentsInColorFunction: "error",
    unknownProperties: "warning",
    ieHack: "ignore",
    unknownVendorSpecificProperties: "ignore",
    propertyIgnoredDueToDisplay: "warning",
    important: "ignore",
    float: "ignore",
    idSelector: "ignore"
  },
  data: { useDefaultDataProvider: !0 },
  format: {
    newlineBetweenSelectors: !0,
    newlineBetweenRules: !0,
    spaceAroundSelectorSeparator: !1,
    braceStyle: "collapse",
    maxPreserveNewLines: void 0,
    preserveNewLines: !0
  }
}, Ig = {
  completionItems: !0,
  hovers: !0,
  documentSymbols: !0,
  definitions: !0,
  references: !0,
  documentHighlights: !0,
  rename: !0,
  colors: !0,
  foldingRanges: !0,
  diagnostics: !0,
  selectionRanges: !0,
  documentFormattingEdits: !0,
  documentRangeFormattingEdits: !0
}, X_ = new xg(
  "css",
  Lg,
  Ig
), Q_ = new xg(
  "scss",
  Lg,
  Ig
), Y_ = new xg(
  "less",
  Lg,
  Ig
);
mo.languages.css = { cssDefaults: X_, lessDefaults: Y_, scssDefaults: Q_ };
function Dg() {
  return import("./cssMode-DK2Syqvd.js");
}
mo.languages.onLanguage("less", () => {
  Dg().then((r) => r.setupMode(Y_));
});
mo.languages.onLanguage("scss", () => {
  Dg().then((r) => r.setupMode(Q_));
});
mo.languages.onLanguage("css", () => {
  Dg().then((r) => r.setupMode(X_));
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var g0 = Object.defineProperty, p0 = Object.getOwnPropertyDescriptor, f0 = Object.getOwnPropertyNames, m0 = Object.prototype.hasOwnProperty, Yp = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of f0(e))
      !m0.call(r, n) && n !== t && g0(r, n, { get: () => e[n], enumerable: !(i = p0(e, n)) || i.enumerable });
  return r;
}, _0 = (r, e, t) => (Yp(r, e, "default"), t && Yp(t, e, "default")), fd = {};
_0(fd, Jl);
var v0 = class {
  constructor(e, t, i) {
    this._onDidChange = new fd.Emitter(), this._languageId = e, this.setOptions(t), this.setModeConfiguration(i);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get options() {
    return this._options;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  setOptions(e) {
    this._options = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
  setModeConfiguration(e) {
    this._modeConfiguration = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
}, b0 = {
  tabSize: 4,
  insertSpaces: !1,
  wrapLineLength: 120,
  unformatted: 'default": "a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var',
  contentUnformatted: "pre",
  indentInnerHtml: !1,
  preserveNewLines: !0,
  maxPreserveNewLines: void 0,
  indentHandlebars: !1,
  endWithNewline: !1,
  extraLiners: "head, body, /html",
  wrapAttributes: "auto"
}, md = {
  format: b0,
  suggest: {},
  data: { useDefaultDataProvider: !0 }
};
function _d(r) {
  return {
    completionItems: !0,
    hovers: !0,
    documentSymbols: !0,
    links: !0,
    documentHighlights: !0,
    rename: !0,
    colors: !0,
    foldingRanges: !0,
    selectionRanges: !0,
    diagnostics: r === er,
    // turned off for Razor and Handlebar
    documentFormattingEdits: r === er,
    // turned off for Razor and Handlebar
    documentRangeFormattingEdits: r === er
    // turned off for Razor and Handlebar
  };
}
var er = "html", Jp = "handlebars", ef = "razor", J_ = vd(
  er,
  md,
  _d(er)
), C0 = J_.defaults, ev = vd(
  Jp,
  md,
  _d(Jp)
), S0 = ev.defaults, tv = vd(
  ef,
  md,
  _d(ef)
), w0 = tv.defaults;
fd.languages.html = {
  htmlDefaults: C0,
  razorDefaults: w0,
  handlebarDefaults: S0,
  htmlLanguageService: J_,
  handlebarLanguageService: ev,
  razorLanguageService: tv,
  registerHTMLLanguageService: vd
};
function y0() {
  return import("./htmlMode-YbVWtMjL.js");
}
function vd(r, e = md, t = _d(r)) {
  const i = new v0(r, e, t);
  let n;
  const s = fd.languages.onLanguage(r, async () => {
    n = (await y0()).setupMode(i);
  });
  return {
    defaults: i,
    dispose() {
      s.dispose(), n == null || n.dispose(), n = void 0;
    }
  };
}
var x0 = class {
  constructor(e, t, i) {
    this._onDidChange = new ZC(), this._languageId = e, this.setDiagnosticsOptions(t), this.setModeConfiguration(i);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get diagnosticsOptions() {
    return this._diagnosticsOptions;
  }
  setDiagnosticsOptions(e) {
    this._diagnosticsOptions = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
  setModeConfiguration(e) {
    this._modeConfiguration = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
}, L0 = {
  validate: !0,
  allowComments: !0,
  schemas: [],
  enableSchemaRequest: !1,
  schemaRequest: "warning",
  schemaValidation: "warning",
  comments: "error",
  trailingCommas: "error"
}, I0 = {
  documentFormattingEdits: !0,
  documentRangeFormattingEdits: !0,
  completionItems: !0,
  hovers: !0,
  documentSymbols: !0,
  tokens: !0,
  colors: !0,
  foldingRanges: !0,
  diagnostics: !0,
  selectionRanges: !0
}, iv = new x0(
  "json",
  L0,
  I0
), D0 = () => nv().then((r) => r.getWorker());
ed.json = { jsonDefaults: iv, getWorker: D0 };
function nv() {
  return import("./jsonMode-dPWXKihQ.js");
}
ed.register({
  id: "json",
  extensions: [".json", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc", ".har"],
  aliases: ["JSON", "json"],
  mimetypes: ["application/json"]
});
ed.onLanguage("json", () => {
  nv().then((r) => r.setupMode(iv));
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.47.0(69991d66135e4a1fc1cf0b1ac4ad25d429866a0d)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var k0 = Object.defineProperty, N0 = Object.getOwnPropertyDescriptor, R0 = Object.getOwnPropertyNames, P0 = Object.prototype.hasOwnProperty, tf = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of R0(e))
      !P0.call(r, n) && n !== t && k0(r, n, { get: () => e[n], enumerable: !(i = N0(e, n)) || i.enumerable });
  return r;
}, M0 = (r, e, t) => (tf(r, e, "default"), t && tf(t, e, "default")), E0 = "5.0.2", Qs = {};
M0(Qs, Jl);
var sv = /* @__PURE__ */ ((r) => (r[r.None = 0] = "None", r[r.CommonJS = 1] = "CommonJS", r[r.AMD = 2] = "AMD", r[r.UMD = 3] = "UMD", r[r.System = 4] = "System", r[r.ES2015 = 5] = "ES2015", r[r.ESNext = 99] = "ESNext", r))(sv || {}), ov = /* @__PURE__ */ ((r) => (r[r.None = 0] = "None", r[r.Preserve = 1] = "Preserve", r[r.React = 2] = "React", r[r.ReactNative = 3] = "ReactNative", r[r.ReactJSX = 4] = "ReactJSX", r[r.ReactJSXDev = 5] = "ReactJSXDev", r))(ov || {}), rv = /* @__PURE__ */ ((r) => (r[r.CarriageReturnLineFeed = 0] = "CarriageReturnLineFeed", r[r.LineFeed = 1] = "LineFeed", r))(rv || {}), av = /* @__PURE__ */ ((r) => (r[r.ES3 = 0] = "ES3", r[r.ES5 = 1] = "ES5", r[r.ES2015 = 2] = "ES2015", r[r.ES2016 = 3] = "ES2016", r[r.ES2017 = 4] = "ES2017", r[r.ES2018 = 5] = "ES2018", r[r.ES2019 = 6] = "ES2019", r[r.ES2020 = 7] = "ES2020", r[r.ESNext = 99] = "ESNext", r[r.JSON = 100] = "JSON", r[
  r.Latest = 99
  /* ESNext */
] = "Latest", r))(av || {}), lv = /* @__PURE__ */ ((r) => (r[r.Classic = 1] = "Classic", r[r.NodeJs = 2] = "NodeJs", r))(lv || {}), dv = class {
  constructor(r, e, t, i, n) {
    this._onDidChange = new Qs.Emitter(), this._onDidExtraLibsChange = new Qs.Emitter(), this._extraLibs = /* @__PURE__ */ Object.create(null), this._removedExtraLibs = /* @__PURE__ */ Object.create(null), this._eagerModelSync = !1, this.setCompilerOptions(r), this.setDiagnosticsOptions(e), this.setWorkerOptions(t), this.setInlayHintsOptions(i), this.setModeConfiguration(n), this._onDidExtraLibsChangeTimeout = -1;
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get onDidExtraLibsChange() {
    return this._onDidExtraLibsChange.event;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get workerOptions() {
    return this._workerOptions;
  }
  get inlayHintsOptions() {
    return this._inlayHintsOptions;
  }
  getExtraLibs() {
    return this._extraLibs;
  }
  addExtraLib(r, e) {
    let t;
    if (typeof e > "u" ? t = `ts:extralib-${Math.random().toString(36).substring(2, 15)}` : t = e, this._extraLibs[t] && this._extraLibs[t].content === r)
      return {
        dispose: () => {
        }
      };
    let i = 1;
    return this._removedExtraLibs[t] && (i = this._removedExtraLibs[t] + 1), this._extraLibs[t] && (i = this._extraLibs[t].version + 1), this._extraLibs[t] = {
      content: r,
      version: i
    }, this._fireOnDidExtraLibsChangeSoon(), {
      dispose: () => {
        let n = this._extraLibs[t];
        n && n.version === i && (delete this._extraLibs[t], this._removedExtraLibs[t] = i, this._fireOnDidExtraLibsChangeSoon());
      }
    };
  }
  setExtraLibs(r) {
    for (const e in this._extraLibs)
      this._removedExtraLibs[e] = this._extraLibs[e].version;
    if (this._extraLibs = /* @__PURE__ */ Object.create(null), r && r.length > 0)
      for (const e of r) {
        const t = e.filePath || `ts:extralib-${Math.random().toString(36).substring(2, 15)}`, i = e.content;
        let n = 1;
        this._removedExtraLibs[t] && (n = this._removedExtraLibs[t] + 1), this._extraLibs[t] = {
          content: i,
          version: n
        };
      }
    this._fireOnDidExtraLibsChangeSoon();
  }
  _fireOnDidExtraLibsChangeSoon() {
    this._onDidExtraLibsChangeTimeout === -1 && (this._onDidExtraLibsChangeTimeout = window.setTimeout(() => {
      this._onDidExtraLibsChangeTimeout = -1, this._onDidExtraLibsChange.fire(void 0);
    }, 0));
  }
  getCompilerOptions() {
    return this._compilerOptions;
  }
  setCompilerOptions(r) {
    this._compilerOptions = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
  getDiagnosticsOptions() {
    return this._diagnosticsOptions;
  }
  setDiagnosticsOptions(r) {
    this._diagnosticsOptions = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
  setWorkerOptions(r) {
    this._workerOptions = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
  setInlayHintsOptions(r) {
    this._inlayHintsOptions = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
  setMaximumWorkerIdleTime(r) {
  }
  setEagerModelSync(r) {
    this._eagerModelSync = r;
  }
  getEagerModelSync() {
    return this._eagerModelSync;
  }
  setModeConfiguration(r) {
    this._modeConfiguration = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
}, T0 = E0, cv = {
  completionItems: !0,
  hovers: !0,
  documentSymbols: !0,
  definitions: !0,
  references: !0,
  documentHighlights: !0,
  rename: !0,
  diagnostics: !0,
  documentRangeFormattingEdits: !0,
  signatureHelp: !0,
  onTypeFormattingEdits: !0,
  codeActions: !0,
  inlayHints: !0
}, hv = new dv(
  {
    allowNonTsExtensions: !0,
    target: 99
    /* Latest */
  },
  { noSemanticValidation: !1, noSyntaxValidation: !1, onlyVisible: !1 },
  {},
  {},
  cv
), uv = new dv(
  {
    allowNonTsExtensions: !0,
    allowJs: !0,
    target: 99
    /* Latest */
  },
  { noSemanticValidation: !0, noSyntaxValidation: !1, onlyVisible: !1 },
  {},
  {},
  cv
), A0 = () => bd().then((r) => r.getTypeScriptWorker()), O0 = () => bd().then((r) => r.getJavaScriptWorker());
Qs.languages.typescript = {
  ModuleKind: sv,
  JsxEmit: ov,
  NewLineKind: rv,
  ScriptTarget: av,
  ModuleResolutionKind: lv,
  typescriptVersion: T0,
  typescriptDefaults: hv,
  javascriptDefaults: uv,
  getTypeScriptWorker: A0,
  getJavaScriptWorker: O0
};
function bd() {
  return import("./tsMode-eQ5-t3Wl.js");
}
Qs.languages.onLanguage("typescript", () => bd().then((r) => r.setupTypeScript(hv)));
Qs.languages.onLanguage("javascript", () => bd().then((r) => r.setupJavaScript(uv)));
class F0 extends rt {
  constructor() {
    super({
      id: "diffEditor.toggleCollapseUnchangedRegions",
      title: $("toggleCollapseUnchangedRegions", "Toggle Collapse Unchanged Regions"),
      icon: j.map,
      toggled: L.has("config.diffEditor.hideUnchangedRegions.enabled"),
      precondition: L.has("isInDiffEditor"),
      menu: {
        when: L.has("isInDiffEditor"),
        id: E.EditorTitle,
        order: 22,
        group: "navigation"
      }
    });
  }
  run(e, ...t) {
    const i = e.get(he), n = !i.getValue("diffEditor.hideUnchangedRegions.enabled");
    i.updateValue("diffEditor.hideUnchangedRegions.enabled", n);
  }
}
ne(F0);
class gv extends rt {
  constructor() {
    super({
      id: "diffEditor.toggleShowMovedCodeBlocks",
      title: $("toggleShowMovedCodeBlocks", "Toggle Show Moved Code Blocks"),
      precondition: L.has("isInDiffEditor")
    });
  }
  run(e, ...t) {
    const i = e.get(he), n = !i.getValue("diffEditor.experimental.showMoves");
    i.updateValue("diffEditor.experimental.showMoves", n);
  }
}
ne(gv);
class pv extends rt {
  constructor() {
    super({
      id: "diffEditor.toggleUseInlineViewWhenSpaceIsLimited",
      title: $("toggleUseInlineViewWhenSpaceIsLimited", "Toggle Use Inline View When Space Is Limited"),
      precondition: L.has("isInDiffEditor")
    });
  }
  run(e, ...t) {
    const i = e.get(he), n = !i.getValue("diffEditor.useInlineViewWhenSpaceIsLimited");
    i.updateValue("diffEditor.useInlineViewWhenSpaceIsLimited", n);
  }
}
ne(pv);
qt.appendMenuItem(E.EditorTitle, {
  command: {
    id: new pv().desc.id,
    title: g("useInlineViewWhenSpaceIsLimited", "Use Inline View When Space Is Limited"),
    toggled: L.has("config.diffEditor.useInlineViewWhenSpaceIsLimited"),
    precondition: L.has("isInDiffEditor")
  },
  order: 11,
  group: "1_diff",
  when: L.and(b.diffEditorRenderSideBySideInlineBreakpointReached, L.has("isInDiffEditor"))
});
qt.appendMenuItem(E.EditorTitle, {
  command: {
    id: new gv().desc.id,
    title: g("showMoves", "Show Moved Code Blocks"),
    icon: j.move,
    toggled: XC.create("config.diffEditor.experimental.showMoves", !0),
    precondition: L.has("isInDiffEditor")
  },
  order: 10,
  group: "1_diff",
  when: L.has("isInDiffEditor")
});
const Cd = $("diffEditor", "Diff Editor");
class W0 extends Kt {
  constructor() {
    super({
      id: "diffEditor.switchSide",
      title: $("switchSide", "Switch Side"),
      icon: j.arrowSwap,
      precondition: L.has("isInDiffEditor"),
      f1: !0,
      category: Cd
    });
  }
  runEditorCommand(e, t, i) {
    const n = vo(e);
    if (n instanceof td) {
      if (i && i.dryRun)
        return { destinationSelection: n.mapToOtherSide().destinationSelection };
      n.switchSide();
    }
  }
}
ne(W0);
class H0 extends Kt {
  constructor() {
    super({
      id: "diffEditor.exitCompareMove",
      title: $("exitCompareMove", "Exit Compare Move"),
      icon: j.close,
      precondition: b.comparingMovedCode,
      f1: !1,
      category: Cd,
      keybinding: {
        weight: 1e4,
        primary: 9
      }
    });
  }
  runEditorCommand(e, t, ...i) {
    const n = vo(e);
    n instanceof td && n.exitCompareMove();
  }
}
ne(H0);
class B0 extends Kt {
  constructor() {
    super({
      id: "diffEditor.collapseAllUnchangedRegions",
      title: $("collapseAllUnchangedRegions", "Collapse All Unchanged Regions"),
      icon: j.fold,
      precondition: L.has("isInDiffEditor"),
      f1: !0,
      category: Cd
    });
  }
  runEditorCommand(e, t, ...i) {
    const n = vo(e);
    n instanceof td && n.collapseAllUnchangedRegions();
  }
}
ne(B0);
class V0 extends Kt {
  constructor() {
    super({
      id: "diffEditor.showAllUnchangedRegions",
      title: $("showAllUnchangedRegions", "Show All Unchanged Regions"),
      icon: j.unfold,
      precondition: L.has("isInDiffEditor"),
      f1: !0,
      category: Cd
    });
  }
  runEditorCommand(e, t, ...i) {
    const n = vo(e);
    n instanceof td && n.showAllUnchangedRegions();
  }
}
ne(V0);
const fv = $("accessibleDiffViewer", "Accessible Diff Viewer");
class _o extends rt {
  constructor() {
    super({
      id: _o.id,
      title: $("editor.action.accessibleDiffViewer.next", "Go to Next Difference"),
      category: fv,
      precondition: L.has("isInDiffEditor"),
      keybinding: {
        primary: 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: !0
    });
  }
  run(e) {
    const t = vo(e);
    t == null || t.accessibleDiffViewerNext();
  }
}
_o.id = "editor.action.accessibleDiffViewer.next";
qt.appendMenuItem(E.EditorTitle, {
  command: {
    id: _o.id,
    title: g("Open Accessible Diff Viewer", "Open Accessible Diff Viewer"),
    precondition: L.has("isInDiffEditor")
  },
  order: 10,
  group: "2_diff",
  when: L.and(b.accessibleDiffViewerVisible.negate(), L.has("isInDiffEditor"))
});
class aa extends rt {
  constructor() {
    super({
      id: aa.id,
      title: $("editor.action.accessibleDiffViewer.prev", "Go to Previous Difference"),
      category: fv,
      precondition: L.has("isInDiffEditor"),
      keybinding: {
        primary: 1089,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: !0
    });
  }
  run(e) {
    const t = vo(e);
    t == null || t.accessibleDiffViewerPrev();
  }
}
aa.id = "editor.action.accessibleDiffViewer.prev";
function vo(r) {
  const t = r.get(_e).listDiffEditors(), i = Em();
  if (i)
    for (const n of t) {
      const s = n.getContainerDomNode();
      if (U0(s, i))
        return n;
    }
  return null;
}
function U0(r, e) {
  let t = e;
  for (; t; ) {
    if (t === r)
      return !0;
    t = t.parentElement;
  }
  return !1;
}
de.registerCommandAlias("editor.action.diffReview.next", _o.id);
ne(_o);
de.registerCommandAlias("editor.action.diffReview.prev", aa.id);
ne(aa);
var z0 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, $0 = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, lh;
const Sd = new Q("selectionAnchorSet", !1);
let Ni = lh = class {
  static get(e) {
    return e.getContribution(lh.ID);
  }
  constructor(e, t) {
    this.editor = e, this.selectionAnchorSetContextKey = Sd.bindTo(t), this.modelChangeListener = e.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
  }
  setSelectionAnchor() {
    if (this.editor.hasModel()) {
      const e = this.editor.getPosition();
      this.editor.changeDecorations((t) => {
        this.decorationId && t.removeDecoration(this.decorationId), this.decorationId = t.addDecoration(z.fromPositions(e, e), {
          description: "selection-anchor",
          stickiness: 1,
          hoverMessage: new Ue().appendText(g("selectionAnchor", "Selection Anchor")),
          className: "selection-anchor"
        });
      }), this.selectionAnchorSetContextKey.set(!!this.decorationId), xt(g("anchorSet", "Anchor set at {0}:{1}", e.lineNumber, e.column));
    }
  }
  goToSelectionAnchor() {
    if (this.editor.hasModel() && this.decorationId) {
      const e = this.editor.getModel().getDecorationRange(this.decorationId);
      e && this.editor.setPosition(e.getStartPosition());
    }
  }
  selectFromAnchorToCursor() {
    if (this.editor.hasModel() && this.decorationId) {
      const e = this.editor.getModel().getDecorationRange(this.decorationId);
      if (e) {
        const t = this.editor.getPosition();
        this.editor.setSelection(z.fromPositions(e.getStartPosition(), t)), this.cancelSelectionAnchor();
      }
    }
  }
  cancelSelectionAnchor() {
    if (this.decorationId) {
      const e = this.decorationId;
      this.editor.changeDecorations((t) => {
        t.removeDecoration(e), this.decorationId = void 0;
      }), this.selectionAnchorSetContextKey.set(!1);
    }
  }
  dispose() {
    this.cancelSelectionAnchor(), this.modelChangeListener.dispose();
  }
};
Ni.ID = "editor.contrib.selectionAnchorController";
Ni = lh = z0([
  $0(1, ee)
], Ni);
class j0 extends D {
  constructor() {
    super({
      id: "editor.action.setSelectionAnchor",
      label: g("setSelectionAnchor", "Set Selection Anchor"),
      alias: "Set Selection Anchor",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2080
          /* KeyCode.KeyB */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    var i;
    (i = Ni.get(t)) === null || i === void 0 || i.setSelectionAnchor();
  }
}
class q0 extends D {
  constructor() {
    super({
      id: "editor.action.goToSelectionAnchor",
      label: g("goToSelectionAnchor", "Go to Selection Anchor"),
      alias: "Go to Selection Anchor",
      precondition: Sd
    });
  }
  async run(e, t) {
    var i;
    (i = Ni.get(t)) === null || i === void 0 || i.goToSelectionAnchor();
  }
}
class K0 extends D {
  constructor() {
    super({
      id: "editor.action.selectFromAnchorToCursor",
      label: g("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
      alias: "Select from Anchor to Cursor",
      precondition: Sd,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2089
          /* KeyCode.KeyK */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    var i;
    (i = Ni.get(t)) === null || i === void 0 || i.selectFromAnchorToCursor();
  }
}
class G0 extends D {
  constructor() {
    super({
      id: "editor.action.cancelSelectionAnchor",
      label: g("cancelSelectionAnchor", "Cancel Selection Anchor"),
      alias: "Cancel Selection Anchor",
      precondition: Sd,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    var i;
    (i = Ni.get(t)) === null || i === void 0 || i.cancelSelectionAnchor();
  }
}
Z(
  Ni.ID,
  Ni,
  4
  /* EditorContributionInstantiation.Lazy */
);
x(j0);
x(q0);
x(K0);
x(G0);
const Z0 = W("editorOverviewRuler.bracketMatchForeground", { dark: "#A0A0A0", light: "#A0A0A0", hcDark: "#A0A0A0", hcLight: "#A0A0A0" }, g("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
class X0 extends D {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: g("smartSelect.jumpBracket", "Go to Bracket"),
      alias: "Go to Bracket",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 3165,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    var i;
    (i = Nt.get(t)) === null || i === void 0 || i.jumpToBracket();
  }
}
class Q0 extends D {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: g("smartSelect.selectToBracket", "Select to Bracket"),
      alias: "Select to Bracket",
      precondition: void 0,
      metadata: {
        description: $("smartSelect.selectToBracketDescription", "Select the text inside and including the brackets or curly braces"),
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              selectBrackets: {
                type: "boolean",
                default: !0
              }
            }
          }
        }]
      }
    });
  }
  run(e, t, i) {
    var n;
    let s = !0;
    i && i.selectBrackets === !1 && (s = !1), (n = Nt.get(t)) === null || n === void 0 || n.selectToBracket(s);
  }
}
class Y0 extends D {
  constructor() {
    super({
      id: "editor.action.removeBrackets",
      label: g("smartSelect.removeBrackets", "Remove Brackets"),
      alias: "Remove Brackets",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 2561,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    var i;
    (i = Nt.get(t)) === null || i === void 0 || i.removeBrackets(this.id);
  }
}
class J0 {
  constructor(e, t, i) {
    this.position = e, this.brackets = t, this.options = i;
  }
}
class Nt extends P {
  static get(e) {
    return e.getContribution(Nt.ID);
  }
  constructor(e) {
    super(), this._editor = e, this._lastBracketsData = [], this._lastVersionId = 0, this._decorations = this._editor.createDecorationsCollection(), this._updateBracketsSoon = this._register(new Re(() => this._updateBrackets(), 50)), this._matchBrackets = this._editor.getOption(
      72
      /* EditorOption.matchBrackets */
    ), this._updateBracketsSoon.schedule(), this._register(e.onDidChangeCursorPosition((t) => {
      this._matchBrackets !== "never" && this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModelContent((t) => {
      this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModel((t) => {
      this._lastBracketsData = [], this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModelLanguageConfiguration((t) => {
      this._lastBracketsData = [], this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeConfiguration((t) => {
      t.hasChanged(
        72
        /* EditorOption.matchBrackets */
      ) && (this._matchBrackets = this._editor.getOption(
        72
        /* EditorOption.matchBrackets */
      ), this._decorations.clear(), this._lastBracketsData = [], this._lastVersionId = 0, this._updateBracketsSoon.schedule());
    })), this._register(e.onDidBlurEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    })), this._register(e.onDidFocusEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
  }
  jumpToBracket() {
    if (!this._editor.hasModel())
      return;
    const e = this._editor.getModel(), t = this._editor.getSelections().map((i) => {
      const n = i.getStartPosition(), s = e.bracketPairs.matchBracket(n);
      let o = null;
      if (s)
        s[0].containsPosition(n) && !s[1].containsPosition(n) ? o = s[1].getStartPosition() : s[1].containsPosition(n) && (o = s[0].getStartPosition());
      else {
        const a = e.bracketPairs.findEnclosingBrackets(n);
        if (a)
          o = a[1].getStartPosition();
        else {
          const l = e.bracketPairs.findNextBracket(n);
          l && l.range && (o = l.range.getStartPosition());
        }
      }
      return o ? new z(o.lineNumber, o.column, o.lineNumber, o.column) : new z(n.lineNumber, n.column, n.lineNumber, n.column);
    });
    this._editor.setSelections(t), this._editor.revealRange(t[0]);
  }
  selectToBracket(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel(), i = [];
    this._editor.getSelections().forEach((n) => {
      const s = n.getStartPosition();
      let o = t.bracketPairs.matchBracket(s);
      if (!o && (o = t.bracketPairs.findEnclosingBrackets(s), !o)) {
        const d = t.bracketPairs.findNextBracket(s);
        d && d.range && (o = t.bracketPairs.matchBracket(d.range.getStartPosition()));
      }
      let a = null, l = null;
      if (o) {
        o.sort(S.compareRangesUsingStarts);
        const [d, c] = o;
        if (a = e ? d.getStartPosition() : d.getEndPosition(), l = e ? c.getEndPosition() : c.getStartPosition(), c.containsPosition(s)) {
          const h = a;
          a = l, l = h;
        }
      }
      a && l && i.push(new z(a.lineNumber, a.column, l.lineNumber, l.column));
    }), i.length > 0 && (this._editor.setSelections(i), this._editor.revealRange(i[0]));
  }
  removeBrackets(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel();
    this._editor.getSelections().forEach((i) => {
      const n = i.getPosition();
      let s = t.bracketPairs.matchBracket(n);
      s || (s = t.bracketPairs.findEnclosingBrackets(n)), s && (this._editor.pushUndoStop(), this._editor.executeEdits(e, [
        { range: s[0], text: "" },
        { range: s[1], text: "" }
      ]), this._editor.pushUndoStop());
    });
  }
  _updateBrackets() {
    if (this._matchBrackets === "never")
      return;
    this._recomputeBrackets();
    const e = [];
    let t = 0;
    for (const i of this._lastBracketsData) {
      const n = i.brackets;
      n && (e[t++] = { range: n[0], options: i.options }, e[t++] = { range: n[1], options: i.options });
    }
    this._decorations.set(e);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
      this._lastBracketsData = [], this._lastVersionId = 0;
      return;
    }
    const e = this._editor.getSelections();
    if (e.length > 100) {
      this._lastBracketsData = [], this._lastVersionId = 0;
      return;
    }
    const t = this._editor.getModel(), i = t.getVersionId();
    let n = [];
    this._lastVersionId === i && (n = this._lastBracketsData);
    const s = [];
    let o = 0;
    for (let h = 0, u = e.length; h < u; h++) {
      const p = e[h];
      p.isEmpty() && (s[o++] = p.getStartPosition());
    }
    s.length > 1 && s.sort(F.compare);
    const a = [];
    let l = 0, d = 0;
    const c = n.length;
    for (let h = 0, u = s.length; h < u; h++) {
      const p = s[h];
      for (; d < c && n[d].position.isBefore(p); )
        d++;
      if (d < c && n[d].position.equals(p))
        a[l++] = n[d];
      else {
        let f = t.bracketPairs.matchBracket(
          p,
          20
          /* give at most 20ms to compute */
        ), m = Nt._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        !f && this._matchBrackets === "always" && (f = t.bracketPairs.findEnclosingBrackets(
          p,
          20
          /* give at most 20ms to compute */
        ), m = Nt._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER), a[l++] = new J0(p, f, m);
      }
    }
    this._lastBracketsData = a, this._lastVersionId = i;
  }
}
Nt.ID = "editor.contrib.bracketMatchingController";
Nt._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = Y.register({
  description: "bracket-match-overview",
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: Se(Z0),
    position: ci.Center
  }
});
Nt._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = Y.register({
  description: "bracket-match-no-overview",
  stickiness: 1,
  className: "bracket-match"
});
Z(
  Nt.ID,
  Nt,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
x(Q0);
x(X0);
x(Y0);
qt.appendMenuItem(E.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: g({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
  },
  order: 2
});
class ex {
  constructor(e, t) {
    this._selection = e, this._isMovingLeft = t;
  }
  getEditOperations(e, t) {
    if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty())
      return;
    const i = this._selection.startLineNumber, n = this._selection.startColumn, s = this._selection.endColumn;
    if (!(this._isMovingLeft && n === 1) && !(!this._isMovingLeft && s === e.getLineMaxColumn(i)))
      if (this._isMovingLeft) {
        const o = new S(i, n - 1, i, n), a = e.getValueInRange(o);
        t.addEditOperation(o, null), t.addEditOperation(new S(i, s, i, s), a);
      } else {
        const o = new S(i, s, i, s + 1), a = e.getValueInRange(o);
        t.addEditOperation(o, null), t.addEditOperation(new S(i, n, i, n), a);
      }
  }
  computeCursorState(e, t) {
    return this._isMovingLeft ? new z(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1) : new z(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
  }
}
class mv extends D {
  constructor(e, t) {
    super(t), this.left = e;
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = [], n = t.getSelections();
    for (const s of n)
      i.push(new ex(s, this.left));
    t.pushUndoStop(), t.executeCommands(this.id, i), t.pushUndoStop();
  }
}
class tx extends mv {
  constructor() {
    super(!0, {
      id: "editor.action.moveCarretLeftAction",
      label: g("caret.moveLeft", "Move Selected Text Left"),
      alias: "Move Selected Text Left",
      precondition: b.writable
    });
  }
}
class ix extends mv {
  constructor() {
    super(!1, {
      id: "editor.action.moveCarretRightAction",
      label: g("caret.moveRight", "Move Selected Text Right"),
      alias: "Move Selected Text Right",
      precondition: b.writable
    });
  }
}
x(tx);
x(ix);
class nx extends D {
  constructor() {
    super({
      id: "editor.action.transposeLetters",
      label: g("transposeLetters.label", "Transpose Letters"),
      alias: "Transpose Letters",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: {
          primary: 306
          /* KeyCode.KeyT */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel(), n = [], s = t.getSelections();
    for (const o of s) {
      if (!o.isEmpty())
        continue;
      const a = o.startLineNumber, l = o.startColumn, d = i.getLineMaxColumn(a);
      if (a === 1 && (l === 1 || l === 2 && d === 2))
        continue;
      const c = l === d ? o.getPosition() : pc.rightPosition(i, o.getPosition().lineNumber, o.getPosition().column), h = pc.leftPosition(i, c), u = pc.leftPosition(i, h), p = i.getValueInRange(S.fromPositions(u, h)), f = i.getValueInRange(S.fromPositions(h, c)), m = S.fromPositions(u, c);
      n.push(new Gr(m, f + p));
    }
    n.length > 0 && (t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop());
  }
}
x(nx);
const wd = function() {
  if (typeof crypto == "object" && typeof crypto.randomUUID == "function")
    return crypto.randomUUID.bind(crypto);
  let r;
  typeof crypto == "object" && typeof crypto.getRandomValues == "function" ? r = crypto.getRandomValues.bind(crypto) : r = function(i) {
    for (let n = 0; n < i.length; n++)
      i[n] = Math.floor(Math.random() * 256);
    return i;
  };
  const e = new Uint8Array(16), t = [];
  for (let i = 0; i < 256; i++)
    t.push(i.toString(16).padStart(2, "0"));
  return function() {
    r(e), e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
    let n = 0, s = "";
    return s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += "-", s += t[e[n++]], s += t[e[n++]], s += "-", s += t[e[n++]], s += t[e[n++]], s += "-", s += t[e[n++]], s += t[e[n++]], s += "-", s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s;
  };
}();
function kg(r) {
  return {
    asString: async () => r,
    asFile: () => {
    },
    value: typeof r == "string" ? r : void 0
  };
}
function sx(r, e, t) {
  const i = { id: wd(), name: r, uri: e, data: t };
  return {
    asString: async () => "",
    asFile: () => i,
    value: void 0
  };
}
class _v {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  get size() {
    let e = 0;
    for (const t of this._entries)
      e++;
    return e;
  }
  has(e) {
    return this._entries.has(this.toKey(e));
  }
  matches(e) {
    const t = [...this._entries.keys()];
    return Si.some(this, ([i, n]) => n.asFile()) && t.push("files"), bv(Dl(e), t);
  }
  get(e) {
    var t;
    return (t = this._entries.get(this.toKey(e))) === null || t === void 0 ? void 0 : t[0];
  }
  /**
   * Add a new entry to this data transfer.
   *
   * This does not replace existing entries for `mimeType`.
   */
  append(e, t) {
    const i = this._entries.get(e);
    i ? i.push(t) : this._entries.set(this.toKey(e), [t]);
  }
  /**
   * Set the entry for a given mime type.
   *
   * This replaces all existing entries for `mimeType`.
   */
  replace(e, t) {
    this._entries.set(this.toKey(e), [t]);
  }
  /**
   * Remove all entries for `mimeType`.
   */
  delete(e) {
    this._entries.delete(this.toKey(e));
  }
  /**
   * Iterate over all `[mime, item]` pairs in this data transfer.
   *
   * There may be multiple entries for each mime type.
   */
  *[Symbol.iterator]() {
    for (const [e, t] of this._entries)
      for (const i of t)
        yield [e, i];
  }
  toKey(e) {
    return Dl(e);
  }
}
function Dl(r) {
  return r.toLowerCase();
}
function vv(r, e) {
  return bv(Dl(r), e.map(Dl));
}
function bv(r, e) {
  if (r === "*/*")
    return e.length > 0;
  if (e.includes(r))
    return !0;
  const t = r.match(/^([a-z]+)\/([a-z]+|\*)$/i);
  if (!t)
    return !1;
  const [i, n, s] = t;
  return s === "*" ? e.some((o) => o.startsWith(n + "/")) : !1;
}
const yd = Object.freeze({
  // http://amundsen.com/hypermedia/urilist/
  create: (r) => Tm(r.map((e) => e.toString())).join(`\r
`),
  split: (r) => r.split(`\r
`),
  parse: (r) => yd.split(r).filter((e) => !e.startsWith("#"))
}), nf = {
  EDITORS: "CodeEditors",
  FILES: "CodeFiles"
};
class ox {
}
const rx = {
  DragAndDropContribution: "workbench.contributions.dragAndDrop"
};
hi.add(rx.DragAndDropContribution, new ox());
class Sr {
  constructor() {
  }
  static getInstance() {
    return Sr.INSTANCE;
  }
  hasData(e) {
    return e && e === this.proto;
  }
  getData(e) {
    if (this.hasData(e))
      return this.data;
  }
}
Sr.INSTANCE = new Sr();
function Cv(r) {
  const e = new _v();
  for (const t of r.items) {
    const i = t.type;
    if (t.kind === "string") {
      const n = new Promise((s) => t.getAsString(s));
      e.append(i, kg(n));
    } else if (t.kind === "file") {
      const n = t.getAsFile();
      n && e.append(i, ax(n));
    }
  }
  return e;
}
function ax(r) {
  const e = r.path ? ce.parse(r.path) : void 0;
  return sx(r.name, e, async () => new Uint8Array(await r.arrayBuffer()));
}
const lx = Object.freeze([
  nf.EDITORS,
  nf.FILES,
  eh.RESOURCES,
  eh.INTERNAL_URI_LIST
]);
function Sv(r, e = !1) {
  const t = Cv(r), i = t.get(eh.INTERNAL_URI_LIST);
  if (i)
    t.replace(Te.uriList, i);
  else if (e || !t.has(Te.uriList)) {
    const n = [];
    for (const s of r.items) {
      const o = s.getAsFile();
      if (o) {
        const a = o.path;
        try {
          a ? n.push(ce.file(a).toString()) : n.push(ce.parse(o.name, !0).toString());
        } catch {
        }
      }
    }
    n.length && t.replace(Te.uriList, kg(yd.create(n)));
  }
  for (const n of lx)
    t.delete(n);
  return t;
}
class It {
  constructor() {
    this.value = "", this.pos = 0;
  }
  static isDigitCharacter(e) {
    return e >= 48 && e <= 57;
  }
  static isVariableCharacter(e) {
    return e === 95 || e >= 97 && e <= 122 || e >= 65 && e <= 90;
  }
  text(e) {
    this.value = e, this.pos = 0;
  }
  tokenText(e) {
    return this.value.substr(e.pos, e.len);
  }
  next() {
    if (this.pos >= this.value.length)
      return { type: 14, pos: this.pos, len: 0 };
    const e = this.pos;
    let t = 0, i = this.value.charCodeAt(e), n;
    if (n = It._table[i], typeof n == "number")
      return this.pos += 1, { type: n, pos: e, len: 1 };
    if (It.isDigitCharacter(i)) {
      n = 8;
      do
        t += 1, i = this.value.charCodeAt(e + t);
      while (It.isDigitCharacter(i));
      return this.pos += t, { type: n, pos: e, len: t };
    }
    if (It.isVariableCharacter(i)) {
      n = 9;
      do
        i = this.value.charCodeAt(e + ++t);
      while (It.isVariableCharacter(i) || It.isDigitCharacter(i));
      return this.pos += t, { type: n, pos: e, len: t };
    }
    n = 10;
    do
      t += 1, i = this.value.charCodeAt(e + t);
    while (!isNaN(i) && typeof It._table[i] > "u" && !It.isDigitCharacter(i) && !It.isVariableCharacter(i));
    return this.pos += t, { type: n, pos: e, len: t };
  }
}
It._table = {
  36: 0,
  58: 1,
  44: 2,
  123: 3,
  125: 4,
  92: 5,
  47: 6,
  124: 7,
  43: 11,
  45: 12,
  63: 13
};
class bo {
  constructor() {
    this._children = [];
  }
  appendChild(e) {
    return e instanceof ze && this._children[this._children.length - 1] instanceof ze ? this._children[this._children.length - 1].value += e.value : (e.parent = this, this._children.push(e)), this;
  }
  replace(e, t) {
    const { parent: i } = e, n = i.children.indexOf(e), s = i.children.slice(0);
    s.splice(n, 1, ...t), i._children = s, function o(a, l) {
      for (const d of a)
        d.parent = l, o(d.children, d);
    }(t, i);
  }
  get children() {
    return this._children;
  }
  get rightMostDescendant() {
    return this._children.length > 0 ? this._children[this._children.length - 1].rightMostDescendant : this;
  }
  get snippet() {
    let e = this;
    for (; ; ) {
      if (!e)
        return;
      if (e instanceof la)
        return e;
      e = e.parent;
    }
  }
  toString() {
    return this.children.reduce((e, t) => e + t.toString(), "");
  }
  len() {
    return 0;
  }
}
class ze extends bo {
  constructor(e) {
    super(), this.value = e;
  }
  toString() {
    return this.value;
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new ze(this.value);
  }
}
class wv extends bo {
}
class St extends wv {
  static compareByIndex(e, t) {
    return e.index === t.index ? 0 : e.isFinalTabstop ? 1 : t.isFinalTabstop || e.index < t.index ? -1 : e.index > t.index ? 1 : 0;
  }
  constructor(e) {
    super(), this.index = e;
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Co ? this._children[0] : void 0;
  }
  clone() {
    const e = new St(this.index);
    return this.transform && (e.transform = this.transform.clone()), e._children = this.children.map((t) => t.clone()), e;
  }
}
class Co extends bo {
  constructor() {
    super(...arguments), this.options = [];
  }
  appendChild(e) {
    return e instanceof ze && (e.parent = this, this.options.push(e)), this;
  }
  toString() {
    return this.options[0].value;
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    const e = new Co();
    return this.options.forEach(e.appendChild, e), e;
  }
}
class Ng extends bo {
  constructor() {
    super(...arguments), this.regexp = new RegExp("");
  }
  resolve(e) {
    const t = this;
    let i = !1, n = e.replace(this.regexp, function() {
      return i = !0, t._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    return !i && this._children.some((s) => s instanceof Ot && !!s.elseValue) && (n = this._replace([])), n;
  }
  _replace(e) {
    let t = "";
    for (const i of this._children)
      if (i instanceof Ot) {
        let n = e[i.index] || "";
        n = i.resolve(n), t += n;
      } else
        t += i.toString();
    return t;
  }
  toString() {
    return "";
  }
  clone() {
    const e = new Ng();
    return e.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")), e._children = this.children.map((t) => t.clone()), e;
  }
}
class Ot extends bo {
  constructor(e, t, i, n) {
    super(), this.index = e, this.shorthandName = t, this.ifValue = i, this.elseValue = n;
  }
  resolve(e) {
    return this.shorthandName === "upcase" ? e ? e.toLocaleUpperCase() : "" : this.shorthandName === "downcase" ? e ? e.toLocaleLowerCase() : "" : this.shorthandName === "capitalize" ? e ? e[0].toLocaleUpperCase() + e.substr(1) : "" : this.shorthandName === "pascalcase" ? e ? this._toPascalCase(e) : "" : this.shorthandName === "camelcase" ? e ? this._toCamelCase(e) : "" : e && typeof this.ifValue == "string" ? this.ifValue : !e && typeof this.elseValue == "string" ? this.elseValue : e || "";
  }
  _toPascalCase(e) {
    const t = e.match(/[a-z0-9]+/gi);
    return t ? t.map((i) => i.charAt(0).toUpperCase() + i.substr(1)).join("") : e;
  }
  _toCamelCase(e) {
    const t = e.match(/[a-z0-9]+/gi);
    return t ? t.map((i, n) => n === 0 ? i.charAt(0).toLowerCase() + i.substr(1) : i.charAt(0).toUpperCase() + i.substr(1)).join("") : e;
  }
  clone() {
    return new Ot(this.index, this.shorthandName, this.ifValue, this.elseValue);
  }
}
class wr extends wv {
  constructor(e) {
    super(), this.name = e;
  }
  resolve(e) {
    let t = e.resolve(this);
    return this.transform && (t = this.transform.resolve(t || "")), t !== void 0 ? (this._children = [new ze(t)], !0) : !1;
  }
  clone() {
    const e = new wr(this.name);
    return this.transform && (e.transform = this.transform.clone()), e._children = this.children.map((t) => t.clone()), e;
  }
}
function sf(r, e) {
  const t = [...r];
  for (; t.length > 0; ) {
    const i = t.shift();
    if (!e(i))
      break;
    t.unshift(...i.children);
  }
}
class la extends bo {
  get placeholderInfo() {
    if (!this._placeholders) {
      const e = [];
      let t;
      this.walk(function(i) {
        return i instanceof St && (e.push(i), t = !t || t.index < i.index ? i : t), !0;
      }), this._placeholders = { all: e, last: t };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all: e } = this.placeholderInfo;
    return e;
  }
  offset(e) {
    let t = 0, i = !1;
    return this.walk((n) => n === e ? (i = !0, !1) : (t += n.len(), !0)), i ? t : -1;
  }
  fullLen(e) {
    let t = 0;
    return sf([e], (i) => (t += i.len(), !0)), t;
  }
  enclosingPlaceholders(e) {
    const t = [];
    let { parent: i } = e;
    for (; i; )
      i instanceof St && t.push(i), i = i.parent;
    return t;
  }
  resolveVariables(e) {
    return this.walk((t) => (t instanceof wr && t.resolve(e) && (this._placeholders = void 0), !0)), this;
  }
  appendChild(e) {
    return this._placeholders = void 0, super.appendChild(e);
  }
  replace(e, t) {
    return this._placeholders = void 0, super.replace(e, t);
  }
  clone() {
    const e = new la();
    return this._children = this.children.map((t) => t.clone()), e;
  }
  walk(e) {
    sf(this.children, e);
  }
}
class Un {
  constructor() {
    this._scanner = new It(), this._token = { type: 14, pos: 0, len: 0 };
  }
  static escape(e) {
    return e.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(e) {
    return /\${?CLIPBOARD/.test(e);
  }
  parse(e, t, i) {
    const n = new la();
    return this.parseFragment(e, n), this.ensureFinalTabstop(n, i ?? !1, t ?? !1), n;
  }
  parseFragment(e, t) {
    const i = t.children.length;
    for (this._scanner.text(e), this._token = this._scanner.next(); this._parse(t); )
      ;
    const n = /* @__PURE__ */ new Map(), s = [];
    t.walk((l) => (l instanceof St && (l.isFinalTabstop ? n.set(0, void 0) : !n.has(l.index) && l.children.length > 0 ? n.set(l.index, l.children) : s.push(l)), !0));
    const o = (l, d) => {
      const c = n.get(l.index);
      if (!c)
        return;
      const h = new St(l.index);
      h.transform = l.transform;
      for (const u of c) {
        const p = u.clone();
        h.appendChild(p), p instanceof St && n.has(p.index) && !d.has(p.index) && (d.add(p.index), o(p, d), d.delete(p.index));
      }
      t.replace(l, [h]);
    }, a = /* @__PURE__ */ new Set();
    for (const l of s)
      o(l, a);
    return t.children.slice(i);
  }
  ensureFinalTabstop(e, t, i) {
    (t || i && e.placeholders.length > 0) && (e.placeholders.find((s) => s.index === 0) || e.appendChild(new St(0)));
  }
  _accept(e, t) {
    if (e === void 0 || this._token.type === e) {
      const i = t ? this._scanner.tokenText(this._token) : !0;
      return this._token = this._scanner.next(), i;
    }
    return !1;
  }
  _backTo(e) {
    return this._scanner.pos = e.pos + e.len, this._token = e, !1;
  }
  _until(e) {
    const t = this._token;
    for (; this._token.type !== e; ) {
      if (this._token.type === 14)
        return !1;
      if (this._token.type === 5) {
        const n = this._scanner.next();
        if (n.type !== 0 && n.type !== 4 && n.type !== 5)
          return !1;
      }
      this._token = this._scanner.next();
    }
    const i = this._scanner.value.substring(t.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    return this._token = this._scanner.next(), i;
  }
  _parse(e) {
    return this._parseEscaped(e) || this._parseTabstopOrVariableName(e) || this._parseComplexPlaceholder(e) || this._parseComplexVariable(e) || this._parseAnything(e);
  }
  // \$, \\, \} -> just text
  _parseEscaped(e) {
    let t;
    return (t = this._accept(5, !0)) ? (t = this._accept(0, !0) || this._accept(4, !0) || this._accept(5, !0) || t, e.appendChild(new ze(t)), !0) : !1;
  }
  // $foo -> variable, $1 -> tabstop
  _parseTabstopOrVariableName(e) {
    let t;
    const i = this._token;
    return this._accept(
      0
      /* TokenType.Dollar */
    ) && (t = this._accept(9, !0) || this._accept(8, !0)) ? (e.appendChild(/^\d+$/.test(t) ? new St(Number(t)) : new wr(t)), !0) : this._backTo(i);
  }
  // ${1:<children>}, ${1} -> placeholder
  _parseComplexPlaceholder(e) {
    let t;
    const i = this._token;
    if (!(this._accept(
      0
      /* TokenType.Dollar */
    ) && this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (t = this._accept(8, !0))))
      return this._backTo(i);
    const s = new St(Number(t));
    if (this._accept(
      1
      /* TokenType.Colon */
    ))
      for (; ; ) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(s), !0;
        if (!this._parse(s))
          return e.appendChild(new ze("${" + t + ":")), s.children.forEach(e.appendChild, e), !0;
      }
    else if (s.index > 0 && this._accept(
      7
      /* TokenType.Pipe */
    )) {
      const o = new Co();
      for (; ; ) {
        if (this._parseChoiceElement(o)) {
          if (this._accept(
            2
            /* TokenType.Comma */
          ))
            continue;
          if (this._accept(
            7
            /* TokenType.Pipe */
          ) && (s.appendChild(o), this._accept(
            4
            /* TokenType.CurlyClose */
          )))
            return e.appendChild(s), !0;
        }
        return this._backTo(i), !1;
      }
    } else
      return this._accept(
        6
        /* TokenType.Forwardslash */
      ) ? this._parseTransform(s) ? (e.appendChild(s), !0) : (this._backTo(i), !1) : this._accept(
        4
        /* TokenType.CurlyClose */
      ) ? (e.appendChild(s), !0) : this._backTo(i);
  }
  _parseChoiceElement(e) {
    const t = this._token, i = [];
    for (; !(this._token.type === 2 || this._token.type === 7); ) {
      let n;
      if ((n = this._accept(5, !0)) ? n = this._accept(2, !0) || this._accept(7, !0) || this._accept(5, !0) || n : n = this._accept(void 0, !0), !n)
        return this._backTo(t), !1;
      i.push(n);
    }
    return i.length === 0 ? (this._backTo(t), !1) : (e.appendChild(new ze(i.join(""))), !0);
  }
  // ${foo:<children>}, ${foo} -> variable
  _parseComplexVariable(e) {
    let t;
    const i = this._token;
    if (!(this._accept(
      0
      /* TokenType.Dollar */
    ) && this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (t = this._accept(9, !0))))
      return this._backTo(i);
    const s = new wr(t);
    if (this._accept(
      1
      /* TokenType.Colon */
    ))
      for (; ; ) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(s), !0;
        if (!this._parse(s))
          return e.appendChild(new ze("${" + t + ":")), s.children.forEach(e.appendChild, e), !0;
      }
    else
      return this._accept(
        6
        /* TokenType.Forwardslash */
      ) ? this._parseTransform(s) ? (e.appendChild(s), !0) : (this._backTo(i), !1) : this._accept(
        4
        /* TokenType.CurlyClose */
      ) ? (e.appendChild(s), !0) : this._backTo(i);
  }
  _parseTransform(e) {
    const t = new Ng();
    let i = "", n = "";
    for (; !this._accept(
      6
      /* TokenType.Forwardslash */
    ); ) {
      let s;
      if (s = this._accept(5, !0)) {
        s = this._accept(6, !0) || s, i += s;
        continue;
      }
      if (this._token.type !== 14) {
        i += this._accept(void 0, !0);
        continue;
      }
      return !1;
    }
    for (; !this._accept(
      6
      /* TokenType.Forwardslash */
    ); ) {
      let s;
      if (s = this._accept(5, !0)) {
        s = this._accept(5, !0) || this._accept(6, !0) || s, t.appendChild(new ze(s));
        continue;
      }
      if (!(this._parseFormatString(t) || this._parseAnything(t)))
        return !1;
    }
    for (; !this._accept(
      4
      /* TokenType.CurlyClose */
    ); ) {
      if (this._token.type !== 14) {
        n += this._accept(void 0, !0);
        continue;
      }
      return !1;
    }
    try {
      t.regexp = new RegExp(i, n);
    } catch {
      return !1;
    }
    return e.transform = t, !0;
  }
  _parseFormatString(e) {
    const t = this._token;
    if (!this._accept(
      0
      /* TokenType.Dollar */
    ))
      return !1;
    let i = !1;
    this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (i = !0);
    const n = this._accept(8, !0);
    if (n)
      if (i) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(new Ot(Number(n))), !0;
        if (!this._accept(
          1
          /* TokenType.Colon */
        ))
          return this._backTo(t), !1;
      } else
        return e.appendChild(new Ot(Number(n))), !0;
    else
      return this._backTo(t), !1;
    if (this._accept(
      6
      /* TokenType.Forwardslash */
    )) {
      const s = this._accept(9, !0);
      return !s || !this._accept(
        4
        /* TokenType.CurlyClose */
      ) ? (this._backTo(t), !1) : (e.appendChild(new Ot(Number(n), s)), !0);
    } else if (this._accept(
      11
      /* TokenType.Plus */
    )) {
      const s = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (s)
        return e.appendChild(new Ot(Number(n), void 0, s, void 0)), !0;
    } else if (this._accept(
      12
      /* TokenType.Dash */
    )) {
      const s = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (s)
        return e.appendChild(new Ot(Number(n), void 0, void 0, s)), !0;
    } else if (this._accept(
      13
      /* TokenType.QuestionMark */
    )) {
      const s = this._until(
        1
        /* TokenType.Colon */
      );
      if (s) {
        const o = this._until(
          4
          /* TokenType.CurlyClose */
        );
        if (o)
          return e.appendChild(new Ot(Number(n), void 0, s, o)), !0;
      }
    } else {
      const s = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (s)
        return e.appendChild(new Ot(Number(n), void 0, void 0, s)), !0;
    }
    return this._backTo(t), !1;
  }
  _parseAnything(e) {
    return this._token.type !== 14 ? (e.appendChild(new ze(this._scanner.tokenText(this._token))), this._accept(void 0), !0) : !1;
  }
}
function yv(r, e, t) {
  var i, n, s, o;
  return (typeof t.insertText == "string" ? t.insertText === "" : t.insertText.snippet === "") ? {
    edits: (n = (i = t.additionalEdit) === null || i === void 0 ? void 0 : i.edits) !== null && n !== void 0 ? n : []
  } : {
    edits: [
      ...e.map((a) => new QC(r, { range: a, text: typeof t.insertText == "string" ? Un.escape(t.insertText) + "$0" : t.insertText.snippet, insertAsSnippet: !0 })),
      ...(o = (s = t.additionalEdit) === null || s === void 0 ? void 0 : s.edits) !== null && o !== void 0 ? o : []
    ]
  };
}
function xv(r) {
  var e;
  function t(a, l) {
    return "providerId" in a && a.providerId === l.providerId || "mimeType" in a && a.mimeType === l.handledMimeType;
  }
  const i = /* @__PURE__ */ new Map();
  for (const a of r)
    for (const l of (e = a.yieldTo) !== null && e !== void 0 ? e : [])
      for (const d of r)
        if (d !== a && t(l, d)) {
          let c = i.get(a);
          c || (c = [], i.set(a, c)), c.push(d);
        }
  if (!i.size)
    return Array.from(r);
  const n = /* @__PURE__ */ new Set(), s = [];
  function o(a) {
    if (!a.length)
      return [];
    const l = a[0];
    if (s.includes(l))
      return console.warn(`Yield to cycle detected for ${l.providerId}`), a;
    if (n.has(l))
      return o(a.slice(1));
    let d = [];
    const c = i.get(l);
    return c && (s.push(l), d = o(c), s.pop()), n.add(l), [...d, l, ...o(a.slice(1))];
  }
  return o(Array.from(r));
}
var dx = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, cx = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const hx = Y.register({
  description: "inline-progress-widget",
  stickiness: 1,
  showIfCollapsed: !0,
  after: {
    content: Am,
    inlineClassName: "inline-editor-progress-decoration",
    inlineClassNameAffectsLetterSpacing: !0
  }
});
class xd extends P {
  constructor(e, t, i, n, s) {
    super(), this.typeId = e, this.editor = t, this.range = i, this.delegate = s, this.allowEditorOverflow = !1, this.suppressMouseDown = !0, this.create(n), this.editor.addContentWidget(this), this.editor.layoutContentWidget(this);
  }
  create(e) {
    this.domNode = O(".inline-progress-widget"), this.domNode.role = "button", this.domNode.title = e;
    const t = O("span.icon");
    this.domNode.append(t), t.classList.add(...oe.asClassNameArray(j.loading), "codicon-modifier-spin");
    const i = () => {
      const n = this.editor.getOption(
        67
        /* EditorOption.lineHeight */
      );
      this.domNode.style.height = `${n}px`, this.domNode.style.width = `${Math.ceil(0.8 * n)}px`;
    };
    i(), this._register(this.editor.onDidChangeConfiguration((n) => {
      (n.hasChanged(
        52
        /* EditorOption.fontSize */
      ) || n.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && i();
    })), this._register(le(this.domNode, Le.CLICK, (n) => {
      this.delegate.cancel();
    }));
  }
  getId() {
    return xd.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: { lineNumber: this.range.startLineNumber, column: this.range.startColumn },
      preference: [
        0
        /* ContentWidgetPositionPreference.EXACT */
      ]
    };
  }
  dispose() {
    super.dispose(), this.editor.removeContentWidget(this);
  }
}
xd.baseId = "editor.widget.inlineProgressWidget";
let kl = class extends P {
  constructor(e, t, i) {
    super(), this.id = e, this._editor = t, this._instantiationService = i, this._showDelay = 500, this._showPromise = this._register(new ft()), this._currentWidget = new ft(), this._operationIdPool = 0, this._currentDecorations = t.createDecorationsCollection();
  }
  async showWhile(e, t, i) {
    const n = this._operationIdPool++;
    this._currentOperation = n, this.clear(), this._showPromise.value = hr(() => {
      const s = S.fromPositions(e);
      this._currentDecorations.set([{
        range: s,
        options: hx
      }]).length > 0 && (this._currentWidget.value = this._instantiationService.createInstance(xd, this.id, this._editor, s, t, i));
    }, this._showDelay);
    try {
      return await i;
    } finally {
      this._currentOperation === n && (this.clear(), this._currentOperation = void 0);
    }
  }
  clear() {
    this._showPromise.clear(), this._currentDecorations.clear(), this._currentWidget.clear();
  }
};
kl = dx([
  cx(2, q)
], kl);
var Lv = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, tr = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, dh;
let Nl = dh = class extends P {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    super(), this.typeId = e, this.editor = t, this.showCommand = n, this.range = s, this.edits = o, this.onSelectNewEdit = a, this._contextMenuService = l, this._keybindingService = c, this.allowEditorOverflow = !0, this.suppressMouseDown = !0, this.create(), this.visibleContext = i.bindTo(d), this.visibleContext.set(!0), this._register(pe(() => this.visibleContext.reset())), this.editor.addContentWidget(this), this.editor.layoutContentWidget(this), this._register(pe(() => this.editor.removeContentWidget(this))), this._register(this.editor.onDidChangeCursorPosition((h) => {
      s.containsPosition(h.position) || this.dispose();
    })), this._register(De.runAndSubscribe(c.onDidUpdateKeybindings, () => {
      this._updateButtonTitle();
    }));
  }
  _updateButtonTitle() {
    var e;
    const t = (e = this._keybindingService.lookupKeybinding(this.showCommand.id)) === null || e === void 0 ? void 0 : e.getLabel();
    this.button.element.title = this.showCommand.label + (t ? ` (${t})` : "");
  }
  create() {
    this.domNode = O(".post-edit-widget"), this.button = this._register(new YC(this.domNode, {
      supportIcons: !0
    })), this.button.label = "$(insert)", this._register(le(this.domNode, Le.CLICK, () => this.showSelector()));
  }
  getId() {
    return dh.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: this.range.getEndPosition(),
      preference: [
        2
        /* ContentWidgetPositionPreference.BELOW */
      ]
    };
  }
  showSelector() {
    this._contextMenuService.showContextMenu({
      getAnchor: () => {
        const e = mt(this.button.element);
        return { x: e.left + e.width, y: e.top + e.height };
      },
      getActions: () => this.edits.allEdits.map((e, t) => JC({
        id: "",
        label: e.label,
        checked: t === this.edits.activeEditIndex,
        run: () => {
          if (t !== this.edits.activeEditIndex)
            return this.onSelectNewEdit(t);
        }
      }))
    });
  }
};
Nl.baseId = "editor.widget.postEditWidget";
Nl = dh = Lv([
  tr(7, co),
  tr(8, ee),
  tr(9, xe)
], Nl);
let Rl = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._id = e, this._editor = t, this._visibleContext = i, this._showCommand = n, this._instantiationService = s, this._bulkEditService = o, this._currentWidget = this._register(new ft()), this._register(De.any(t.onDidChangeModel, t.onDidChangeModelContent)(() => this.clear()));
  }
  async applyEditAndShowIfNeeded(e, t, i, n) {
    const s = this._editor.getModel();
    if (!s || !e.length)
      return;
    const o = t.allEdits[t.activeEditIndex];
    if (!o)
      return;
    const a = yv(s.uri, e, o), l = e[0], d = s.deltaDecorations([], [{
      range: l,
      options: {
        description: "paste-line-suffix",
        stickiness: 0
        /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
      }
    }]);
    let c, h;
    try {
      c = await this._bulkEditService.apply(a, { editor: this._editor, token: n }), h = s.getDecorationRange(d[0]);
    } finally {
      s.deltaDecorations(d, []);
    }
    i && c.isApplied && t.allEdits.length > 1 && this.show(h ?? l, t, async (u) => {
      const p = this._editor.getModel();
      p && (await p.undo(), this.applyEditAndShowIfNeeded(e, { activeEditIndex: u, allEdits: t.allEdits }, i, n));
    });
  }
  show(e, t, i) {
    this.clear(), this._editor.hasModel() && (this._currentWidget.value = this._instantiationService.createInstance(Nl, this._id, this._editor, this._visibleContext, this._showCommand, e, t, i));
  }
  clear() {
    this._currentWidget.clear();
  }
  tryShowSelector() {
    var e;
    (e = this._currentWidget.value) === null || e === void 0 || e.showSelector();
  }
};
Rl = Lv([
  tr(4, q),
  tr(5, id)
], Rl);
var ux = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, of = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, dl;
let qe = dl = class {
  static get(e) {
    return e.getContribution(dl.ID);
  }
  constructor(e, t, i) {
    this._openerService = i, this._messageWidget = new ft(), this._messageListeners = new M(), this._mouseOverMessage = !1, this._editor = e, this._visible = dl.MESSAGE_VISIBLE.bindTo(t);
  }
  dispose() {
    var e;
    (e = this._message) === null || e === void 0 || e.dispose(), this._messageListeners.dispose(), this._messageWidget.dispose(), this._visible.reset();
  }
  showMessage(e, t) {
    xt(fc(e) ? e.value : e), this._visible.set(!0), this._messageWidget.clear(), this._messageListeners.clear(), this._message = fc(e) ? eS(e, {
      actionHandler: {
        callback: (n) => {
          this.closeMessage(), tS(this._openerService, n, fc(e) ? e.isTrusted : void 0);
        },
        disposables: this._messageListeners
      }
    }) : void 0, this._messageWidget.value = new rf(this._editor, t, typeof e == "string" ? e : this._message.element), this._messageListeners.add(De.debounce(this._editor.onDidBlurEditorText, (n, s) => s, 0)(() => {
      this._mouseOverMessage || this._messageWidget.value && iS(Em(), this._messageWidget.value.getDomNode()) || this.closeMessage();
    })), this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage())), this._messageListeners.add(le(this._messageWidget.value.getDomNode(), Le.MOUSE_ENTER, () => this._mouseOverMessage = !0, !0)), this._messageListeners.add(le(this._messageWidget.value.getDomNode(), Le.MOUSE_LEAVE, () => this._mouseOverMessage = !1, !0));
    let i;
    this._messageListeners.add(this._editor.onMouseMove((n) => {
      n.target.position && (i ? i.containsPosition(n.target.position) || this.closeMessage() : i = new S(t.lineNumber - 3, 1, n.target.position.lineNumber + 3, 1));
    }));
  }
  closeMessage() {
    this._visible.reset(), this._messageListeners.clear(), this._messageWidget.value && this._messageListeners.add(rf.fadeOut(this._messageWidget.value));
  }
};
qe.ID = "editor.contrib.messageController";
qe.MESSAGE_VISIBLE = new Q("messageVisible", !1, g("messageVisible", "Whether the editor is currently showing an inline message"));
qe = dl = ux([
  of(1, ee),
  of(2, Gt)
], qe);
const gx = bt.bindToContribution(qe.get);
B(new gx({
  id: "leaveEditorMessage",
  precondition: qe.MESSAGE_VISIBLE,
  handler: (r) => r.closeMessage(),
  kbOpts: {
    weight: 130,
    primary: 9
    /* KeyCode.Escape */
  }
}));
let rf = class {
  static fadeOut(e) {
    const t = () => {
      e.dispose(), clearTimeout(i), e.getDomNode().removeEventListener("animationend", t);
    }, i = setTimeout(t, 110);
    return e.getDomNode().addEventListener("animationend", t), e.getDomNode().classList.add("fadeOut"), { dispose: t };
  }
  constructor(e, { lineNumber: t, column: i }, n) {
    this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._editor = e, this._editor.revealLinesInCenterIfOutsideViewport(
      t,
      t,
      0
      /* ScrollType.Smooth */
    ), this._position = { lineNumber: t, column: i }, this._domNode = document.createElement("div"), this._domNode.classList.add("monaco-editor-overlaymessage"), this._domNode.style.marginLeft = "-6px";
    const s = document.createElement("div");
    s.classList.add("anchor", "top"), this._domNode.appendChild(s);
    const o = document.createElement("div");
    typeof n == "string" ? (o.classList.add("message"), o.textContent = n) : (n.classList.add("message"), o.appendChild(n)), this._domNode.appendChild(o);
    const a = document.createElement("div");
    a.classList.add("anchor", "below"), this._domNode.appendChild(a), this._editor.addContentWidget(this), this._domNode.classList.add("fadeIn");
  }
  dispose() {
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "messageoverlay";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._position,
      preference: [
        1,
        2
      ],
      positionAffinity: 1
    };
  }
  afterRender(e) {
    this._domNode.classList.toggle(
      "below",
      e === 2
      /* ContentWidgetPositionPreference.BELOW */
    );
  }
};
Z(
  qe.ID,
  qe,
  4
  /* EditorContributionInstantiation.Lazy */
);
var px = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, hs = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, ch;
const Iv = "editor.changePasteType", Dv = new Q("pasteWidgetVisible", !1, g("pasteWidgetVisible", "Whether the paste widget is showing")), yc = "application/vnd.code.copyMetadata";
let Ri = ch = class extends P {
  static get(e) {
    return e.getContribution(ch.ID);
  }
  constructor(e, t, i, n, s, o, a) {
    super(), this._bulkEditService = i, this._clipboardService = n, this._languageFeaturesService = s, this._quickInputService = o, this._progressService = a, this._editor = e;
    const l = e.getContainerDomNode();
    this._register(le(l, "copy", (d) => this.handleCopy(d))), this._register(le(l, "cut", (d) => this.handleCopy(d))), this._register(le(l, "paste", (d) => this.handlePaste(d), !0)), this._pasteProgressManager = this._register(new kl("pasteIntoEditor", e, t)), this._postPasteWidgetManager = this._register(t.createInstance(Rl, "pasteIntoEditor", e, Dv, { id: Iv, label: g("postPasteWidgetTitle", "Show paste options...") }));
  }
  changePasteType() {
    this._postPasteWidgetManager.tryShowSelector();
  }
  pasteAs(e) {
    this._editor.focus();
    try {
      this._pasteAsActionContext = { preferredId: e }, Zu().execCommand("paste");
    } finally {
      this._pasteAsActionContext = void 0;
    }
  }
  isPasteAsEnabled() {
    return this._editor.getOption(
      85
      /* EditorOption.pasteAs */
    ).enabled && !this._editor.getOption(
      91
      /* EditorOption.readOnly */
    );
  }
  async finishedPaste() {
    await this._currentPasteOperation;
  }
  handleCopy(e) {
    var t, i;
    if (!this._editor.hasTextFocus() || (Om && this._clipboardService.writeResources([]), !e.clipboardData || !this.isPasteAsEnabled()))
      return;
    const n = this._editor.getModel(), s = this._editor.getSelections();
    if (!n || !(s != null && s.length))
      return;
    const o = this._editor.getOption(
      37
      /* EditorOption.emptySelectionClipboard */
    );
    let a = s;
    const l = s.length === 1 && s[0].isEmpty();
    if (l) {
      if (!o)
        return;
      a = [new S(a[0].startLineNumber, 1, a[0].startLineNumber, 1 + n.getLineLength(a[0].startLineNumber))];
    }
    const d = (t = this._editor._getViewModel()) === null || t === void 0 ? void 0 : t.getPlainTextToCopy(s, o, nd), h = {
      multicursorText: Array.isArray(d) ? d : null,
      pasteOnNewLine: l,
      mode: null
    }, u = this._languageFeaturesService.documentPasteEditProvider.ordered(n).filter((v) => !!v.prepareDocumentPaste);
    if (!u.length) {
      this.setCopyMetadata(e.clipboardData, { defaultPastePayload: h });
      return;
    }
    const p = Cv(e.clipboardData), f = u.flatMap((v) => {
      var C;
      return (C = v.copyMimeTypes) !== null && C !== void 0 ? C : [];
    }), m = wd();
    this.setCopyMetadata(e.clipboardData, {
      id: m,
      providerCopyMimeTypes: f,
      defaultPastePayload: h
    });
    const _ = Pe(async (v) => {
      const C = Ii(await Promise.all(u.map(async (w) => {
        try {
          return await w.prepareDocumentPaste(n, a, p, v);
        } catch (y) {
          console.error(y);
          return;
        }
      })));
      C.reverse();
      for (const w of C)
        for (const [y, I] of w)
          p.replace(y, I);
      return p;
    });
    (i = this._currentCopyOperation) === null || i === void 0 || i.dataTransferPromise.cancel(), this._currentCopyOperation = { handle: m, dataTransferPromise: _ };
  }
  async handlePaste(e) {
    var t, i, n, s, o;
    if (!e.clipboardData || !this._editor.hasTextFocus())
      return;
    (t = qe.get(this._editor)) === null || t === void 0 || t.closeMessage(), (i = this._currentPasteOperation) === null || i === void 0 || i.cancel(), this._currentPasteOperation = void 0;
    const a = this._editor.getModel(), l = this._editor.getSelections();
    if (!(l != null && l.length) || !a || !this.isPasteAsEnabled() && !this._pasteAsActionContext)
      return;
    const d = this.fetchCopyMetadata(e), c = Sv(e.clipboardData);
    c.delete(yc);
    const h = [
      ...e.clipboardData.types,
      ...(n = d == null ? void 0 : d.providerCopyMimeTypes) !== null && n !== void 0 ? n : [],
      // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.
      // However we can only check the system clipboard async. For this early check, just add it in.
      // We filter providers again once we have the final dataTransfer we will use.
      Te.uriList
    ], u = this._languageFeaturesService.documentPasteEditProvider.ordered(a).filter((p) => {
      var f, m;
      return !((f = this._pasteAsActionContext) === null || f === void 0) && f.preferredId && this._pasteAsActionContext.preferredId !== p.id ? !1 : (m = p.pasteMimeTypes) === null || m === void 0 ? void 0 : m.some((_) => vv(_, h));
    });
    if (!u.length) {
      !((s = this._pasteAsActionContext) === null || s === void 0) && s.preferredId && this.showPasteAsNoEditMessage(l, (o = this._pasteAsActionContext) === null || o === void 0 ? void 0 : o.preferredId);
      return;
    }
    e.preventDefault(), e.stopImmediatePropagation(), this._pasteAsActionContext ? this.showPasteAsPick(this._pasteAsActionContext.preferredId, u, l, c, d, { trigger: "explicit", only: this._pasteAsActionContext.preferredId }) : this.doPasteInline(u, l, c, d, { trigger: "implicit" });
  }
  showPasteAsNoEditMessage(e, t) {
    var i;
    (i = qe.get(this._editor)) === null || i === void 0 || i.showMessage(g("pasteAsError", "No paste edits for '{0}' found", t), e[0].getStartPosition());
  }
  doPasteInline(e, t, i, n, s) {
    const o = Pe(async (a) => {
      const l = this._editor;
      if (!l.hasModel())
        return;
      const d = l.getModel(), c = new Vs(l, 3, void 0, a);
      try {
        if (await this.mergeInDataFromCopy(i, n, c.token), c.token.isCancellationRequested)
          return;
        const h = e.filter((p) => af(p, i));
        if (!h.length || h.length === 1 && h[0].id === "text") {
          await this.applyDefaultPasteHandler(i, n, c.token);
          return;
        }
        const u = await this.getPasteEdits(h, i, d, t, s, c.token);
        if (c.token.isCancellationRequested)
          return;
        if (u.length === 1 && u[0].providerId === "text") {
          await this.applyDefaultPasteHandler(i, n, c.token);
          return;
        }
        if (u.length) {
          const p = l.getOption(
            85
            /* EditorOption.pasteAs */
          ).showPasteSelector === "afterPaste";
          return this._postPasteWidgetManager.applyEditAndShowIfNeeded(t, { activeEditIndex: 0, allEdits: u }, p, c.token);
        }
        await this.applyDefaultPasteHandler(i, n, c.token);
      } finally {
        c.dispose(), this._currentPasteOperation === o && (this._currentPasteOperation = void 0);
      }
    });
    this._pasteProgressManager.showWhile(t[0].getEndPosition(), g("pasteIntoEditorProgress", "Running paste handlers. Click to cancel"), o), this._currentPasteOperation = o;
  }
  showPasteAsPick(e, t, i, n, s, o) {
    const a = Pe(async (l) => {
      const d = this._editor;
      if (!d.hasModel())
        return;
      const c = d.getModel(), h = new Vs(d, 3, void 0, l);
      try {
        if (await this.mergeInDataFromCopy(n, s, h.token), h.token.isCancellationRequested)
          return;
        let u = t.filter((_) => af(_, n));
        e && (u = u.filter((_) => _.id === e));
        const p = await this.getPasteEdits(u, n, c, i, o, h.token);
        if (h.token.isCancellationRequested)
          return;
        if (!p.length) {
          o.only && this.showPasteAsNoEditMessage(i, o.only);
          return;
        }
        let f;
        if (e)
          f = p.at(0);
        else {
          const _ = await this._quickInputService.pick(p.map((v) => ({
            label: v.label,
            description: v.providerId,
            detail: v.detail,
            edit: v
          })), {
            placeHolder: g("pasteAsPickerPlaceholder", "Select Paste Action")
          });
          f = _ == null ? void 0 : _.edit;
        }
        if (!f)
          return;
        const m = yv(c.uri, i, f);
        await this._bulkEditService.apply(m, { editor: this._editor });
      } finally {
        h.dispose(), this._currentPasteOperation === a && (this._currentPasteOperation = void 0);
      }
    });
    this._progressService.withProgress({
      location: 10,
      title: g("pasteAsProgress", "Running paste handlers")
    }, () => a);
  }
  setCopyMetadata(e, t) {
    e.setData(yc, JSON.stringify(t));
  }
  fetchCopyMetadata(e) {
    var t;
    if (!e.clipboardData)
      return;
    const i = e.clipboardData.getData(yc);
    if (i)
      try {
        return JSON.parse(i);
      } catch {
        return;
      }
    const [n, s] = sS.getTextData(e.clipboardData);
    if (s)
      return {
        defaultPastePayload: {
          mode: s.mode,
          multicursorText: (t = s.multicursorText) !== null && t !== void 0 ? t : null,
          pasteOnNewLine: !!s.isFromEmptySelection
        }
      };
  }
  async mergeInDataFromCopy(e, t, i) {
    var n;
    if (t != null && t.id && ((n = this._currentCopyOperation) === null || n === void 0 ? void 0 : n.handle) === t.id) {
      const s = await this._currentCopyOperation.dataTransferPromise;
      if (i.isCancellationRequested)
        return;
      for (const [o, a] of s)
        e.replace(o, a);
    }
    if (!e.has(Te.uriList)) {
      const s = await this._clipboardService.readResources();
      if (i.isCancellationRequested)
        return;
      s.length && e.append(Te.uriList, kg(yd.create(s)));
    }
  }
  async getPasteEdits(e, t, i, n, s, o) {
    const a = await Zr(Promise.all(e.map(async (d) => {
      var c;
      try {
        const h = await ((c = d.provideDocumentPasteEdits) === null || c === void 0 ? void 0 : c.call(d, i, n, t, s, o));
        if (h)
          return { ...h, providerId: d.id };
      } catch (h) {
        console.error(h);
      }
    })), o), l = Ii(a ?? []);
    return xv(l);
  }
  async applyDefaultPasteHandler(e, t, i) {
    var n, s, o;
    const a = (n = e.get(Te.text)) !== null && n !== void 0 ? n : e.get("text");
    if (!a)
      return;
    const l = await a.asString();
    if (i.isCancellationRequested)
      return;
    const d = {
      text: l,
      pasteOnNewLine: (s = t == null ? void 0 : t.defaultPastePayload.pasteOnNewLine) !== null && s !== void 0 ? s : !1,
      multicursorText: (o = t == null ? void 0 : t.defaultPastePayload.multicursorText) !== null && o !== void 0 ? o : null,
      mode: null
    };
    this._editor.trigger("keyboard", "paste", d);
  }
};
Ri.ID = "editor.contrib.copyPasteActionController";
Ri = ch = px([
  hs(1, q),
  hs(2, id),
  hs(3, ho),
  hs(4, V),
  hs(5, Ei),
  hs(6, nS)
], Ri);
function af(r, e) {
  var t;
  return !!(!((t = r.pasteMimeTypes) === null || t === void 0) && t.some((i) => e.matches(i)));
}
const zn = "9_cutcopypaste", fx = uo || document.queryCommandSupported("cut"), kv = uo || document.queryCommandSupported("copy"), mx = typeof navigator.clipboard > "u" || oS ? document.queryCommandSupported("paste") : !0;
function Rg(r) {
  return r.register(), r;
}
const _x = fx ? Rg(new Xu({
  id: "editor.action.clipboardCutAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind cut keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    uo ? {
      primary: 2102,
      win: { primary: 2102, secondary: [
        1044
        /* KeyCode.Delete */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: E.MenubarEditMenu,
    group: "2_ccp",
    title: g({ key: "miCut", comment: ["&& denotes a mnemonic"] }, "Cu&&t"),
    order: 1
  }, {
    menuId: E.EditorContext,
    group: zn,
    title: g("actions.clipboard.cutLabel", "Cut"),
    when: b.writable,
    order: 1
  }, {
    menuId: E.CommandPalette,
    group: "",
    title: g("actions.clipboard.cutLabel", "Cut"),
    order: 1
  }, {
    menuId: E.SimpleEditorContext,
    group: zn,
    title: g("actions.clipboard.cutLabel", "Cut"),
    when: b.writable,
    order: 1
  }]
})) : void 0, vx = kv ? Rg(new Xu({
  id: "editor.action.clipboardCopyAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind copy keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    uo ? {
      primary: 2081,
      win: { primary: 2081, secondary: [
        2067
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: E.MenubarEditMenu,
    group: "2_ccp",
    title: g({ key: "miCopy", comment: ["&& denotes a mnemonic"] }, "&&Copy"),
    order: 2
  }, {
    menuId: E.EditorContext,
    group: zn,
    title: g("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }, {
    menuId: E.CommandPalette,
    group: "",
    title: g("actions.clipboard.copyLabel", "Copy"),
    order: 1
  }, {
    menuId: E.SimpleEditorContext,
    group: zn,
    title: g("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }]
})) : void 0;
qt.appendMenuItem(E.MenubarEditMenu, { submenu: E.MenubarCopy, title: $("copy as", "Copy As"), group: "2_ccp", order: 3 });
qt.appendMenuItem(E.EditorContext, { submenu: E.EditorContextCopy, title: $("copy as", "Copy As"), group: zn, order: 3 });
qt.appendMenuItem(E.EditorContext, { submenu: E.EditorContextShare, title: $("share", "Share"), group: "11_share", order: -1, when: L.and(L.notEquals("resourceScheme", "output"), b.editorTextFocus) });
qt.appendMenuItem(E.EditorTitleContext, { submenu: E.EditorTitleContextShare, title: $("share", "Share"), group: "11_share", order: -1 });
qt.appendMenuItem(E.ExplorerContext, { submenu: E.ExplorerContextShare, title: $("share", "Share"), group: "11_share", order: -1 });
const xc = mx ? Rg(new Xu({
  id: "editor.action.clipboardPasteAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind paste keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    uo ? {
      primary: 2100,
      win: { primary: 2100, secondary: [
        1043
        /* KeyCode.Insert */
      ] },
      linux: { primary: 2100, secondary: [
        1043
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: E.MenubarEditMenu,
    group: "2_ccp",
    title: g({ key: "miPaste", comment: ["&& denotes a mnemonic"] }, "&&Paste"),
    order: 4
  }, {
    menuId: E.EditorContext,
    group: zn,
    title: g("actions.clipboard.pasteLabel", "Paste"),
    when: b.writable,
    order: 4
  }, {
    menuId: E.CommandPalette,
    group: "",
    title: g("actions.clipboard.pasteLabel", "Paste"),
    order: 1
  }, {
    menuId: E.SimpleEditorContext,
    group: zn,
    title: g("actions.clipboard.pasteLabel", "Paste"),
    when: b.writable,
    order: 4
  }]
})) : void 0;
class bx extends D {
  constructor() {
    super({
      id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
      label: g("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
      alias: "Copy With Syntax Highlighting",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    !t.hasModel() || !t.getOption(
      37
      /* EditorOption.emptySelectionClipboard */
    ) && t.getSelection().isEmpty() || (Cp.forceCopyWithSyntaxHighlighting = !0, t.focus(), t.getContainerDomNode().ownerDocument.execCommand("copy"), Cp.forceCopyWithSyntaxHighlighting = !1);
  }
}
function Nv(r, e) {
  r && (r.addImplementation(1e4, "code-editor", (t, i) => {
    const n = t.get(_e).getFocusedCodeEditor();
    if (n && n.hasTextFocus()) {
      const s = n.getOption(
        37
        /* EditorOption.emptySelectionClipboard */
      ), o = n.getSelection();
      return o && o.isEmpty() && !s || n.getContainerDomNode().ownerDocument.execCommand(e), !0;
    }
    return !1;
  }), r.addImplementation(0, "generic-dom", (t, i) => (Zu().execCommand(e), !0)));
}
Nv(_x, "cut");
Nv(vx, "copy");
xc && (xc.addImplementation(1e4, "code-editor", (r, e) => {
  var t, i;
  const n = r.get(_e), s = r.get(ho), o = n.getFocusedCodeEditor();
  return o && o.hasTextFocus() ? o.getContainerDomNode().ownerDocument.execCommand("paste") ? (i = (t = Ri.get(o)) === null || t === void 0 ? void 0 : t.finishedPaste()) !== null && i !== void 0 ? i : Promise.resolve() : Om ? (async () => {
    const l = await s.readText();
    if (l !== "") {
      const d = rS.INSTANCE.get(l);
      let c = !1, h = null, u = null;
      d && (c = o.getOption(
        37
        /* EditorOption.emptySelectionClipboard */
      ) && !!d.isFromEmptySelection, h = typeof d.multicursorText < "u" ? d.multicursorText : null, u = d.mode), o.trigger("keyboard", "paste", {
        text: l,
        pasteOnNewLine: c,
        multicursorText: h,
        mode: u
      });
    }
  })() : !0 : !1;
}), xc.addImplementation(0, "generic-dom", (r, e) => (Zu().execCommand("paste"), !0)));
kv && x(bx);
class H {
  constructor(e) {
    this.value = e;
  }
  equals(e) {
    return this.value === e.value;
  }
  contains(e) {
    return this.equals(e) || this.value === "" || e.value.startsWith(this.value + H.sep);
  }
  intersects(e) {
    return this.contains(e) || e.contains(this);
  }
  append(e) {
    return new H(this.value + H.sep + e);
  }
}
H.sep = ".";
H.None = new H("@@none@@");
H.Empty = new H("");
H.QuickFix = new H("quickfix");
H.Refactor = new H("refactor");
H.RefactorExtract = H.Refactor.append("extract");
H.RefactorInline = H.Refactor.append("inline");
H.RefactorMove = H.Refactor.append("move");
H.RefactorRewrite = H.Refactor.append("rewrite");
H.Notebook = new H("notebook");
H.Source = new H("source");
H.SourceOrganizeImports = H.Source.append("organizeImports");
H.SourceFixAll = H.Source.append("fixAll");
H.SurroundWith = H.Refactor.append("surround");
var ot;
(function(r) {
  r.Refactor = "refactor", r.RefactorPreview = "refactor preview", r.Lightbulb = "lightbulb", r.Default = "other (default)", r.SourceAction = "source action", r.QuickFix = "quick fix action", r.FixAll = "fix all", r.OrganizeImports = "organize imports", r.AutoFix = "auto fix", r.QuickFixHover = "quick fix hover window", r.OnSave = "save participants", r.ProblemsView = "problems view";
})(ot || (ot = {}));
function Cx(r, e) {
  return !(r.include && !r.include.intersects(e) || r.excludes && r.excludes.some((t) => Rv(e, t, r.include)) || !r.includeSourceActions && H.Source.contains(e));
}
function Sx(r, e) {
  const t = e.kind ? new H(e.kind) : void 0;
  return !(r.include && (!t || !r.include.contains(t)) || r.excludes && t && r.excludes.some((i) => Rv(t, i, r.include)) || !r.includeSourceActions && t && H.Source.contains(t) || r.onlyIncludePreferredActions && !e.isPreferred);
}
function Rv(r, e, t) {
  return !(!e.contains(r) || t && e.contains(t));
}
class ti {
  static fromUser(e, t) {
    return !e || typeof e != "object" ? new ti(t.kind, t.apply, !1) : new ti(ti.getKindFromUser(e, t.kind), ti.getApplyFromUser(e, t.apply), ti.getPreferredUser(e));
  }
  static getApplyFromUser(e, t) {
    switch (typeof e.apply == "string" ? e.apply.toLowerCase() : "") {
      case "first":
        return "first";
      case "never":
        return "never";
      case "ifsingle":
        return "ifSingle";
      default:
        return t;
    }
  }
  static getKindFromUser(e, t) {
    return typeof e.kind == "string" ? new H(e.kind) : t;
  }
  static getPreferredUser(e) {
    return typeof e.preferred == "boolean" ? e.preferred : !1;
  }
  constructor(e, t, i) {
    this.kind = e, this.apply = t, this.preferred = i;
  }
}
class wx {
  constructor(e, t, i) {
    this.action = e, this.provider = t, this.highlightRange = i;
  }
  async resolve(e) {
    var t;
    if (!((t = this.provider) === null || t === void 0) && t.resolveCodeAction && !this.action.edit) {
      let i;
      try {
        i = await this.provider.resolveCodeAction(this.action, e);
      } catch (n) {
        Ie(n);
      }
      i && (this.action.edit = i.edit);
    }
    return this;
  }
}
const Pv = "editor.action.codeAction", Pg = "editor.action.quickFix", Mv = "editor.action.autoFix", Ev = "editor.action.refactor", Tv = "editor.action.sourceAction", Mg = "editor.action.organizeImports", Eg = "editor.action.fixAll";
class ir extends P {
  static codeActionsPreferredComparator(e, t) {
    return e.isPreferred && !t.isPreferred ? -1 : !e.isPreferred && t.isPreferred ? 1 : 0;
  }
  static codeActionsComparator({ action: e }, { action: t }) {
    return e.isAI && !t.isAI ? 1 : !e.isAI && t.isAI ? -1 : nt(e.diagnostics) ? nt(t.diagnostics) ? ir.codeActionsPreferredComparator(e, t) : -1 : nt(t.diagnostics) ? 1 : ir.codeActionsPreferredComparator(e, t);
  }
  constructor(e, t, i) {
    super(), this.documentation = t, this._register(i), this.allActions = [...e].sort(ir.codeActionsComparator), this.validActions = this.allActions.filter(({ action: n }) => !n.disabled);
  }
  get hasAutoFix() {
    return this.validActions.some(({ action: e }) => !!e.kind && H.QuickFix.contains(new H(e.kind)) && !!e.isPreferred);
  }
  get hasAIFix() {
    return this.validActions.some(({ action: e }) => !!e.isAI);
  }
  get allAIFixes() {
    return this.validActions.every(({ action: e }) => !!e.isAI);
  }
}
const lf = { actions: [], documentation: void 0 };
async function nr(r, e, t, i, n, s) {
  var o;
  const a = i.filter || {}, l = {
    ...a,
    excludes: [...a.excludes || [], H.Notebook]
  }, d = {
    only: (o = a.include) === null || o === void 0 ? void 0 : o.value,
    trigger: i.type
  }, c = new aS(e, s), h = i.type === 2, u = yx(r, e, h ? l : a), p = new M(), f = u.map(async (_) => {
    try {
      n.report(_);
      const v = await _.provideCodeActions(e, t, d, c.token);
      if (v && p.add(v), c.token.isCancellationRequested)
        return lf;
      const C = ((v == null ? void 0 : v.actions) || []).filter((y) => y && Sx(a, y)), w = Lx(_, C, a.include);
      return {
        actions: C.map((y) => new wx(y, _)),
        documentation: w
      };
    } catch (v) {
      if (go(v))
        throw v;
      return Ie(v), lf;
    }
  }), m = r.onDidChange(() => {
    const _ = r.all(e);
    jt(_, u) || c.cancel();
  });
  try {
    const _ = await Promise.all(f), v = _.map((w) => w.actions).flat(), C = [
      ...Ii(_.map((w) => w.documentation)),
      ...xx(r, e, i, v)
    ];
    return new ir(v, C, p);
  } finally {
    m.dispose(), c.dispose();
  }
}
function yx(r, e, t) {
  return r.all(e).filter((i) => i.providedCodeActionKinds ? i.providedCodeActionKinds.some((n) => Cx(t, new H(n))) : !0);
}
function* xx(r, e, t, i) {
  var n, s, o;
  if (e && i.length)
    for (const a of r.all(e))
      a._getAdditionalMenuItems && (yield* (n = a._getAdditionalMenuItems) === null || n === void 0 ? void 0 : n.call(a, { trigger: t.type, only: (o = (s = t.filter) === null || s === void 0 ? void 0 : s.include) === null || o === void 0 ? void 0 : o.value }, i.map((l) => l.action)));
}
function Lx(r, e, t) {
  if (!r.documentation)
    return;
  const i = r.documentation.map((n) => ({ kind: new H(n.kind), command: n.command }));
  if (t) {
    let n;
    for (const s of i)
      s.kind.contains(t) && (n ? n.kind.contains(s.kind) && (n = s) : n = s);
    if (n)
      return n == null ? void 0 : n.command;
  }
  for (const n of e)
    if (n.kind) {
      for (const s of i)
        if (s.kind.contains(new H(n.kind)))
          return s.command;
    }
}
var Os;
(function(r) {
  r.OnSave = "onSave", r.FromProblemsView = "fromProblemsView", r.FromCodeActions = "fromCodeActions", r.FromAILightbulb = "fromAILightbulb";
})(Os || (Os = {}));
async function Ix(r, e, t, i, n = X.None) {
  var s;
  const o = r.get(id), a = r.get(Fe), l = r.get(ui), d = r.get(Je);
  if (l.publicLog2("codeAction.applyCodeAction", {
    codeActionTitle: e.action.title,
    codeActionKind: e.action.kind,
    codeActionIsPreferred: !!e.action.isPreferred,
    reason: t
  }), await e.resolve(n), !n.isCancellationRequested && !(!((s = e.action.edit) === null || s === void 0) && s.edits.length && !(await o.apply(e.action.edit, {
    editor: i == null ? void 0 : i.editor,
    label: e.action.title,
    quotableLabel: e.action.title,
    code: "undoredo.codeAction",
    respectAutoSaveConfig: t !== Os.OnSave,
    showPreview: i == null ? void 0 : i.preview
  })).isApplied) && e.action.command)
    try {
      await a.executeCommand(e.action.command.id, ...e.action.command.arguments || []);
    } catch (c) {
      const h = Dx(c);
      d.error(typeof h == "string" ? h : g("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
    }
}
function Dx(r) {
  return typeof r == "string" ? r : r instanceof Error && typeof r.message == "string" ? r.message : void 0;
}
de.registerCommand("_executeCodeActionProvider", async function(r, e, t, i, n) {
  if (!(e instanceof ce))
    throw wi();
  const { codeActionProvider: s } = r.get(V), o = r.get(Ge).getModel(e);
  if (!o)
    throw wi();
  const a = z.isISelection(t) ? z.liftSelection(t) : S.isIRange(t) ? o.validateRange(t) : void 0;
  if (!a)
    throw wi();
  const l = typeof i == "string" ? new H(i) : void 0, d = await nr(s, o, a, { type: 1, triggerAction: ot.Default, filter: { includeSourceActions: !0, include: l } }, Xi.None, X.None), c = [], h = Math.min(d.validActions.length, typeof n == "number" ? n : 0);
  for (let u = 0; u < h; u++)
    c.push(d.validActions[u].resolve(X.None));
  try {
    return await Promise.all(c), d.validActions.map((u) => u.action);
  } finally {
    setTimeout(() => d.dispose(), 100);
  }
});
var kx = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Nx = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, hh;
let Pl = hh = class {
  constructor(e) {
    this.keybindingService = e;
  }
  getResolver() {
    const e = new Qu(() => this.keybindingService.getKeybindings().filter((t) => hh.codeActionCommands.indexOf(t.command) >= 0).filter((t) => t.resolvedKeybinding).map((t) => {
      let i = t.commandArgs;
      return t.command === Mg ? i = { kind: H.SourceOrganizeImports.value } : t.command === Eg && (i = { kind: H.SourceFixAll.value }), {
        resolvedKeybinding: t.resolvedKeybinding,
        ...ti.fromUser(i, {
          kind: H.None,
          apply: "never"
          /* CodeActionAutoApply.Never */
        })
      };
    }));
    return (t) => {
      if (t.kind) {
        const i = this.bestKeybindingForCodeAction(t, e.value);
        return i == null ? void 0 : i.resolvedKeybinding;
      }
    };
  }
  bestKeybindingForCodeAction(e, t) {
    if (!e.kind)
      return;
    const i = new H(e.kind);
    return t.filter((n) => n.kind.contains(i)).filter((n) => n.preferred ? e.isPreferred : !0).reduceRight((n, s) => n ? n.kind.contains(s.kind) ? s : n : s, void 0);
  }
};
Pl.codeActionCommands = [
  Ev,
  Pv,
  Tv,
  Mg,
  Eg
];
Pl = hh = kx([
  Nx(0, xe)
], Pl);
W("symbolIcon.arrayForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.booleanForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.classForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, g("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.colorForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.constantForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.constructorForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, g("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.enumeratorForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, g("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.enumeratorMemberForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, g("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.eventForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, g("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.fieldForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, g("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.fileForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.folderForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.functionForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, g("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.interfaceForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, g("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.keyForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.keywordForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.methodForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, g("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.moduleForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.namespaceForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.nullForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.numberForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.objectForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.operatorForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.packageForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.propertyForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.referenceForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.snippetForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.stringForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.structForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.textForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.typeParameterForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.unitForeground", {
  dark: R,
  light: R,
  hcDark: R,
  hcLight: R
}, g("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
W("symbolIcon.variableForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, g("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const Av = Object.freeze({ kind: H.Empty, title: g("codeAction.widget.id.more", "More Actions...") }), Rx = Object.freeze([
  { kind: H.QuickFix, title: g("codeAction.widget.id.quickfix", "Quick Fix") },
  { kind: H.RefactorExtract, title: g("codeAction.widget.id.extract", "Extract"), icon: j.wrench },
  { kind: H.RefactorInline, title: g("codeAction.widget.id.inline", "Inline"), icon: j.wrench },
  { kind: H.RefactorRewrite, title: g("codeAction.widget.id.convert", "Rewrite"), icon: j.wrench },
  { kind: H.RefactorMove, title: g("codeAction.widget.id.move", "Move"), icon: j.wrench },
  { kind: H.SurroundWith, title: g("codeAction.widget.id.surround", "Surround With"), icon: j.surroundWith },
  { kind: H.Source, title: g("codeAction.widget.id.source", "Source Action"), icon: j.symbolFile },
  Av
]);
function Px(r, e, t) {
  if (!e)
    return r.map((s) => {
      var o;
      return {
        kind: "action",
        item: s,
        group: Av,
        disabled: !!s.action.disabled,
        label: s.action.disabled || s.action.title,
        canPreview: !!(!((o = s.action.edit) === null || o === void 0) && o.edits.length)
      };
    });
  const i = Rx.map((s) => ({ group: s, actions: [] }));
  for (const s of r) {
    const o = s.action.kind ? new H(s.action.kind) : H.None;
    for (const a of i)
      if (a.group.kind.contains(o)) {
        a.actions.push(s);
        break;
      }
  }
  const n = [];
  for (const s of i)
    if (s.actions.length) {
      n.push({ kind: "header", group: s.group });
      for (const o of s.actions) {
        const a = s.group;
        n.push({
          kind: "action",
          item: o,
          group: o.action.isAI ? { title: a.title, kind: a.kind, icon: j.sparkle } : a,
          label: o.action.title,
          disabled: !!o.action.disabled,
          keybinding: t(o.action)
        });
      }
    }
  return n;
}
var Mx = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, df = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, uh, Ps;
(function(r) {
  r.Hidden = {
    type: 0
    /* Type.Hidden */
  };
  class e {
    constructor(i, n, s, o) {
      this.actions = i, this.trigger = n, this.editorPosition = s, this.widgetPosition = o, this.type = 1;
    }
  }
  r.Showing = e;
})(Ps || (Ps = {}));
let $n = uh = class extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._keybindingService = t, this._onClick = this._register(new G()), this.onClick = this._onClick.event, this._state = Ps.Hidden, this._iconClasses = [], this._domNode = O("div.lightBulbWidget"), this._register(Fm.ignoreTarget(this._domNode)), this._editor.addContentWidget(this), this._register(this._editor.onDidChangeModelContent((n) => {
      const s = this._editor.getModel();
      (this.state.type !== 1 || !s || this.state.editorPosition.lineNumber >= s.getLineCount()) && this.hide();
    })), this._register(lS(this._domNode, (n) => {
      if (this.state.type !== 1)
        return;
      this._editor.focus(), n.preventDefault();
      const { top: s, height: o } = mt(this._domNode), a = this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      );
      let l = Math.floor(a / 3);
      this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber && (l += a), this._onClick.fire({
        x: n.posx,
        y: s + o + l,
        actions: this.state.actions,
        trigger: this.state.trigger
      });
    })), this._register(le(this._domNode, "mouseenter", (n) => {
      (n.buttons & 1) === 1 && this.hide();
    })), this._register(De.runAndSubscribe(this._keybindingService.onDidUpdateKeybindings, () => {
      var n, s, o, a;
      this._preferredKbLabel = (s = (n = this._keybindingService.lookupKeybinding(Mv)) === null || n === void 0 ? void 0 : n.getLabel()) !== null && s !== void 0 ? s : void 0, this._quickFixKbLabel = (a = (o = this._keybindingService.lookupKeybinding(Pg)) === null || o === void 0 ? void 0 : o.getLabel()) !== null && a !== void 0 ? a : void 0, this._updateLightBulbTitleAndIcon();
    }));
  }
  dispose() {
    super.dispose(), this._editor.removeContentWidget(this);
  }
  getId() {
    return "LightBulbWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._state.type === 1 ? this._state.widgetPosition : null;
  }
  update(e, t, i) {
    if (e.validActions.length <= 0)
      return this.hide();
    if (!this._editor.getOptions().get(
      65
      /* EditorOption.lightbulb */
    ).enabled)
      return this.hide();
    const s = this._editor.getModel();
    if (!s)
      return this.hide();
    const { lineNumber: o, column: a } = s.validatePosition(i), l = s.getOptions().tabSize, d = this._editor.getOptions().get(
      50
      /* EditorOption.fontInfo */
    ), c = s.getLineContent(o), h = Yu(c, l), u = d.spaceWidth * h > 22, p = (_) => _ > 2 && this._editor.getTopForLineNumber(_) === this._editor.getTopForLineNumber(_ - 1);
    let f = o, m = 1;
    if (!u) {
      if (o > 1 && !p(o - 1))
        f -= 1;
      else if (o < s.getLineCount() && !p(o + 1))
        f += 1;
      else if (a * d.spaceWidth < 22)
        return this.hide();
      m = /^\S\s*$/.test(s.getLineContent(f)) ? 2 : 1;
    }
    this.state = new Ps.Showing(e, t, i, {
      position: { lineNumber: f, column: m },
      preference: uh._posPref
    }), this._editor.layoutContentWidget(this);
  }
  hide() {
    this.state !== Ps.Hidden && (this.state = Ps.Hidden, this._editor.layoutContentWidget(this));
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state = e, this._updateLightBulbTitleAndIcon();
  }
  _updateLightBulbTitleAndIcon() {
    if (this._domNode.classList.remove(...this._iconClasses), this._iconClasses = [], this.state.type !== 1)
      return;
    let e, t = !1;
    this.state.actions.allAIFixes ? (e = j.sparkleFilled, this.state.actions.validActions.length === 1 && (t = !0)) : this.state.actions.hasAutoFix ? this.state.actions.hasAIFix ? e = j.lightbulbSparkleAutofix : e = j.lightbulbAutofix : this.state.actions.hasAIFix ? e = j.lightbulbSparkle : e = j.lightBulb, this._updateLightbulbTitle(this.state.actions.hasAutoFix, t), this._iconClasses = oe.asClassNameArray(e), this._domNode.classList.add(...this._iconClasses);
  }
  _updateLightbulbTitle(e, t) {
    this.state.type === 1 && (t ? this.title = g("codeActionAutoRun", "Run: {0}", this.state.actions.validActions[0].action.title) : e && this._preferredKbLabel ? this.title = g("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", this._preferredKbLabel) : !e && this._quickFixKbLabel ? this.title = g("codeActionWithKb", "Show Code Actions ({0})", this._quickFixKbLabel) : e || (this.title = g("codeAction", "Show Code Actions")));
  }
  set title(e) {
    this._domNode.title = e;
  }
};
$n.ID = "editor.contrib.lightbulbWidget";
$n._posPref = [
  0
  /* ContentWidgetPositionPreference.EXACT */
];
$n = uh = Mx([
  df(1, xe),
  df(2, Fe)
], $n);
var Ov = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, gh = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Fv = "acceptSelectedCodeAction", Wv = "previewSelectedCodeAction";
class Ex {
  get templateId() {
    return "header";
  }
  renderTemplate(e) {
    e.classList.add("group-header");
    const t = document.createElement("span");
    return e.append(t), { container: e, text: t };
  }
  renderElement(e, t, i) {
    var n, s;
    i.text.textContent = (s = (n = e.group) === null || n === void 0 ? void 0 : n.title) !== null && s !== void 0 ? s : "";
  }
  disposeTemplate(e) {
  }
}
let ph = class {
  get templateId() {
    return "action";
  }
  constructor(e, t) {
    this._supportsPreview = e, this._keybindingService = t;
  }
  renderTemplate(e) {
    e.classList.add(this.templateId);
    const t = document.createElement("div");
    t.className = "icon", e.append(t);
    const i = document.createElement("span");
    i.className = "title", e.append(i);
    const n = new Ju(e, eg);
    return { container: e, icon: t, text: i, keybinding: n };
  }
  renderElement(e, t, i) {
    var n, s, o;
    if (!((n = e.group) === null || n === void 0) && n.icon ? (i.icon.className = oe.asClassName(e.group.icon), e.group.icon.color && (i.icon.style.color = Mn(e.group.icon.color.id))) : (i.icon.className = oe.asClassName(j.lightBulb), i.icon.style.color = "var(--vscode-editorLightBulb-foreground)"), !e.item || !e.label)
      return;
    i.text.textContent = Hv(e.label), i.keybinding.set(e.keybinding), dS(!!e.keybinding, i.keybinding.element);
    const a = (s = this._keybindingService.lookupKeybinding(Fv)) === null || s === void 0 ? void 0 : s.getLabel(), l = (o = this._keybindingService.lookupKeybinding(Wv)) === null || o === void 0 ? void 0 : o.getLabel();
    i.container.classList.toggle("option-disabled", e.disabled), e.disabled ? i.container.title = e.label : a && l ? this._supportsPreview && e.canPreview ? i.container.title = g({ key: "label-preview", comment: ['placeholders are keybindings, e.g "F2 to apply, Shift+F2 to preview"'] }, "{0} to apply, {1} to preview", a, l) : i.container.title = g({ key: "label", comment: ['placeholder is a keybinding, e.g "F2 to apply"'] }, "{0} to apply", a) : i.container.title = "";
  }
  disposeTemplate(e) {
  }
};
ph = Ov([
  gh(1, xe)
], ph);
class Tx extends UIEvent {
  constructor() {
    super("acceptSelectedAction");
  }
}
class cf extends UIEvent {
  constructor() {
    super("previewSelectedAction");
  }
}
function Ax(r) {
  if (r.kind === "action")
    return r.label;
}
let fh = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._delegate = n, this._contextViewService = s, this._keybindingService = o, this._actionLineHeight = 24, this._headerLineHeight = 26, this.cts = this._register(new Oe()), this.domNode = document.createElement("div"), this.domNode.classList.add("actionList");
    const a = {
      getHeight: (l) => l.kind === "header" ? this._headerLineHeight : this._actionLineHeight,
      getTemplateId: (l) => l.kind
    };
    this._list = this._register(new tg(e, this.domNode, a, [
      new ph(t, this._keybindingService),
      new Ex()
    ], {
      keyboardSupport: !1,
      typeNavigationEnabled: !0,
      keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: Ax },
      accessibilityProvider: {
        getAriaLabel: (l) => {
          if (l.kind === "action") {
            let d = l.label ? Hv(l == null ? void 0 : l.label) : "";
            return l.disabled && (d = g({ key: "customQuickFixWidget.labels", comment: ["Action widget labels for accessibility."] }, "{0}, Disabled Reason: {1}", d, l.disabled)), d;
          }
          return null;
        },
        getWidgetAriaLabel: () => g({ key: "customQuickFixWidget", comment: ["An action widget option"] }, "Action Widget"),
        getRole: (l) => l.kind === "action" ? "option" : "separator",
        getWidgetRole: () => "listbox"
      }
    })), this._list.style(Wm), this._register(this._list.onMouseClick((l) => this.onListClick(l))), this._register(this._list.onMouseOver((l) => this.onListHover(l))), this._register(this._list.onDidChangeFocus(() => this.onFocus())), this._register(this._list.onDidChangeSelection((l) => this.onListSelection(l))), this._allMenuItems = i, this._list.splice(0, this._list.length, this._allMenuItems), this._list.length && this.focusNext();
  }
  focusCondition(e) {
    return !e.disabled && e.kind === "action";
  }
  hide(e) {
    this._delegate.onHide(e), this.cts.cancel(), this._contextViewService.hideContextView();
  }
  layout(e) {
    const t = this._allMenuItems.filter((l) => l.kind === "header").length, n = this._allMenuItems.length * this._actionLineHeight + t * this._headerLineHeight - t * this._actionLineHeight;
    this._list.layout(n);
    let s = e;
    if (this._allMenuItems.length >= 50)
      s = 380;
    else {
      const l = this._allMenuItems.map((d, c) => {
        const h = this.domNode.ownerDocument.getElementById(this._list.getElementID(c));
        if (h) {
          h.style.width = "auto";
          const u = h.getBoundingClientRect().width;
          return h.style.width = "", u;
        }
        return 0;
      });
      s = Math.max(...l, e);
    }
    const a = Math.min(n, this.domNode.ownerDocument.body.clientHeight * 0.7);
    return this._list.layout(a, s), this.domNode.style.height = `${a}px`, this._list.domFocus(), s;
  }
  focusPrevious() {
    this._list.focusPrevious(1, !0, void 0, this.focusCondition);
  }
  focusNext() {
    this._list.focusNext(1, !0, void 0, this.focusCondition);
  }
  acceptSelected(e) {
    const t = this._list.getFocus();
    if (t.length === 0)
      return;
    const i = t[0], n = this._list.element(i);
    if (!this.focusCondition(n))
      return;
    const s = e ? new cf() : new Tx();
    this._list.setSelection([i], s);
  }
  onListSelection(e) {
    if (!e.elements.length)
      return;
    const t = e.elements[0];
    t.item && this.focusCondition(t) ? this._delegate.onSelect(t.item, e.browserEvent instanceof cf) : this._list.setSelection([]);
  }
  onFocus() {
    var e, t;
    const i = this._list.getFocus();
    if (i.length === 0)
      return;
    const n = i[0], s = this._list.element(n);
    (t = (e = this._delegate).onFocus) === null || t === void 0 || t.call(e, s.item);
  }
  async onListHover(e) {
    const t = e.element;
    if (t && t.item && this.focusCondition(t)) {
      if (this._delegate.onHover && !t.disabled && t.kind === "action") {
        const i = await this._delegate.onHover(t.item, this.cts.token);
        t.canPreview = i ? i.canPreview : void 0;
      }
      e.index && this._list.splice(e.index, 1, [t]);
    }
    this._list.setFocus(typeof e.index == "number" ? [e.index] : []);
  }
  onListClick(e) {
    e.element && this.focusCondition(e.element) && this._list.setFocus([]);
  }
};
fh = Ov([
  gh(4, sd),
  gh(5, xe)
], fh);
function Hv(r) {
  return r.replace(/\r\n|\r|\n/g, " ");
}
var Ox = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Lc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
W("actionBar.toggledBackground", { dark: Is, light: Is, hcDark: Is, hcLight: Is }, g("actionBar.toggledBackground", "Background color for toggled action items in action bar."));
const jn = {
  Visible: new Q("codeActionMenuVisible", !1, g("codeActionMenuVisible", "Whether the action widget list is visible"))
}, os = Ti("actionWidgetService");
let qn = class extends P {
  get isVisible() {
    return jn.Visible.getValue(this._contextKeyService) || !1;
  }
  constructor(e, t, i) {
    super(), this._contextViewService = e, this._contextKeyService = t, this._instantiationService = i, this._list = this._register(new ft());
  }
  show(e, t, i, n, s, o, a) {
    const l = jn.Visible.bindTo(this._contextKeyService), d = this._instantiationService.createInstance(fh, e, t, i, n);
    this._contextViewService.showContextView({
      getAnchor: () => s,
      render: (c) => (l.set(!0), this._renderWidget(c, d, a ?? [])),
      onHide: (c) => {
        l.reset(), this._onWidgetClosed(c);
      }
    }, o, !1);
  }
  acceptSelected(e) {
    var t;
    (t = this._list.value) === null || t === void 0 || t.acceptSelected(e);
  }
  focusPrevious() {
    var e, t;
    (t = (e = this._list) === null || e === void 0 ? void 0 : e.value) === null || t === void 0 || t.focusPrevious();
  }
  focusNext() {
    var e, t;
    (t = (e = this._list) === null || e === void 0 ? void 0 : e.value) === null || t === void 0 || t.focusNext();
  }
  hide() {
    var e;
    (e = this._list.value) === null || e === void 0 || e.hide(), this._list.clear();
  }
  _renderWidget(e, t, i) {
    var n;
    const s = document.createElement("div");
    if (s.classList.add("action-widget"), e.appendChild(s), this._list.value = t, this._list.value)
      s.appendChild(this._list.value.domNode);
    else
      throw new Error("List has no value");
    const o = new M(), a = document.createElement("div"), l = e.appendChild(a);
    l.classList.add("context-view-block"), o.add(le(l, Le.MOUSE_DOWN, (f) => f.stopPropagation()));
    const d = document.createElement("div"), c = e.appendChild(d);
    c.classList.add("context-view-pointerBlock"), o.add(le(c, Le.POINTER_MOVE, () => c.remove())), o.add(le(c, Le.MOUSE_DOWN, () => c.remove()));
    let h = 0;
    if (i.length) {
      const f = this._createActionBar(".action-widget-action-bar", i);
      f && (s.appendChild(f.getContainer().parentElement), o.add(f), h = f.getContainer().offsetWidth);
    }
    const u = (n = this._list.value) === null || n === void 0 ? void 0 : n.layout(h);
    s.style.width = `${u}px`;
    const p = o.add(Us(e));
    return o.add(p.onDidBlur(() => this.hide())), o;
  }
  _createActionBar(e, t) {
    if (!t.length)
      return;
    const i = O(e), n = new ur(i);
    return n.push(t, { icon: !1, label: !0 }), n;
  }
  _onWidgetClosed(e) {
    var t;
    (t = this._list.value) === null || t === void 0 || t.hide(e);
  }
};
qn = Ox([
  Lc(0, sd),
  Lc(1, ee),
  Lc(2, q)
], qn);
Ai(
  os,
  qn,
  1
  /* InstantiationType.Delayed */
);
const da = 1100;
ne(class extends rt {
  constructor() {
    super({
      id: "hideCodeActionWidget",
      title: $("hideCodeActionWidget.title", "Hide action widget"),
      precondition: jn.Visible,
      keybinding: {
        weight: da,
        primary: 9,
        secondary: [
          1033
          /* KeyCode.Escape */
        ]
      }
    });
  }
  run(r) {
    r.get(os).hide();
  }
});
ne(class extends rt {
  constructor() {
    super({
      id: "selectPrevCodeAction",
      title: $("selectPrevCodeAction.title", "Select previous action"),
      precondition: jn.Visible,
      keybinding: {
        weight: da,
        primary: 16,
        secondary: [
          2064
          /* KeyCode.UpArrow */
        ],
        mac: { primary: 16, secondary: [
          2064,
          302
          /* KeyCode.KeyP */
        ] }
      }
    });
  }
  run(r) {
    const e = r.get(os);
    e instanceof qn && e.focusPrevious();
  }
});
ne(class extends rt {
  constructor() {
    super({
      id: "selectNextCodeAction",
      title: $("selectNextCodeAction.title", "Select next action"),
      precondition: jn.Visible,
      keybinding: {
        weight: da,
        primary: 18,
        secondary: [
          2066
          /* KeyCode.DownArrow */
        ],
        mac: { primary: 18, secondary: [
          2066,
          300
          /* KeyCode.KeyN */
        ] }
      }
    });
  }
  run(r) {
    const e = r.get(os);
    e instanceof qn && e.focusNext();
  }
});
ne(class extends rt {
  constructor() {
    super({
      id: Fv,
      title: $("acceptSelected.title", "Accept selected action"),
      precondition: jn.Visible,
      keybinding: {
        weight: da,
        primary: 3,
        secondary: [
          2137
          /* KeyCode.Period */
        ]
      }
    });
  }
  run(r) {
    const e = r.get(os);
    e instanceof qn && e.acceptSelected();
  }
});
ne(class extends rt {
  constructor() {
    super({
      id: Wv,
      title: $("previewSelected.title", "Preview selected action"),
      precondition: jn.Visible,
      keybinding: {
        weight: da,
        primary: 2051
      }
    });
  }
  run(r) {
    const e = r.get(os);
    e instanceof qn && e.acceptSelected(!0);
  }
});
const Bv = new Q("supportedCodeAction", ""), hf = "_typescript.applyFixAllCodeAction";
class Fx extends P {
  constructor(e, t, i, n = 250) {
    super(), this._editor = e, this._markerService = t, this._signalChange = i, this._delay = n, this._autoTriggerTimer = this._register(new Xr()), this._register(this._markerService.onMarkerChanged((s) => this._onMarkerChanges(s))), this._register(this._editor.onDidChangeCursorPosition(() => this._tryAutoTrigger()));
  }
  trigger(e) {
    const t = this._getRangeOfSelectionUnlessWhitespaceEnclosed(e);
    this._signalChange(t ? { trigger: e, selection: t } : void 0);
  }
  _onMarkerChanges(e) {
    const t = this._editor.getModel();
    t && e.some((i) => Hm(i, t.uri)) && this._tryAutoTrigger();
  }
  _tryAutoTrigger() {
    this._autoTriggerTimer.cancelAndSet(() => {
      this.trigger({ type: 2, triggerAction: ot.Default });
    }, this._delay);
  }
  _getRangeOfSelectionUnlessWhitespaceEnclosed(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getSelection();
    if (e.type === 1)
      return t;
    const i = this._editor.getOption(
      65
      /* EditorOption.lightbulb */
    ).enabled;
    if (i !== mc.Off) {
      {
        if (i === mc.On)
          return t;
        if (i === mc.OnCode) {
          if (!t.isEmpty())
            return t;
          const s = this._editor.getModel(), { lineNumber: o, column: a } = t.getPosition(), l = s.getLineContent(o);
          if (l.length === 0)
            return;
          if (a === 1) {
            if (/\s/.test(l[0]))
              return;
          } else if (a === s.getLineMaxColumn(o)) {
            if (/\s/.test(l[l.length - 1]))
              return;
          } else if (/\s/.test(l[a - 2]) && /\s/.test(l[a - 1]))
            return;
        }
      }
      return t;
    }
  }
}
var Dn;
(function(r) {
  r.Empty = {
    type: 0
    /* Type.Empty */
  };
  class e {
    constructor(i, n, s) {
      this.trigger = i, this.position = n, this._cancellablePromise = s, this.type = 1, this.actions = s.catch((o) => {
        if (go(o))
          return Vv;
        throw o;
      });
    }
    cancel() {
      this._cancellablePromise.cancel();
    }
  }
  r.Triggered = e;
})(Dn || (Dn = {}));
const Vv = Object.freeze({
  allActions: [],
  validActions: [],
  dispose: () => {
  },
  documentation: [],
  hasAutoFix: !1,
  hasAIFix: !1,
  allAIFixes: !1
});
class Wx extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._editor = e, this._registry = t, this._markerService = i, this._progressService = s, this._configurationService = o, this._codeActionOracle = this._register(new ft()), this._state = Dn.Empty, this._onDidChangeState = this._register(new G()), this.onDidChangeState = this._onDidChangeState.event, this._disposed = !1, this._supportedCodeActions = Bv.bindTo(n), this._register(this._editor.onDidChangeModel(() => this._update())), this._register(this._editor.onDidChangeModelLanguage(() => this._update())), this._register(this._registry.onDidChange(() => this._update())), this._register(this._editor.onDidChangeConfiguration((a) => {
      a.hasChanged(
        65
        /* EditorOption.lightbulb */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._disposed || (this._disposed = !0, super.dispose(), this.setState(Dn.Empty, !0));
  }
  _settingEnabledNearbyQuickfixes() {
    var e;
    const t = (e = this._editor) === null || e === void 0 ? void 0 : e.getModel();
    return this._configurationService ? this._configurationService.getValue("editor.codeActionWidget.includeNearbyQuickFixes", { resource: t == null ? void 0 : t.uri }) : !1;
  }
  _update() {
    if (this._disposed)
      return;
    this._codeActionOracle.value = void 0, this.setState(Dn.Empty);
    const e = this._editor.getModel();
    if (e && this._registry.has(e) && !this._editor.getOption(
      91
      /* EditorOption.readOnly */
    )) {
      const t = this._registry.all(e).flatMap((i) => {
        var n;
        return (n = i.providedCodeActionKinds) !== null && n !== void 0 ? n : [];
      });
      this._supportedCodeActions.set(t.join(" ")), this._codeActionOracle.value = new Fx(this._editor, this._markerService, (i) => {
        var n;
        if (!i) {
          this.setState(Dn.Empty);
          return;
        }
        const s = i.selection.getStartPosition(), o = Pe(async (a) => {
          var l, d, c, h, u, p, f, m, _, v;
          if (this._settingEnabledNearbyQuickfixes() && i.trigger.type === 1 && (i.trigger.triggerAction === ot.QuickFix || !((d = (l = i.trigger.filter) === null || l === void 0 ? void 0 : l.include) === null || d === void 0) && d.contains(H.QuickFix))) {
            const C = await nr(this._registry, e, i.selection, i.trigger, Xi.None, a), w = [...C.allActions];
            if (a.isCancellationRequested)
              return Vv;
            const y = (c = C.validActions) === null || c === void 0 ? void 0 : c.some((k) => k.action.kind ? H.QuickFix.contains(new H(k.action.kind)) : !1), I = this._markerService.read({ resource: e.uri });
            if (y) {
              for (const k of C.validActions)
                !((u = (h = k.action.command) === null || h === void 0 ? void 0 : h.arguments) === null || u === void 0) && u.some((N) => typeof N == "string" && N.includes(hf)) && (k.action.diagnostics = [...I.filter((N) => N.relatedInformation)]);
              return { validActions: C.validActions, allActions: w, documentation: C.documentation, hasAutoFix: C.hasAutoFix, hasAIFix: C.hasAIFix, allAIFixes: C.allAIFixes, dispose: () => {
                C.dispose();
              } };
            } else if (!y && I.length > 0) {
              const k = i.selection.getPosition();
              let N = k, J = Number.MAX_VALUE;
              const te = [...C.validActions];
              for (const be of I) {
                const et = be.endColumn, cs = be.endLineNumber, ko = be.startLineNumber;
                if (cs === k.lineNumber || ko === k.lineNumber) {
                  N = new F(cs, et);
                  const KC = {
                    type: i.trigger.type,
                    triggerAction: i.trigger.triggerAction,
                    filter: { include: !((p = i.trigger.filter) === null || p === void 0) && p.include ? (f = i.trigger.filter) === null || f === void 0 ? void 0 : f.include : H.QuickFix },
                    autoApply: i.trigger.autoApply,
                    context: { notAvailableMessage: ((m = i.trigger.context) === null || m === void 0 ? void 0 : m.notAvailableMessage) || "", position: N }
                  }, GC = new z(N.lineNumber, N.column, N.lineNumber, N.column), No = await nr(this._registry, e, GC, KC, Xi.None, a);
                  if (No.validActions.length !== 0) {
                    for (const bp of No.validActions)
                      !((v = (_ = bp.action.command) === null || _ === void 0 ? void 0 : _.arguments) === null || v === void 0) && v.some((Ca) => typeof Ca == "string" && Ca.includes(hf)) && (bp.action.diagnostics = [...I.filter((Ca) => Ca.relatedInformation)]);
                    C.allActions.length === 0 && w.push(...No.allActions), Math.abs(k.column - et) < J ? te.unshift(...No.validActions) : te.push(...No.validActions);
                  }
                  J = Math.abs(k.column - et);
                }
              }
              const ve = te.filter((be, et, cs) => cs.findIndex((ko) => ko.action.title === be.action.title) === et);
              return ve.sort((be, et) => be.action.isPreferred && !et.action.isPreferred ? -1 : !be.action.isPreferred && et.action.isPreferred || be.action.isAI && !et.action.isAI ? 1 : !be.action.isAI && et.action.isAI ? -1 : 0), { validActions: ve, allActions: w, documentation: C.documentation, hasAutoFix: C.hasAutoFix, hasAIFix: C.hasAIFix, allAIFixes: C.allAIFixes, dispose: () => {
                C.dispose();
              } };
            }
          }
          return nr(this._registry, e, i.selection, i.trigger, Xi.None, a);
        });
        i.trigger.type === 1 && ((n = this._progressService) === null || n === void 0 || n.showWhile(o, 250)), this.setState(new Dn.Triggered(i.trigger, s, o));
      }, void 0), this._codeActionOracle.value.trigger({ type: 2, triggerAction: ot.Default });
    } else
      this._supportedCodeActions.reset();
  }
  trigger(e) {
    var t;
    (t = this._codeActionOracle.value) === null || t === void 0 || t.trigger(e);
  }
  setState(e, t) {
    e !== this._state && (this._state.type === 1 && this._state.cancel(), this._state = e, !t && !this._disposed && this._onDidChangeState.fire(e));
  }
}
var Hx = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, fi = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Ss;
const Bx = "quickfix-edit-highlight";
let on = Ss = class extends P {
  static get(e) {
    return e.getContribution(Ss.ID);
  }
  constructor(e, t, i, n, s, o, a, l, d, c) {
    super(), this._commandService = a, this._configurationService = l, this._actionWidgetService = d, this._instantiationService = c, this._activeCodeActions = this._register(new ft()), this._showDisabled = !1, this._disposed = !1, this._editor = e, this._model = this._register(new Wx(this._editor, s.codeActionProvider, t, i, o, l)), this._register(this._model.onDidChangeState((h) => this.update(h))), this._lightBulbWidget = new Qu(() => {
      const h = this._editor.getContribution($n.ID);
      return h && this._register(h.onClick((u) => this.showCodeActionsFromLightbulb(u.actions, u))), h;
    }), this._resolver = n.createInstance(Pl), this._register(this._editor.onDidLayoutChange(() => this._actionWidgetService.hide()));
  }
  dispose() {
    this._disposed = !0, super.dispose();
  }
  async showCodeActionsFromLightbulb(e, t) {
    if (e.allAIFixes && e.validActions.length === 1) {
      const i = e.validActions[0], n = i.action.command;
      n && n.id === "inlineChat.start" && n.arguments && n.arguments.length >= 1 && (n.arguments[0] = { ...n.arguments[0], autoSend: !1 }), await this._applyCodeAction(i, !1, !1, Os.FromAILightbulb);
      return;
    }
    await this.showCodeActionList(e, t, { includeDisabledActions: !1, fromLightbulb: !0 });
  }
  showCodeActions(e, t, i) {
    return this.showCodeActionList(t, i, { includeDisabledActions: !1, fromLightbulb: !1 });
  }
  manualTriggerAtCurrentPosition(e, t, i, n) {
    var s;
    if (!this._editor.hasModel())
      return;
    (s = qe.get(this._editor)) === null || s === void 0 || s.closeMessage();
    const o = this._editor.getPosition();
    this._trigger({ type: 1, triggerAction: t, filter: i, autoApply: n, context: { notAvailableMessage: e, position: o } });
  }
  _trigger(e) {
    return this._model.trigger(e);
  }
  async _applyCodeAction(e, t, i, n) {
    try {
      await this._instantiationService.invokeFunction(Ix, e, n, { preview: i, editor: this._editor });
    } finally {
      t && this._trigger({ type: 2, triggerAction: ot.QuickFix, filter: {} });
    }
  }
  async update(e) {
    var t, i, n, s, o, a, l;
    if (e.type !== 1) {
      (t = this._lightBulbWidget.rawValue) === null || t === void 0 || t.hide();
      return;
    }
    let d;
    try {
      d = await e.actions;
    } catch (c) {
      re(c);
      return;
    }
    if (!this._disposed)
      if ((i = this._lightBulbWidget.value) === null || i === void 0 || i.update(d, e.trigger, e.position), e.trigger.type === 1) {
        if (!((n = e.trigger.filter) === null || n === void 0) && n.include) {
          const h = this.tryGetValidActionToApply(e.trigger, d);
          if (h) {
            try {
              (s = this._lightBulbWidget.value) === null || s === void 0 || s.hide(), await this._applyCodeAction(h, !1, !1, Os.FromCodeActions);
            } finally {
              d.dispose();
            }
            return;
          }
          if (e.trigger.context) {
            const u = this.getInvalidActionThatWouldHaveBeenApplied(e.trigger, d);
            if (u && u.action.disabled) {
              (o = qe.get(this._editor)) === null || o === void 0 || o.showMessage(u.action.disabled, e.trigger.context.position), d.dispose();
              return;
            }
          }
        }
        const c = !!(!((a = e.trigger.filter) === null || a === void 0) && a.include);
        if (e.trigger.context && (!d.allActions.length || !c && !d.validActions.length)) {
          (l = qe.get(this._editor)) === null || l === void 0 || l.showMessage(e.trigger.context.notAvailableMessage, e.trigger.context.position), this._activeCodeActions.value = d, d.dispose();
          return;
        }
        this._activeCodeActions.value = d, this.showCodeActionList(d, this.toCoords(e.position), { includeDisabledActions: c, fromLightbulb: !1 });
      } else
        this._actionWidgetService.isVisible ? d.dispose() : this._activeCodeActions.value = d;
  }
  getInvalidActionThatWouldHaveBeenApplied(e, t) {
    if (t.allActions.length && (e.autoApply === "first" && t.validActions.length === 0 || e.autoApply === "ifSingle" && t.allActions.length === 1))
      return t.allActions.find(({ action: i }) => i.disabled);
  }
  tryGetValidActionToApply(e, t) {
    if (t.validActions.length && (e.autoApply === "first" && t.validActions.length > 0 || e.autoApply === "ifSingle" && t.validActions.length === 1))
      return t.validActions[0];
  }
  async showCodeActionList(e, t, i) {
    const n = this._editor.createDecorationsCollection(), s = this._editor.getDomNode();
    if (!s)
      return;
    const o = i.includeDisabledActions && (this._showDisabled || e.validActions.length === 0) ? e.allActions : e.validActions;
    if (!o.length)
      return;
    const a = F.isIPosition(t) ? this.toCoords(t) : t, l = {
      onSelect: async (d, c) => {
        this._applyCodeAction(
          d,
          /* retrigger */
          !0,
          !!c,
          Os.FromCodeActions
        ), this._actionWidgetService.hide(), n.clear();
      },
      onHide: () => {
        var d;
        (d = this._editor) === null || d === void 0 || d.focus(), n.clear();
      },
      onHover: async (d, c) => {
        var h;
        if (!c.isCancellationRequested)
          return { canPreview: !!(!((h = d.action.edit) === null || h === void 0) && h.edits.length) };
      },
      onFocus: (d) => {
        var c, h;
        if (d && d.action) {
          const u = d.action.ranges, p = d.action.diagnostics;
          if (n.clear(), u && u.length > 0) {
            const f = p && (p == null ? void 0 : p.length) > 1 ? p.map((m) => ({ range: m, options: Ss.DECORATION })) : u.map((m) => ({ range: m, options: Ss.DECORATION }));
            n.set(f);
          } else if (p && p.length > 0) {
            const f = p.map((_) => ({ range: _, options: Ss.DECORATION }));
            n.set(f);
            const m = p[0];
            if (m.startLineNumber && m.startColumn) {
              const _ = (h = (c = this._editor.getModel()) === null || c === void 0 ? void 0 : c.getWordAtPosition({ lineNumber: m.startLineNumber, column: m.startColumn })) === null || h === void 0 ? void 0 : h.word;
              zs(g("editingNewSelection", "Context: {0} at line {1} and column {2}.", _, m.startLineNumber, m.startColumn));
            }
          }
        } else
          n.clear();
      }
    };
    this._actionWidgetService.show("codeActionWidget", !0, Px(o, this._shouldShowHeaders(), this._resolver.getResolver()), l, a, s, this._getActionBarActions(e, t, i));
  }
  toCoords(e) {
    if (!this._editor.hasModel())
      return { x: 0, y: 0 };
    this._editor.revealPosition(
      e,
      1
      /* ScrollType.Immediate */
    ), this._editor.render();
    const t = this._editor.getScrolledVisiblePosition(e), i = mt(this._editor.getDomNode()), n = i.left + t.left, s = i.top + t.top + t.height;
    return { x: n, y: s };
  }
  _shouldShowHeaders() {
    var e;
    const t = (e = this._editor) === null || e === void 0 ? void 0 : e.getModel();
    return this._configurationService.getValue("editor.codeActionWidget.showHeaders", { resource: t == null ? void 0 : t.uri });
  }
  _getActionBarActions(e, t, i) {
    if (i.fromLightbulb)
      return [];
    const n = e.documentation.map((s) => {
      var o;
      return {
        id: s.id,
        label: s.title,
        tooltip: (o = s.tooltip) !== null && o !== void 0 ? o : "",
        class: void 0,
        enabled: !0,
        run: () => {
          var a;
          return this._commandService.executeCommand(s.id, ...(a = s.arguments) !== null && a !== void 0 ? a : []);
        }
      };
    });
    return i.includeDisabledActions && e.validActions.length > 0 && e.allActions.length !== e.validActions.length && n.push(this._showDisabled ? {
      id: "hideMoreActions",
      label: g("hideMoreActions", "Hide Disabled"),
      enabled: !0,
      tooltip: "",
      class: void 0,
      run: () => (this._showDisabled = !1, this.showCodeActionList(e, t, i))
    } : {
      id: "showMoreActions",
      label: g("showMoreActions", "Show Disabled"),
      enabled: !0,
      tooltip: "",
      class: void 0,
      run: () => (this._showDisabled = !0, this.showCodeActionList(e, t, i))
    }), n;
  }
};
on.ID = "editor.contrib.codeActionController";
on.DECORATION = Y.register({
  description: "quickfix-highlight",
  className: Bx
});
on = Ss = Hx([
  fi(1, ig),
  fi(2, ee),
  fi(3, q),
  fi(4, V),
  fi(5, Qr),
  fi(6, Fe),
  fi(7, he),
  fi(8, os),
  fi(9, q)
], on);
od((r, e) => {
  ((n, s) => {
    s && e.addRule(`.monaco-editor ${n} { background-color: ${s}; }`);
  })(".quickfix-edit-highlight", r.getColor(cS));
  const i = r.getColor(Bm);
  i && e.addRule(`.monaco-editor .quickfix-edit-highlight { border: 1px ${gr(r.type) ? "dotted" : "solid"} ${i}; box-sizing: border-box; }`);
});
function ca(r) {
  return L.regex(Bv.keys()[0], new RegExp("(\\s|^)" + pr(r.value) + "\\b"));
}
const Tg = {
  type: "object",
  defaultSnippets: [{ body: { kind: "" } }],
  properties: {
    kind: {
      type: "string",
      description: g("args.schema.kind", "Kind of the code action to run.")
    },
    apply: {
      type: "string",
      description: g("args.schema.apply", "Controls when the returned actions are applied."),
      default: "ifSingle",
      enum: [
        "first",
        "ifSingle",
        "never"
        /* CodeActionAutoApply.Never */
      ],
      enumDescriptions: [
        g("args.schema.apply.first", "Always apply the first returned code action."),
        g("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
        g("args.schema.apply.never", "Do not apply the returned code actions.")
      ]
    },
    preferred: {
      type: "boolean",
      default: !1,
      description: g("args.schema.preferred", "Controls if only preferred code actions should be returned.")
    }
  }
};
function rs(r, e, t, i, n = ot.Default) {
  if (r.hasModel()) {
    const s = on.get(r);
    s == null || s.manualTriggerAtCurrentPosition(e, n, t, i);
  }
}
class Vx extends D {
  constructor() {
    super({
      id: Pg,
      label: g("quickfix.trigger.label", "Quick Fix..."),
      alias: "Quick Fix...",
      precondition: L.and(b.writable, b.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 2137,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    return rs(t, g("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0, ot.QuickFix);
  }
}
class Ux extends bt {
  constructor() {
    super({
      id: Pv,
      precondition: L.and(b.writable, b.hasCodeActionsProvider),
      metadata: {
        description: "Trigger a code action",
        args: [{ name: "args", schema: Tg }]
      }
    });
  }
  runEditorCommand(e, t, i) {
    const n = ti.fromUser(i, {
      kind: H.Empty,
      apply: "ifSingle"
    });
    return rs(t, typeof (i == null ? void 0 : i.kind) == "string" ? n.preferred ? g("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", i.kind) : g("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", i.kind) : n.preferred ? g("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : g("editor.action.codeAction.noneMessage", "No code actions available"), {
      include: n.kind,
      includeSourceActions: !0,
      onlyIncludePreferredActions: n.preferred
    }, n.apply);
  }
}
class zx extends D {
  constructor() {
    super({
      id: Ev,
      label: g("refactor.label", "Refactor..."),
      alias: "Refactor...",
      precondition: L.and(b.writable, b.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 3120,
        mac: {
          primary: 1328
          /* KeyCode.KeyR */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 2,
        when: L.and(b.writable, ca(H.Refactor))
      },
      metadata: {
        description: "Refactor...",
        args: [{ name: "args", schema: Tg }]
      }
    });
  }
  run(e, t, i) {
    const n = ti.fromUser(i, {
      kind: H.Refactor,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return rs(t, typeof (i == null ? void 0 : i.kind) == "string" ? n.preferred ? g("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", i.kind) : g("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", i.kind) : n.preferred ? g("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : g("editor.action.refactor.noneMessage", "No refactorings available"), {
      include: H.Refactor.contains(n.kind) ? n.kind : H.None,
      onlyIncludePreferredActions: n.preferred
    }, n.apply, ot.Refactor);
  }
}
class $x extends D {
  constructor() {
    super({
      id: Tv,
      label: g("source.label", "Source Action..."),
      alias: "Source Action...",
      precondition: L.and(b.writable, b.hasCodeActionsProvider),
      contextMenuOpts: {
        group: "1_modification",
        order: 2.1,
        when: L.and(b.writable, ca(H.Source))
      },
      metadata: {
        description: "Source Action...",
        args: [{ name: "args", schema: Tg }]
      }
    });
  }
  run(e, t, i) {
    const n = ti.fromUser(i, {
      kind: H.Source,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return rs(t, typeof (i == null ? void 0 : i.kind) == "string" ? n.preferred ? g("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", i.kind) : g("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", i.kind) : n.preferred ? g("editor.action.source.noneMessage.preferred", "No preferred source actions available") : g("editor.action.source.noneMessage", "No source actions available"), {
      include: H.Source.contains(n.kind) ? n.kind : H.None,
      includeSourceActions: !0,
      onlyIncludePreferredActions: n.preferred
    }, n.apply, ot.SourceAction);
  }
}
class jx extends D {
  constructor() {
    super({
      id: Mg,
      label: g("organizeImports.label", "Organize Imports"),
      alias: "Organize Imports",
      precondition: L.and(b.writable, ca(H.SourceOrganizeImports)),
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 1581,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    return rs(t, g("editor.action.organize.noneMessage", "No organize imports action available"), { include: H.SourceOrganizeImports, includeSourceActions: !0 }, "ifSingle", ot.OrganizeImports);
  }
}
class qx extends D {
  constructor() {
    super({
      id: Eg,
      label: g("fixAll.label", "Fix All"),
      alias: "Fix All",
      precondition: L.and(b.writable, ca(H.SourceFixAll))
    });
  }
  run(e, t) {
    return rs(t, g("fixAll.noneMessage", "No fix all action available"), { include: H.SourceFixAll, includeSourceActions: !0 }, "ifSingle", ot.FixAll);
  }
}
class Kx extends D {
  constructor() {
    super({
      id: Mv,
      label: g("autoFix.label", "Auto Fix..."),
      alias: "Auto Fix...",
      precondition: L.and(b.writable, ca(H.QuickFix)),
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 1625,
        mac: {
          primary: 2649
          /* KeyCode.Period */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    return rs(t, g("editor.action.autoFix.noneMessage", "No auto fixes available"), {
      include: H.QuickFix,
      onlyIncludePreferredActions: !0
    }, "ifSingle", ot.AutoFix);
  }
}
Z(
  on.ID,
  on,
  3
  /* EditorContributionInstantiation.Eventually */
);
Z(
  $n.ID,
  $n,
  4
  /* EditorContributionInstantiation.Lazy */
);
x(Vx);
x(zx);
x($x);
x(jx);
x(Kx);
x(qx);
B(new Ux());
hi.as(rd.Configuration).registerConfiguration({
  ...ng,
  properties: {
    "editor.codeActionWidget.showHeaders": {
      type: "boolean",
      scope: 5,
      description: g("showCodeActionHeaders", "Enable/disable showing group headers in the Code Action menu."),
      default: !0
    }
  }
});
hi.as(rd.Configuration).registerConfiguration({
  ...ng,
  properties: {
    "editor.codeActionWidget.includeNearbyQuickFixes": {
      type: "boolean",
      scope: 5,
      description: g("includeNearbyQuickFixes", "Enable/disable showing nearest Quick Fix within a line when not currently on a diagnostic."),
      default: !0
    }
  }
});
class mh {
  constructor() {
    this.lenses = [], this._disposables = new M();
  }
  dispose() {
    this._disposables.dispose();
  }
  get isDisposed() {
    return this._disposables.isDisposed;
  }
  add(e, t) {
    this._disposables.add(e);
    for (const i of e.lenses)
      this.lenses.push({ symbol: i, provider: t });
  }
}
async function Uv(r, e, t) {
  const i = r.ordered(e), n = /* @__PURE__ */ new Map(), s = new mh(), o = i.map(async (a, l) => {
    n.set(a, l);
    try {
      const d = await Promise.resolve(a.provideCodeLenses(e, t));
      d && s.add(d, a);
    } catch (d) {
      Ie(d);
    }
  });
  return await Promise.all(o), s.lenses = s.lenses.sort((a, l) => a.symbol.range.startLineNumber < l.symbol.range.startLineNumber ? -1 : a.symbol.range.startLineNumber > l.symbol.range.startLineNumber ? 1 : n.get(a.provider) < n.get(l.provider) ? -1 : n.get(a.provider) > n.get(l.provider) ? 1 : a.symbol.range.startColumn < l.symbol.range.startColumn ? -1 : a.symbol.range.startColumn > l.symbol.range.startColumn ? 1 : 0), s;
}
de.registerCommand("_executeCodeLensProvider", function(r, ...e) {
  let [t, i] = e;
  ie(ce.isUri(t)), ie(typeof i == "number" || !i);
  const { codeLensProvider: n } = r.get(V), s = r.get(Ge).getModel(t);
  if (!s)
    throw wi();
  const o = [], a = new M();
  return Uv(n, s, X.None).then((l) => {
    a.add(l);
    const d = [];
    for (const c of l.lenses)
      i == null || c.symbol.command ? o.push(c.symbol) : i-- > 0 && c.provider.resolveCodeLens && d.push(Promise.resolve(c.provider.resolveCodeLens(s, c.symbol, X.None)).then((h) => o.push(h || c.symbol)));
    return Promise.all(d);
  }).then(() => o).finally(() => {
    setTimeout(() => a.dispose(), 100);
  });
});
var Gx = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Zx = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const zv = Ti("ICodeLensCache");
class uf {
  constructor(e, t) {
    this.lineCount = e, this.data = t;
  }
}
let _h = class {
  constructor(e) {
    this._fakeProvider = new class {
      provideCodeLenses() {
        throw new Error("not supported");
      }
    }(), this._cache = new Yr(20, 0.75);
    const t = "codelens/cache";
    hS(uS, () => e.remove(
      t,
      1
      /* StorageScope.WORKSPACE */
    ));
    const i = "codelens/cache2", n = e.get(i, 1, "{}");
    this._deserialize(n), De.once(e.onWillSaveState)((s) => {
      s.reason === sg.SHUTDOWN && e.store(
        i,
        this._serialize(),
        1,
        1
        /* StorageTarget.MACHINE */
      );
    });
  }
  put(e, t) {
    const i = t.lenses.map((o) => {
      var a;
      return {
        range: o.symbol.range,
        command: o.symbol.command && { id: "", title: (a = o.symbol.command) === null || a === void 0 ? void 0 : a.title }
      };
    }), n = new mh();
    n.add({ lenses: i, dispose: () => {
    } }, this._fakeProvider);
    const s = new uf(e.getLineCount(), n);
    this._cache.set(e.uri.toString(), s);
  }
  get(e) {
    const t = this._cache.get(e.uri.toString());
    return t && t.lineCount === e.getLineCount() ? t.data : void 0;
  }
  delete(e) {
    this._cache.delete(e.uri.toString());
  }
  // --- persistence
  _serialize() {
    const e = /* @__PURE__ */ Object.create(null);
    for (const [t, i] of this._cache) {
      const n = /* @__PURE__ */ new Set();
      for (const s of i.data.lenses)
        n.add(s.symbol.range.startLineNumber);
      e[t] = {
        lineCount: i.lineCount,
        lines: [...n.values()]
      };
    }
    return JSON.stringify(e);
  }
  _deserialize(e) {
    try {
      const t = JSON.parse(e);
      for (const i in t) {
        const n = t[i], s = [];
        for (const a of n.lines)
          s.push({ range: new S(a, 1, a, 11) });
        const o = new mh();
        o.add({ lenses: s, dispose() {
        } }, this._fakeProvider), this._cache.set(i, new uf(n.lineCount, o));
      }
    } catch {
    }
  }
};
_h = Gx([
  Zx(0, vn)
], _h);
Ai(
  zv,
  _h,
  1
  /* InstantiationType.Delayed */
);
class Xx {
  constructor(e, t, i) {
    this.afterColumn = 1073741824, this.afterLineNumber = e, this.heightInPx = t, this._onHeight = i, this.suppressMouseDown = !0, this.domNode = document.createElement("div");
  }
  onComputedHeight(e) {
    this._lastHeight === void 0 ? this._lastHeight = e : this._lastHeight !== e && (this._lastHeight = e, this._onHeight());
  }
  isVisible() {
    return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
  }
}
class yr {
  constructor(e, t) {
    this.allowEditorOverflow = !1, this.suppressMouseDown = !0, this._commands = /* @__PURE__ */ new Map(), this._isEmpty = !0, this._editor = e, this._id = `codelens.widget-${yr._idPool++}`, this.updatePosition(t), this._domNode = document.createElement("span"), this._domNode.className = "codelens-decoration";
  }
  withCommands(e, t) {
    this._commands.clear();
    const i = [];
    let n = !1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o && (n = !0, o.command)) {
        const a = gS(o.command.title.trim());
        if (o.command.id) {
          const l = `c${yr._idPool++}`;
          i.push(O("a", { id: l, title: o.command.tooltip, role: "button" }, ...a)), this._commands.set(l, o.command);
        } else
          i.push(O("span", { title: o.command.tooltip }, ...a));
        s + 1 < e.length && i.push(O("span", void 0, "|"));
      }
    }
    n ? (Cl(this._domNode, ...i), this._isEmpty && t && this._domNode.classList.add("fadein"), this._isEmpty = !1) : Cl(this._domNode, O("span", void 0, "no commands"));
  }
  getCommand(e) {
    return e.parentElement === this._domNode ? this._commands.get(e.id) : void 0;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  updatePosition(e) {
    const t = this._editor.getModel().getLineFirstNonWhitespaceColumn(e);
    this._widgetPosition = {
      position: { lineNumber: e, column: t },
      preference: [
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  getPosition() {
    return this._widgetPosition || null;
  }
}
yr._idPool = 0;
class Ic {
  constructor() {
    this._removeDecorations = [], this._addDecorations = [], this._addDecorationsCallbacks = [];
  }
  addDecoration(e, t) {
    this._addDecorations.push(e), this._addDecorationsCallbacks.push(t);
  }
  removeDecoration(e) {
    this._removeDecorations.push(e);
  }
  commit(e) {
    const t = e.deltaDecorations(this._removeDecorations, this._addDecorations);
    for (let i = 0, n = t.length; i < n; i++)
      this._addDecorationsCallbacks[i](t[i]);
  }
}
const gf = Y.register({
  collapseOnReplaceEdit: !0,
  description: "codelens"
});
class pf {
  constructor(e, t, i, n, s, o) {
    this._isDisposed = !1, this._editor = t, this._data = e, this._decorationIds = [];
    let a;
    const l = [];
    this._data.forEach((d, c) => {
      d.symbol.command && l.push(d.symbol), i.addDecoration({
        range: d.symbol.range,
        options: gf
      }, (h) => this._decorationIds[c] = h), a ? a = S.plusRange(a, d.symbol.range) : a = S.lift(d.symbol.range);
    }), this._viewZone = new Xx(a.startLineNumber - 1, s, o), this._viewZoneId = n.addZone(this._viewZone), l.length > 0 && (this._createContentWidgetIfNecessary(), this._contentWidget.withCommands(l, !1));
  }
  _createContentWidgetIfNecessary() {
    this._contentWidget ? this._editor.layoutContentWidget(this._contentWidget) : (this._contentWidget = new yr(this._editor, this._viewZone.afterLineNumber + 1), this._editor.addContentWidget(this._contentWidget));
  }
  dispose(e, t) {
    this._decorationIds.forEach(e.removeDecoration, e), this._decorationIds = [], t == null || t.removeZone(this._viewZoneId), this._contentWidget && (this._editor.removeContentWidget(this._contentWidget), this._contentWidget = void 0), this._isDisposed = !0;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isValid() {
    return this._decorationIds.some((e, t) => {
      const i = this._editor.getModel().getDecorationRange(e), n = this._data[t].symbol;
      return !!(i && S.isEmpty(n.range) === i.isEmpty());
    });
  }
  updateCodeLensSymbols(e, t) {
    this._decorationIds.forEach(t.removeDecoration, t), this._decorationIds = [], this._data = e, this._data.forEach((i, n) => {
      t.addDecoration({
        range: i.symbol.range,
        options: gf
      }, (s) => this._decorationIds[n] = s);
    });
  }
  updateHeight(e, t) {
    this._viewZone.heightInPx = e, t.layoutZone(this._viewZoneId), this._contentWidget && this._editor.layoutContentWidget(this._contentWidget);
  }
  computeIfNecessary(e) {
    if (!this._viewZone.isVisible())
      return null;
    for (let t = 0; t < this._decorationIds.length; t++) {
      const i = e.getDecorationRange(this._decorationIds[t]);
      i && (this._data[t].symbol.range = i);
    }
    return this._data;
  }
  updateCommands(e) {
    this._createContentWidgetIfNecessary(), this._contentWidget.withCommands(e, !0);
    for (let t = 0; t < this._data.length; t++) {
      const i = e[t];
      if (i) {
        const { symbol: n } = this._data[t];
        n.command = i.command || n.command;
      }
    }
  }
  getCommand(e) {
    var t;
    return (t = this._contentWidget) === null || t === void 0 ? void 0 : t.getCommand(e);
  }
  getLineNumber() {
    const e = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
    return e ? e.startLineNumber : -1;
  }
  update(e) {
    if (this.isValid()) {
      const t = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      t && (this._viewZone.afterLineNumber = t.startLineNumber - 1, e.layoutZone(this._viewZoneId), this._contentWidget && (this._contentWidget.updatePosition(t.startLineNumber), this._editor.layoutContentWidget(this._contentWidget)));
    }
  }
}
var Qx = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Mo = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Ys = class {
  constructor(e, t, i, n, s, o) {
    this._editor = e, this._languageFeaturesService = t, this._commandService = n, this._notificationService = s, this._codeLensCache = o, this._disposables = new M(), this._localToDispose = new M(), this._lenses = [], this._oldCodeLensModels = new M(), this._provideCodeLensDebounce = i.for(t.codeLensProvider, "CodeLensProvide", { min: 250 }), this._resolveCodeLensesDebounce = i.for(t.codeLensProvider, "CodeLensResolve", { min: 250, salt: "resolve" }), this._resolveCodeLensesScheduler = new Re(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default()), this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange())), this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange())), this._disposables.add(this._editor.onDidChangeConfiguration((a) => {
      (a.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) || a.hasChanged(
        19
        /* EditorOption.codeLensFontSize */
      ) || a.hasChanged(
        18
        /* EditorOption.codeLensFontFamily */
      )) && this._updateLensStyle(), a.hasChanged(
        17
        /* EditorOption.codeLens */
      ) && this._onModelChange();
    })), this._disposables.add(t.codeLensProvider.onDidChange(this._onModelChange, this)), this._onModelChange(), this._updateLensStyle();
  }
  dispose() {
    var e;
    this._localDispose(), this._disposables.dispose(), this._oldCodeLensModels.dispose(), (e = this._currentCodeLensModel) === null || e === void 0 || e.dispose();
  }
  _getLayoutInfo() {
    const e = Math.max(1.3, this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ) / this._editor.getOption(
      52
      /* EditorOption.fontSize */
    ));
    let t = this._editor.getOption(
      19
      /* EditorOption.codeLensFontSize */
    );
    return (!t || t < 5) && (t = this._editor.getOption(
      52
      /* EditorOption.fontSize */
    ) * 0.9 | 0), {
      fontSize: t,
      codeLensHeight: t * e | 0
    };
  }
  _updateLensStyle() {
    const { codeLensHeight: e, fontSize: t } = this._getLayoutInfo(), i = this._editor.getOption(
      18
      /* EditorOption.codeLensFontFamily */
    ), n = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), { style: s } = this._editor.getContainerDomNode();
    s.setProperty("--vscode-editorCodeLens-lineHeight", `${e}px`), s.setProperty("--vscode-editorCodeLens-fontSize", `${t}px`), s.setProperty("--vscode-editorCodeLens-fontFeatureSettings", n.fontFeatureSettings), i && (s.setProperty("--vscode-editorCodeLens-fontFamily", i), s.setProperty("--vscode-editorCodeLens-fontFamilyDefault", Vm.fontFamily)), this._editor.changeViewZones((o) => {
      for (const a of this._lenses)
        a.updateHeight(e, o);
    });
  }
  _localDispose() {
    var e, t, i;
    (e = this._getCodeLensModelPromise) === null || e === void 0 || e.cancel(), this._getCodeLensModelPromise = void 0, (t = this._resolveCodeLensesPromise) === null || t === void 0 || t.cancel(), this._resolveCodeLensesPromise = void 0, this._localToDispose.clear(), this._oldCodeLensModels.clear(), (i = this._currentCodeLensModel) === null || i === void 0 || i.dispose();
  }
  _onModelChange() {
    this._localDispose();
    const e = this._editor.getModel();
    if (!e || !this._editor.getOption(
      17
      /* EditorOption.codeLens */
    ) || e.isTooLargeForTokenization())
      return;
    const t = this._codeLensCache.get(e);
    if (t && this._renderCodeLensSymbols(t), !this._languageFeaturesService.codeLensProvider.has(e)) {
      t && hr(() => {
        const n = this._codeLensCache.get(e);
        t === n && (this._codeLensCache.delete(e), this._onModelChange());
      }, 30 * 1e3, this._localToDispose);
      return;
    }
    for (const n of this._languageFeaturesService.codeLensProvider.all(e))
      if (typeof n.onDidChange == "function") {
        const s = n.onDidChange(() => i.schedule());
        this._localToDispose.add(s);
      }
    const i = new Re(() => {
      var n;
      const s = Date.now();
      (n = this._getCodeLensModelPromise) === null || n === void 0 || n.cancel(), this._getCodeLensModelPromise = Pe((o) => Uv(this._languageFeaturesService.codeLensProvider, e, o)), this._getCodeLensModelPromise.then((o) => {
        this._currentCodeLensModel && this._oldCodeLensModels.add(this._currentCodeLensModel), this._currentCodeLensModel = o, this._codeLensCache.put(e, o);
        const a = this._provideCodeLensDebounce.update(e, Date.now() - s);
        i.delay = a, this._renderCodeLensSymbols(o), this._resolveCodeLensesInViewportSoon();
      }, re);
    }, this._provideCodeLensDebounce.get(e));
    this._localToDispose.add(i), this._localToDispose.add(pe(() => this._resolveCodeLensesScheduler.cancel())), this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      var n;
      this._editor.changeDecorations((s) => {
        this._editor.changeViewZones((o) => {
          const a = [];
          let l = -1;
          this._lenses.forEach((c) => {
            !c.isValid() || l === c.getLineNumber() ? a.push(c) : (c.update(o), l = c.getLineNumber());
          });
          const d = new Ic();
          a.forEach((c) => {
            c.dispose(d, o), this._lenses.splice(this._lenses.indexOf(c), 1);
          }), d.commit(s);
        });
      }), i.schedule(), this._resolveCodeLensesScheduler.cancel(), (n = this._resolveCodeLensesPromise) === null || n === void 0 || n.cancel(), this._resolveCodeLensesPromise = void 0;
    })), this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
      i.schedule();
    })), this._localToDispose.add(this._editor.onDidBlurEditorText(() => {
      i.cancel();
    })), this._localToDispose.add(this._editor.onDidScrollChange((n) => {
      n.scrollTopChanged && this._lenses.length > 0 && this._resolveCodeLensesInViewportSoon();
    })), this._localToDispose.add(this._editor.onDidLayoutChange(() => {
      this._resolveCodeLensesInViewportSoon();
    })), this._localToDispose.add(pe(() => {
      if (this._editor.getModel()) {
        const n = $s.capture(this._editor);
        this._editor.changeDecorations((s) => {
          this._editor.changeViewZones((o) => {
            this._disposeAllLenses(s, o);
          });
        }), n.restore(this._editor);
      } else
        this._disposeAllLenses(void 0, void 0);
    })), this._localToDispose.add(this._editor.onMouseDown((n) => {
      if (n.target.type !== 9)
        return;
      let s = n.target.element;
      if ((s == null ? void 0 : s.tagName) === "SPAN" && (s = s.parentElement), (s == null ? void 0 : s.tagName) === "A")
        for (const o of this._lenses) {
          const a = o.getCommand(s);
          if (a) {
            this._commandService.executeCommand(a.id, ...a.arguments || []).catch((l) => this._notificationService.error(l));
            break;
          }
        }
    })), i.schedule();
  }
  _disposeAllLenses(e, t) {
    const i = new Ic();
    for (const n of this._lenses)
      n.dispose(i, t);
    e && i.commit(e), this._lenses.length = 0;
  }
  _renderCodeLensSymbols(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel().getLineCount(), i = [];
    let n;
    for (const a of e.lenses) {
      const l = a.symbol.range.startLineNumber;
      l < 1 || l > t || (n && n[n.length - 1].symbol.range.startLineNumber === l ? n.push(a) : (n = [a], i.push(n)));
    }
    if (!i.length && !this._lenses.length)
      return;
    const s = $s.capture(this._editor), o = this._getLayoutInfo();
    this._editor.changeDecorations((a) => {
      this._editor.changeViewZones((l) => {
        const d = new Ic();
        let c = 0, h = 0;
        for (; h < i.length && c < this._lenses.length; ) {
          const u = i[h][0].symbol.range.startLineNumber, p = this._lenses[c].getLineNumber();
          p < u ? (this._lenses[c].dispose(d, l), this._lenses.splice(c, 1)) : p === u ? (this._lenses[c].updateCodeLensSymbols(i[h], d), h++, c++) : (this._lenses.splice(c, 0, new pf(i[h], this._editor, d, l, o.codeLensHeight, () => this._resolveCodeLensesInViewportSoon())), c++, h++);
        }
        for (; c < this._lenses.length; )
          this._lenses[c].dispose(d, l), this._lenses.splice(c, 1);
        for (; h < i.length; )
          this._lenses.push(new pf(i[h], this._editor, d, l, o.codeLensHeight, () => this._resolveCodeLensesInViewportSoon())), h++;
        d.commit(a);
      });
    }), s.restore(this._editor);
  }
  _resolveCodeLensesInViewportSoon() {
    this._editor.getModel() && this._resolveCodeLensesScheduler.schedule();
  }
  _resolveCodeLensesInViewport() {
    var e;
    (e = this._resolveCodeLensesPromise) === null || e === void 0 || e.cancel(), this._resolveCodeLensesPromise = void 0;
    const t = this._editor.getModel();
    if (!t)
      return;
    const i = [], n = [];
    if (this._lenses.forEach((a) => {
      const l = a.computeIfNecessary(t);
      l && (i.push(l), n.push(a));
    }), i.length === 0)
      return;
    const s = Date.now(), o = Pe((a) => {
      const l = i.map((d, c) => {
        const h = new Array(d.length), u = d.map((p, f) => !p.symbol.command && typeof p.provider.resolveCodeLens == "function" ? Promise.resolve(p.provider.resolveCodeLens(t, p.symbol, a)).then((m) => {
          h[f] = m;
        }, Ie) : (h[f] = p.symbol, Promise.resolve(void 0)));
        return Promise.all(u).then(() => {
          !a.isCancellationRequested && !n[c].isDisposed() && n[c].updateCommands(h);
        });
      });
      return Promise.all(l);
    });
    this._resolveCodeLensesPromise = o, this._resolveCodeLensesPromise.then(() => {
      const a = this._resolveCodeLensesDebounce.update(t, Date.now() - s);
      this._resolveCodeLensesScheduler.delay = a, this._currentCodeLensModel && this._codeLensCache.put(t, this._currentCodeLensModel), this._oldCodeLensModels.clear(), o === this._resolveCodeLensesPromise && (this._resolveCodeLensesPromise = void 0);
    }, (a) => {
      re(a), o === this._resolveCodeLensesPromise && (this._resolveCodeLensesPromise = void 0);
    });
  }
  async getModel() {
    var e;
    return await this._getCodeLensModelPromise, await this._resolveCodeLensesPromise, !((e = this._currentCodeLensModel) === null || e === void 0) && e.isDisposed ? void 0 : this._currentCodeLensModel;
  }
};
Ys.ID = "css.editor.codeLens";
Ys = Qx([
  Mo(1, V),
  Mo(2, Pt),
  Mo(3, Fe),
  Mo(4, Je),
  Mo(5, zv)
], Ys);
Z(
  Ys.ID,
  Ys,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
x(class extends D {
  constructor() {
    super({
      id: "codelens.showLensesInCurrentLine",
      precondition: b.hasCodeLensProvider,
      label: g("showLensOnLine", "Show CodeLens Commands For Current Line"),
      alias: "Show CodeLens Commands For Current Line"
    });
  }
  async run(e, t) {
    if (!t.hasModel())
      return;
    const i = e.get(Ei), n = e.get(Fe), s = e.get(Je), o = t.getSelection().positionLineNumber, a = t.getContribution(Ys.ID);
    if (!a)
      return;
    const l = await a.getModel();
    if (!l)
      return;
    const d = [];
    for (const u of l.lenses)
      u.symbol.command && u.symbol.range.startLineNumber === o && d.push({
        label: u.symbol.command.title,
        command: u.symbol.command
      });
    if (d.length === 0)
      return;
    const c = await i.pick(d, {
      canPickMany: !1,
      placeHolder: g("placeHolder", "Select a command")
    });
    if (!c)
      return;
    let h = c.command;
    if (l.isDisposed) {
      const u = await a.getModel(), p = u == null ? void 0 : u.lenses.find((f) => {
        var m;
        return f.symbol.range.startLineNumber === o && ((m = f.symbol.command) === null || m === void 0 ? void 0 : m.title) === h.title;
      });
      if (!p || !p.symbol.command)
        return;
      h = p.symbol.command;
    }
    try {
      await n.executeCommand(h.id, ...h.arguments || []);
    } catch (u) {
      s.error(u);
    }
  }
});
var Yx = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Dc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class Ag {
  constructor(e, t) {
    this._editorWorkerClient = new pS(e, !1, "editorWorkerService", t);
  }
  async provideDocumentColors(e, t) {
    return this._editorWorkerClient.computeDefaultDocumentColors(e.uri);
  }
  provideColorPresentations(e, t, i) {
    const n = t.range, s = t.color, o = s.alpha, a = new K(new js(Math.round(255 * s.red), Math.round(255 * s.green), Math.round(255 * s.blue), o)), l = o ? K.Format.CSS.formatRGB(a) : K.Format.CSS.formatRGBA(a), d = o ? K.Format.CSS.formatHSL(a) : K.Format.CSS.formatHSLA(a), c = o ? K.Format.CSS.formatHex(a) : K.Format.CSS.formatHexA(a), h = [];
    return h.push({ label: l, textEdit: { range: n, text: l } }), h.push({ label: d, textEdit: { range: n, text: d } }), h.push({ label: c, textEdit: { range: n, text: c } }), h;
  }
}
let vh = class extends P {
  constructor(e, t, i) {
    super(), this._register(i.colorProvider.register("*", new Ag(e, t)));
  }
};
vh = Yx([
  Dc(0, Ge),
  Dc(1, fe),
  Dc(2, V)
], vh);
Jr(vh);
async function $v(r, e, t, i = !0) {
  return Og(new Jx(), r, e, t, i);
}
function jv(r, e, t, i) {
  return Promise.resolve(t.provideColorPresentations(r, e, i));
}
class Jx {
  constructor() {
  }
  async compute(e, t, i, n) {
    const s = await e.provideDocumentColors(t, i);
    if (Array.isArray(s))
      for (const o of s)
        n.push({ colorInfo: o, provider: e });
    return Array.isArray(s);
  }
}
class eL {
  constructor() {
  }
  async compute(e, t, i, n) {
    const s = await e.provideDocumentColors(t, i);
    if (Array.isArray(s))
      for (const o of s)
        n.push({ range: o.range, color: [o.color.red, o.color.green, o.color.blue, o.color.alpha] });
    return Array.isArray(s);
  }
}
class tL {
  constructor(e) {
    this.colorInfo = e;
  }
  async compute(e, t, i, n) {
    const s = await e.provideColorPresentations(t, this.colorInfo, X.None);
    return Array.isArray(s) && n.push(...s), Array.isArray(s);
  }
}
async function Og(r, e, t, i, n) {
  let s = !1, o;
  const a = [], l = e.ordered(t);
  for (let d = l.length - 1; d >= 0; d--) {
    const c = l[d];
    if (c instanceof Ag)
      o = c;
    else
      try {
        await r.compute(c, t, i, a) && (s = !0);
      } catch (h) {
        Ie(h);
      }
  }
  return s ? a : o && n ? (await r.compute(o, t, i, a), a) : [];
}
function qv(r, e) {
  const { colorProvider: t } = r.get(V), i = r.get(Ge).getModel(e);
  if (!i)
    throw wi();
  const n = r.get(he).getValue("editor.defaultColorDecorators", { resource: e });
  return { model: i, colorProviderRegistry: t, isDefaultColorDecoratorsEnabled: n };
}
de.registerCommand("_executeDocumentColorProvider", function(r, ...e) {
  const [t] = e;
  if (!(t instanceof ce))
    throw wi();
  const { model: i, colorProviderRegistry: n, isDefaultColorDecoratorsEnabled: s } = qv(r, t);
  return Og(new eL(), n, i, X.None, s);
});
de.registerCommand("_executeColorPresentationProvider", function(r, ...e) {
  const [t, i] = e, { uri: n, range: s } = i;
  if (!(n instanceof ce) || !Array.isArray(t) || t.length !== 4 || !S.isIRange(s))
    throw wi();
  const { model: o, colorProviderRegistry: a, isDefaultColorDecoratorsEnabled: l } = qv(r, n), [d, c, h, u] = t;
  return Og(new tL({ range: s, color: { red: d, green: c, blue: h, alpha: u } }), a, o, X.None, l);
});
var iL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, kc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, bh;
const Kv = /* @__PURE__ */ Object.create({});
let rn = bh = class extends P {
  constructor(e, t, i, n) {
    super(), this._editor = e, this._configurationService = t, this._languageFeaturesService = i, this._localToDispose = this._register(new M()), this._decorationsIds = [], this._colorDatas = /* @__PURE__ */ new Map(), this._colorDecoratorIds = this._editor.createDecorationsCollection(), this._ruleFactory = new Um(this._editor), this._decoratorLimitReporter = new nL(), this._colorDecorationClassRefs = this._register(new M()), this._debounceInformation = n.for(i.colorProvider, "Document Colors", { min: bh.RECOMPUTE_TIME }), this._register(e.onDidChangeModel(() => {
      this._isColorDecoratorsEnabled = this.isEnabled(), this.updateColors();
    })), this._register(e.onDidChangeModelLanguage(() => this.updateColors())), this._register(i.colorProvider.onDidChange(() => this.updateColors())), this._register(e.onDidChangeConfiguration((s) => {
      const o = this._isColorDecoratorsEnabled;
      this._isColorDecoratorsEnabled = this.isEnabled(), this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
        146
        /* EditorOption.defaultColorDecorators */
      );
      const a = o !== this._isColorDecoratorsEnabled || s.hasChanged(
        21
        /* EditorOption.colorDecoratorsLimit */
      ), l = s.hasChanged(
        146
        /* EditorOption.defaultColorDecorators */
      );
      (a || l) && (this._isColorDecoratorsEnabled ? this.updateColors() : this.removeAllDecorations());
    })), this._timeoutTimer = null, this._computePromise = null, this._isColorDecoratorsEnabled = this.isEnabled(), this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
      146
      /* EditorOption.defaultColorDecorators */
    ), this.updateColors();
  }
  isEnabled() {
    const e = this._editor.getModel();
    if (!e)
      return !1;
    const t = e.getLanguageId(), i = this._configurationService.getValue(t);
    if (i && typeof i == "object") {
      const n = i.colorDecorators;
      if (n && n.enable !== void 0 && !n.enable)
        return n.enable;
    }
    return this._editor.getOption(
      20
      /* EditorOption.colorDecorators */
    );
  }
  static get(e) {
    return e.getContribution(this.ID);
  }
  dispose() {
    this.stop(), this.removeAllDecorations(), super.dispose();
  }
  updateColors() {
    if (this.stop(), !this._isColorDecoratorsEnabled)
      return;
    const e = this._editor.getModel();
    !e || !this._languageFeaturesService.colorProvider.has(e) || (this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      this._timeoutTimer || (this._timeoutTimer = new Xr(), this._timeoutTimer.cancelAndSet(() => {
        this._timeoutTimer = null, this.beginCompute();
      }, this._debounceInformation.get(e)));
    })), this.beginCompute());
  }
  async beginCompute() {
    this._computePromise = Pe(async (e) => {
      const t = this._editor.getModel();
      if (!t)
        return [];
      const i = new Rt(!1), n = await $v(this._languageFeaturesService.colorProvider, t, e, this._isDefaultColorDecoratorsEnabled);
      return this._debounceInformation.update(t, i.elapsed()), n;
    });
    try {
      const e = await this._computePromise;
      this.updateDecorations(e), this.updateColorDecorators(e), this._computePromise = null;
    } catch (e) {
      re(e);
    }
  }
  stop() {
    this._timeoutTimer && (this._timeoutTimer.cancel(), this._timeoutTimer = null), this._computePromise && (this._computePromise.cancel(), this._computePromise = null), this._localToDispose.clear();
  }
  updateDecorations(e) {
    const t = e.map((i) => ({
      range: {
        startLineNumber: i.colorInfo.range.startLineNumber,
        startColumn: i.colorInfo.range.startColumn,
        endLineNumber: i.colorInfo.range.endLineNumber,
        endColumn: i.colorInfo.range.endColumn
      },
      options: Y.EMPTY
    }));
    this._editor.changeDecorations((i) => {
      this._decorationsIds = i.deltaDecorations(this._decorationsIds, t), this._colorDatas = /* @__PURE__ */ new Map(), this._decorationsIds.forEach((n, s) => this._colorDatas.set(n, e[s]));
    });
  }
  updateColorDecorators(e) {
    this._colorDecorationClassRefs.clear();
    const t = [], i = this._editor.getOption(
      21
      /* EditorOption.colorDecoratorsLimit */
    );
    for (let s = 0; s < e.length && t.length < i; s++) {
      const { red: o, green: a, blue: l, alpha: d } = e[s].colorInfo.color, c = new js(Math.round(o * 255), Math.round(a * 255), Math.round(l * 255), d), h = `rgba(${c.r}, ${c.g}, ${c.b}, ${c.a})`, u = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: h
      }));
      t.push({
        range: {
          startLineNumber: e[s].colorInfo.range.startLineNumber,
          startColumn: e[s].colorInfo.range.startColumn,
          endLineNumber: e[s].colorInfo.range.endLineNumber,
          endColumn: e[s].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: Am,
            inlineClassName: `${u.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: !0,
            attachedData: Kv
          }
        }
      });
    }
    const n = i < e.length ? i : !1;
    this._decoratorLimitReporter.update(e.length, n), this._colorDecoratorIds.set(t);
  }
  removeAllDecorations() {
    this._editor.removeDecorations(this._decorationsIds), this._decorationsIds = [], this._colorDecoratorIds.clear(), this._colorDecorationClassRefs.clear();
  }
  getColorData(e) {
    const t = this._editor.getModel();
    if (!t)
      return null;
    const i = t.getDecorationsInRange(S.fromPositions(e, e)).filter((n) => this._colorDatas.has(n.id));
    return i.length === 0 ? null : this._colorDatas.get(i[0].id);
  }
  isColorDecoration(e) {
    return this._colorDecoratorIds.has(e);
  }
};
rn.ID = "editor.contrib.colorDetector";
rn.RECOMPUTE_TIME = 1e3;
rn = bh = iL([
  kc(1, he),
  kc(2, V),
  kc(3, Pt)
], rn);
class nL {
  constructor() {
    this._onDidChange = new G(), this._computed = 0, this._limited = !1;
  }
  update(e, t) {
    (e !== this._computed || t !== this._limited) && (this._computed = e, this._limited = t, this._onDidChange.fire());
  }
}
Z(
  rn.ID,
  rn,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
class sL {
  get color() {
    return this._color;
  }
  set color(e) {
    this._color.equals(e) || (this._color = e, this._onDidChangeColor.fire(e));
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(e) {
    this._colorPresentations = e, this.presentationIndex > e.length - 1 && (this.presentationIndex = 0), this._onDidChangePresentation.fire(this.presentation);
  }
  constructor(e, t, i) {
    this.presentationIndex = i, this._onColorFlushed = new G(), this.onColorFlushed = this._onColorFlushed.event, this._onDidChangeColor = new G(), this.onDidChangeColor = this._onDidChangeColor.event, this._onDidChangePresentation = new G(), this.onDidChangePresentation = this._onDidChangePresentation.event, this.originalColor = e, this._color = e, this._colorPresentations = t;
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length, this.flushColor(), this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(e, t) {
    let i = -1;
    for (let n = 0; n < this.colorPresentations.length; n++)
      if (t.toLowerCase() === this.colorPresentations[n].label) {
        i = n;
        break;
      }
    if (i === -1) {
      const n = t.split("(")[0].toLowerCase();
      for (let s = 0; s < this.colorPresentations.length; s++)
        if (this.colorPresentations[s].label.toLowerCase().startsWith(n)) {
          i = s;
          break;
        }
    }
    i !== -1 && i !== this.presentationIndex && (this.presentationIndex = i, this._onDidChangePresentation.fire(this.presentation));
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
}
const pt = O;
class oL extends P {
  constructor(e, t, i, n = !1) {
    super(), this.model = t, this.showingStandaloneColorPicker = n, this._closeButton = null, this._domNode = pt(".colorpicker-header"), A(e, this._domNode), this._pickedColorNode = A(this._domNode, pt(".picked-color")), A(this._pickedColorNode, pt("span.codicon.codicon-color-mode")), this._pickedColorPresentation = A(this._pickedColorNode, document.createElement("span")), this._pickedColorPresentation.classList.add("picked-color-presentation");
    const s = g("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
    this._pickedColorNode.setAttribute("title", s), this._originalColorNode = A(this._domNode, pt(".original-color")), this._originalColorNode.style.backgroundColor = K.Format.CSS.format(this.model.originalColor) || "", this.backgroundColor = i.getColorTheme().getColor(Sp) || K.white, this._register(i.onDidColorThemeChange((o) => {
      this.backgroundColor = o.getColor(Sp) || K.white;
    })), this._register(le(this._pickedColorNode, Le.CLICK, () => this.model.selectNextColorPresentation())), this._register(le(this._originalColorNode, Le.CLICK, () => {
      this.model.color = this.model.originalColor, this.model.flushColor();
    })), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this._register(t.onDidChangePresentation(this.onDidChangePresentation, this)), this._pickedColorNode.style.backgroundColor = K.Format.CSS.format(t.color) || "", this._pickedColorNode.classList.toggle("light", t.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : t.color.isLighter()), this.onDidChangeColor(this.model.color), this.showingStandaloneColorPicker && (this._domNode.classList.add("standalone-colorpicker"), this._closeButton = this._register(new rL(this._domNode)));
  }
  get closeButton() {
    return this._closeButton;
  }
  get pickedColorNode() {
    return this._pickedColorNode;
  }
  get originalColorNode() {
    return this._originalColorNode;
  }
  onDidChangeColor(e) {
    this._pickedColorNode.style.backgroundColor = K.Format.CSS.format(e) || "", this._pickedColorNode.classList.toggle("light", e.rgba.a < 0.5 ? this.backgroundColor.isLighter() : e.isLighter()), this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this._pickedColorPresentation.textContent = this.model.presentation ? this.model.presentation.label : "";
  }
}
class rL extends P {
  constructor(e) {
    super(), this._onClicked = this._register(new G()), this.onClicked = this._onClicked.event, this._button = document.createElement("div"), this._button.classList.add("close-button"), A(e, this._button);
    const t = document.createElement("div");
    t.classList.add("close-button-inner-div"), A(this._button, t), A(t, pt(".button" + oe.asCSSSelector(Ae("color-picker-close", j.close, g("closeIcon", "Icon to close the color picker"))))).classList.add("close-icon"), this._register(le(this._button, Le.CLICK, () => {
      this._onClicked.fire();
    }));
  }
}
class aL extends P {
  constructor(e, t, i, n = !1) {
    super(), this.model = t, this.pixelRatio = i, this._insertButton = null, this._domNode = pt(".colorpicker-body"), A(e, this._domNode), this._saturationBox = new lL(this._domNode, this.model, this.pixelRatio), this._register(this._saturationBox), this._register(this._saturationBox.onDidChange(this.onDidSaturationValueChange, this)), this._register(this._saturationBox.onColorFlushed(this.flushColor, this)), this._opacityStrip = new dL(this._domNode, this.model, n), this._register(this._opacityStrip), this._register(this._opacityStrip.onDidChange(this.onDidOpacityChange, this)), this._register(this._opacityStrip.onColorFlushed(this.flushColor, this)), this._hueStrip = new cL(this._domNode, this.model, n), this._register(this._hueStrip), this._register(this._hueStrip.onDidChange(this.onDidHueChange, this)), this._register(this._hueStrip.onColorFlushed(this.flushColor, this)), n && (this._insertButton = this._register(new hL(this._domNode)), this._domNode.classList.add("standalone-colorpicker"));
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s: e, v: t }) {
    const i = this.model.color.hsva;
    this.model.color = new K(new ol(i.h, e, t, i.a));
  }
  onDidOpacityChange(e) {
    const t = this.model.color.hsva;
    this.model.color = new K(new ol(t.h, t.s, t.v, e));
  }
  onDidHueChange(e) {
    const t = this.model.color.hsva, i = (1 - e) * 360;
    this.model.color = new K(new ol(i === 360 ? 0 : i, t.s, t.v, t.a));
  }
  get domNode() {
    return this._domNode;
  }
  get saturationBox() {
    return this._saturationBox;
  }
  get enterButton() {
    return this._insertButton;
  }
  layout() {
    this._saturationBox.layout(), this._opacityStrip.layout(), this._hueStrip.layout();
  }
}
class lL extends P {
  constructor(e, t, i) {
    super(), this.model = t, this.pixelRatio = i, this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new G(), this.onColorFlushed = this._onColorFlushed.event, this._domNode = pt(".saturation-wrap"), A(e, this._domNode), this._canvas = document.createElement("canvas"), this._canvas.className = "saturation-box", A(this._domNode, this._canvas), this.selection = pt(".saturation-selection"), A(this._domNode, this.selection), this.layout(), this._register(le(this._domNode, Le.POINTER_DOWN, (n) => this.onPointerDown(n))), this._register(this.model.onDidChangeColor(this.onDidChangeColor, this)), this.monitor = null;
  }
  get domNode() {
    return this._domNode;
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    this.monitor = this._register(new zm());
    const t = mt(this._domNode);
    e.target !== this.selection && this.onDidChangePosition(e.offsetX, e.offsetY), this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (n) => this.onDidChangePosition(n.pageX - t.left, n.pageY - t.top), () => null);
    const i = le(e.target.ownerDocument, Le.POINTER_UP, () => {
      this._onColorFlushed.fire(), i.dispose(), this.monitor && (this.monitor.stopMonitoring(!0), this.monitor = null);
    }, !0);
  }
  onDidChangePosition(e, t) {
    const i = Math.max(0, Math.min(1, e / this.width)), n = Math.max(0, Math.min(1, 1 - t / this.height));
    this.paintSelection(i, n), this._onDidChange.fire({ s: i, v: n });
  }
  layout() {
    this.width = this._domNode.offsetWidth, this.height = this._domNode.offsetHeight, this._canvas.width = this.width * this.pixelRatio, this._canvas.height = this.height * this.pixelRatio, this.paint();
    const e = this.model.color.hsva;
    this.paintSelection(e.s, e.v);
  }
  paint() {
    const e = this.model.color.hsva, t = new K(new ol(e.h, 1, 1, 1)), i = this._canvas.getContext("2d"), n = i.createLinearGradient(0, 0, this._canvas.width, 0);
    n.addColorStop(0, "rgba(255, 255, 255, 1)"), n.addColorStop(0.5, "rgba(255, 255, 255, 0.5)"), n.addColorStop(1, "rgba(255, 255, 255, 0)");
    const s = i.createLinearGradient(0, 0, 0, this._canvas.height);
    s.addColorStop(0, "rgba(0, 0, 0, 0)"), s.addColorStop(1, "rgba(0, 0, 0, 1)"), i.rect(0, 0, this._canvas.width, this._canvas.height), i.fillStyle = K.Format.CSS.format(t), i.fill(), i.fillStyle = n, i.fill(), i.fillStyle = s, i.fill();
  }
  paintSelection(e, t) {
    this.selection.style.left = `${e * this.width}px`, this.selection.style.top = `${this.height - t * this.height}px`;
  }
  onDidChangeColor(e) {
    if (this.monitor && this.monitor.isMonitoring())
      return;
    this.paint();
    const t = e.hsva;
    this.paintSelection(t.s, t.v);
  }
}
class Gv extends P {
  constructor(e, t, i = !1) {
    super(), this.model = t, this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new G(), this.onColorFlushed = this._onColorFlushed.event, i ? (this.domNode = A(e, pt(".standalone-strip")), this.overlay = A(this.domNode, pt(".standalone-overlay"))) : (this.domNode = A(e, pt(".strip")), this.overlay = A(this.domNode, pt(".overlay"))), this.slider = A(this.domNode, pt(".slider")), this.slider.style.top = "0px", this._register(le(this.domNode, Le.POINTER_DOWN, (n) => this.onPointerDown(n))), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const e = this.getValue(this.model.color);
    this.updateSliderPosition(e);
  }
  onDidChangeColor(e) {
    const t = this.getValue(e);
    this.updateSliderPosition(t);
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._register(new zm()), i = mt(this.domNode);
    this.domNode.classList.add("grabbing"), e.target !== this.slider && this.onDidChangeTop(e.offsetY), t.startMonitoring(e.target, e.pointerId, e.buttons, (s) => this.onDidChangeTop(s.pageY - i.top), () => null);
    const n = le(e.target.ownerDocument, Le.POINTER_UP, () => {
      this._onColorFlushed.fire(), n.dispose(), t.stopMonitoring(!0), this.domNode.classList.remove("grabbing");
    }, !0);
  }
  onDidChangeTop(e) {
    const t = Math.max(0, Math.min(1, 1 - e / this.height));
    this.updateSliderPosition(t), this._onDidChange.fire(t);
  }
  updateSliderPosition(e) {
    this.slider.style.top = `${(1 - e) * this.height}px`;
  }
}
class dL extends Gv {
  constructor(e, t, i = !1) {
    super(e, t, i), this.domNode.classList.add("opacity-strip"), this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(e) {
    super.onDidChangeColor(e);
    const { r: t, g: i, b: n } = e.rgba, s = new K(new js(t, i, n, 1)), o = new K(new js(t, i, n, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${s} 0%, ${o} 100%)`;
  }
  getValue(e) {
    return e.hsva.a;
  }
}
class cL extends Gv {
  constructor(e, t, i = !1) {
    super(e, t, i), this.domNode.classList.add("hue-strip");
  }
  getValue(e) {
    return 1 - e.hsva.h / 360;
  }
}
class hL extends P {
  constructor(e) {
    super(), this._onClicked = this._register(new G()), this.onClicked = this._onClicked.event, this._button = A(e, document.createElement("button")), this._button.classList.add("insert-button"), this._button.textContent = "Insert", this._register(le(this._button, Le.CLICK, () => {
      this._onClicked.fire();
    }));
  }
  get button() {
    return this._button;
  }
}
class uL extends ea {
  constructor(e, t, i, n, s = !1) {
    super(), this.model = t, this.pixelRatio = i, this._register(fS.getInstance(En(e)).onDidChange(() => this.layout()));
    const o = pt(".colorpicker-widget");
    e.appendChild(o), this.header = this._register(new oL(o, this.model, n, s)), this.body = this._register(new aL(o, this.model, this.pixelRatio, s));
  }
  layout() {
    this.body.layout();
  }
}
var Zv = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Xv = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class gL {
  constructor(e, t, i, n) {
    this.owner = e, this.range = t, this.model = i, this.provider = n, this.forceShowAtRange = !0;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let Ml = class {
  constructor(e, t) {
    this._editor = e, this._themeService = t, this.hoverOrdinal = 2;
  }
  computeSync(e, t) {
    return [];
  }
  computeAsync(e, t, i) {
    return zt.fromPromise(this._computeAsync(e, t, i));
  }
  async _computeAsync(e, t, i) {
    if (!this._editor.hasModel())
      return [];
    const n = rn.get(this._editor);
    if (!n)
      return [];
    for (const s of t) {
      if (!n.isColorDecoration(s))
        continue;
      const o = n.getColorData(s.range.getStartPosition());
      if (o)
        return [await Qv(this, this._editor.getModel(), o.colorInfo, o.provider)];
    }
    return [];
  }
  renderHoverParts(e, t) {
    return Yv(this, this._editor, this._themeService, t, e);
  }
};
Ml = Zv([
  Xv(1, Mt)
], Ml);
class pL {
  constructor(e, t, i, n) {
    this.owner = e, this.range = t, this.model = i, this.provider = n;
  }
}
let xr = class {
  constructor(e, t) {
    this._editor = e, this._themeService = t, this._color = null;
  }
  async createColorHover(e, t, i) {
    if (!this._editor.hasModel() || !rn.get(this._editor))
      return null;
    const s = await $v(i, this._editor.getModel(), X.None);
    let o = null, a = null;
    for (const h of s) {
      const u = h.colorInfo;
      S.containsRange(u.range, e.range) && (o = u, a = h.provider);
    }
    const l = o ?? e, d = a ?? t, c = !!o;
    return { colorHover: await Qv(this, this._editor.getModel(), l, d), foundInEditor: c };
  }
  async updateEditorModel(e) {
    if (!this._editor.hasModel())
      return;
    const t = e.model;
    let i = new S(e.range.startLineNumber, e.range.startColumn, e.range.endLineNumber, e.range.endColumn);
    this._color && (await cl(this._editor.getModel(), t, this._color, i, e), i = Jv(this._editor, i, t));
  }
  renderHoverParts(e, t) {
    return Yv(this, this._editor, this._themeService, t, e);
  }
  set color(e) {
    this._color = e;
  }
  get color() {
    return this._color;
  }
};
xr = Zv([
  Xv(1, Mt)
], xr);
async function Qv(r, e, t, i) {
  const n = e.getValueInRange(t.range), { red: s, green: o, blue: a, alpha: l } = t.color, d = new js(Math.round(s * 255), Math.round(o * 255), Math.round(a * 255), l), c = new K(d), h = await jv(e, t, i, X.None), u = new sL(c, [], 0);
  return u.colorPresentations = h || [], u.guessColorPresentation(c, n), r instanceof Ml ? new gL(r, S.lift(t.range), u, i) : new pL(r, S.lift(t.range), u, i);
}
function Yv(r, e, t, i, n) {
  if (i.length === 0 || !e.hasModel())
    return P.None;
  if (n.setMinimumDimensions) {
    const u = e.getOption(
      67
      /* EditorOption.lineHeight */
    ) + 8;
    n.setMinimumDimensions(new ae(302, u));
  }
  const s = new M(), o = i[0], a = e.getModel(), l = o.model, d = s.add(new uL(n.fragment, l, e.getOption(
    142
    /* EditorOption.pixelRatio */
  ), t, r instanceof xr));
  n.setColorPicker(d);
  let c = !1, h = new S(o.range.startLineNumber, o.range.startColumn, o.range.endLineNumber, o.range.endColumn);
  if (r instanceof xr) {
    const u = i[0].model.color;
    r.color = u, cl(a, l, u, h, o), s.add(l.onColorFlushed((p) => {
      r.color = p;
    }));
  } else
    s.add(l.onColorFlushed(async (u) => {
      await cl(a, l, u, h, o), c = !0, h = Jv(e, h, l);
    }));
  return s.add(l.onDidChangeColor((u) => {
    cl(a, l, u, h, o);
  })), s.add(e.onDidChangeModelContent((u) => {
    c ? c = !1 : (n.hide(), e.focus());
  })), s;
}
function Jv(r, e, t) {
  var i, n;
  const s = [], o = (i = t.presentation.textEdit) !== null && i !== void 0 ? i : { range: e, text: t.presentation.label, forceMoveMarkers: !1 };
  s.push(o), t.presentation.additionalTextEdits && s.push(...t.presentation.additionalTextEdits);
  const a = S.lift(o.range), l = r.getModel()._setTrackedRange(
    null,
    a,
    3
    /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  );
  return r.executeEdits("colorpicker", s), r.pushUndoStop(), (n = r.getModel()._getTrackedRange(l)) !== null && n !== void 0 ? n : a;
}
async function cl(r, e, t, i, n) {
  const s = await jv(r, {
    range: i,
    color: {
      red: t.rgba.r / 255,
      green: t.rgba.g / 255,
      blue: t.rgba.b / 255,
      alpha: t.rgba.a
    }
  }, n.provider, X.None);
  e.colorPresentations = s || [];
}
function Ch(r, e) {
  return !!r[e];
}
class Nc {
  constructor(e, t) {
    this.target = e.target, this.isLeftClick = e.event.leftButton, this.isMiddleClick = e.event.middleButton, this.isRightClick = e.event.rightButton, this.hasTriggerModifier = Ch(e.event, t.triggerModifier), this.hasSideBySideModifier = Ch(e.event, t.triggerSideBySideModifier), this.isNoneOrSingleMouseDown = e.event.detail <= 1;
  }
}
class ff {
  constructor(e, t) {
    this.keyCodeIsTriggerKey = e.keyCode === t.triggerKey, this.keyCodeIsSideBySideKey = e.keyCode === t.triggerSideBySideKey, this.hasTriggerModifier = Ch(e, t.triggerModifier);
  }
}
class Pa {
  constructor(e, t, i, n) {
    this.triggerKey = e, this.triggerModifier = t, this.triggerSideBySideKey = i, this.triggerSideBySideModifier = n;
  }
  equals(e) {
    return this.triggerKey === e.triggerKey && this.triggerModifier === e.triggerModifier && this.triggerSideBySideKey === e.triggerSideBySideKey && this.triggerSideBySideModifier === e.triggerSideBySideModifier;
  }
}
function mf(r) {
  return r === "altKey" ? si ? new Pa(57, "metaKey", 6, "altKey") : new Pa(5, "ctrlKey", 6, "altKey") : si ? new Pa(6, "altKey", 57, "metaKey") : new Pa(6, "altKey", 5, "ctrlKey");
}
class Ld extends P {
  constructor(e, t) {
    var i;
    super(), this._onMouseMoveOrRelevantKeyDown = this._register(new G()), this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event, this._onExecute = this._register(new G()), this.onExecute = this._onExecute.event, this._onCancel = this._register(new G()), this.onCancel = this._onCancel.event, this._editor = e, this._extractLineNumberFromMouseEvent = (i = t == null ? void 0 : t.extractLineNumberFromMouseEvent) !== null && i !== void 0 ? i : (n) => n.target.position ? n.target.position.lineNumber : 0, this._opts = mf(this._editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    )), this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._register(this._editor.onDidChangeConfiguration((n) => {
      if (n.hasChanged(
        78
        /* EditorOption.multiCursorModifier */
      )) {
        const s = mf(this._editor.getOption(
          78
          /* EditorOption.multiCursorModifier */
        ));
        if (this._opts.equals(s))
          return;
        this._opts = s, this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._onCancel.fire();
      }
    })), this._register(this._editor.onMouseMove((n) => this._onEditorMouseMove(new Nc(n, this._opts)))), this._register(this._editor.onMouseDown((n) => this._onEditorMouseDown(new Nc(n, this._opts)))), this._register(this._editor.onMouseUp((n) => this._onEditorMouseUp(new Nc(n, this._opts)))), this._register(this._editor.onKeyDown((n) => this._onEditorKeyDown(new ff(n, this._opts)))), this._register(this._editor.onKeyUp((n) => this._onEditorKeyUp(new ff(n, this._opts)))), this._register(this._editor.onMouseDrag(() => this._resetHandler())), this._register(this._editor.onDidChangeCursorSelection((n) => this._onDidChangeCursorSelection(n))), this._register(this._editor.onDidChangeModel((n) => this._resetHandler())), this._register(this._editor.onDidChangeModelContent(() => this._resetHandler())), this._register(this._editor.onDidScrollChange((n) => {
      (n.scrollTopChanged || n.scrollLeftChanged) && this._resetHandler();
    }));
  }
  _onDidChangeCursorSelection(e) {
    e.selection && e.selection.startColumn !== e.selection.endColumn && this._resetHandler();
  }
  _onEditorMouseMove(e) {
    this._lastMouseMoveEvent = e, this._onMouseMoveOrRelevantKeyDown.fire([e, null]);
  }
  _onEditorMouseDown(e) {
    this._hasTriggerKeyOnMouseDown = e.hasTriggerModifier, this._lineNumberOnMouseDown = this._extractLineNumberFromMouseEvent(e);
  }
  _onEditorMouseUp(e) {
    const t = this._extractLineNumberFromMouseEvent(e);
    this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === t && this._onExecute.fire(e);
  }
  _onEditorKeyDown(e) {
    this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier) ? this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]) : e.hasTriggerModifier && this._onCancel.fire();
  }
  _onEditorKeyUp(e) {
    e.keyCodeIsTriggerKey && this._onCancel.fire();
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._onCancel.fire();
  }
}
var fL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, mi = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let an = class extends mS {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u, p) {
    super(e, { ...n.getRawOptions(), overflowWidgetsDomNode: n.getOverflowWidgetsDomNode() }, i, s, o, a, l, d, c, h, u, p), this._parentEditor = n, this._overwriteOptions = t, super.updateOptions(this._overwriteOptions), this._register(n.onDidChangeConfiguration((f) => this._onParentConfigurationChanged(f)));
  }
  getParentEditor() {
    return this._parentEditor;
  }
  _onParentConfigurationChanged(e) {
    super.updateOptions(this._parentEditor.getRawOptions()), super.updateOptions(this._overwriteOptions);
  }
  updateOptions(e) {
    rg(this._overwriteOptions, e, !0), super.updateOptions(this._overwriteOptions);
  }
};
an = fL([
  mi(4, q),
  mi(5, _e),
  mi(6, Fe),
  mi(7, ee),
  mi(8, Mt),
  mi(9, Je),
  mi(10, og),
  mi(11, fe),
  mi(12, V)
], an);
const _f = new K(new js(0, 122, 204)), mL = {
  showArrow: !0,
  showFrame: !0,
  className: "",
  frameColor: _f,
  arrowColor: _f,
  keepEditorSelection: !1
}, _L = "vs.editor.contrib.zoneWidget";
class vL {
  constructor(e, t, i, n, s, o, a, l) {
    this.id = "", this.domNode = e, this.afterLineNumber = t, this.afterColumn = i, this.heightInLines = n, this.showInHiddenAreas = a, this.ordinal = l, this._onDomNodeTop = s, this._onComputedHeight = o;
  }
  onDomNodeTop(e) {
    this._onDomNodeTop(e);
  }
  onComputedHeight(e) {
    this._onComputedHeight(e);
  }
}
class bL {
  constructor(e, t) {
    this._id = e, this._domNode = t;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return null;
  }
}
class Id {
  constructor(e) {
    this._editor = e, this._ruleName = Id._IdGenerator.nextId(), this._decorations = this._editor.createDecorationsCollection(), this._color = null, this._height = -1;
  }
  dispose() {
    this.hide(), wp(this._ruleName);
  }
  set color(e) {
    this._color !== e && (this._color = e, this._updateStyle());
  }
  set height(e) {
    this._height !== e && (this._height = e, this._updateStyle());
  }
  _updateStyle() {
    wp(this._ruleName), vS(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);
  }
  show(e) {
    e.column === 1 && (e = { lineNumber: e.lineNumber, column: 2 }), this._decorations.set([{
      range: S.fromPositions(e),
      options: {
        description: "zone-widget-arrow",
        className: this._ruleName,
        stickiness: 1
        /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
      }
    }]);
  }
  hide() {
    this._decorations.clear();
  }
}
Id._IdGenerator = new bS(".arrow-decoration-");
class CL {
  constructor(e, t = {}) {
    this._arrow = null, this._overlayWidget = null, this._resizeSash = null, this._viewZone = null, this._disposables = new M(), this.container = null, this._isShowing = !1, this.editor = e, this._positionMarkerId = this.editor.createDecorationsCollection(), this.options = _S(t), rg(this.options, mL, !1), this.domNode = document.createElement("div"), this.options.isAccessible || (this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setAttribute("role", "presentation")), this._disposables.add(this.editor.onDidLayoutChange((i) => {
      const n = this._getWidth(i);
      this.domNode.style.width = n + "px", this.domNode.style.left = this._getLeft(i) + "px", this._onWidth(n);
    }));
  }
  dispose() {
    this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this._viewZone && this.editor.changeViewZones((e) => {
      this._viewZone && e.removeZone(this._viewZone.id), this._viewZone = null;
    }), this._positionMarkerId.clear(), this._disposables.dispose();
  }
  create() {
    this.domNode.classList.add("zone-widget"), this.options.className && this.domNode.classList.add(this.options.className), this.container = document.createElement("div"), this.container.classList.add("zone-widget-container"), this.domNode.appendChild(this.container), this.options.showArrow && (this._arrow = new Id(this.editor), this._disposables.add(this._arrow)), this._fillContainer(this.container), this._initSash(), this._applyStyles();
  }
  style(e) {
    e.frameColor && (this.options.frameColor = e.frameColor), e.arrowColor && (this.options.arrowColor = e.arrowColor), this._applyStyles();
  }
  _applyStyles() {
    if (this.container && this.options.frameColor) {
      const e = this.options.frameColor.toString();
      this.container.style.borderTopColor = e, this.container.style.borderBottomColor = e;
    }
    if (this._arrow && this.options.arrowColor) {
      const e = this.options.arrowColor.toString();
      this._arrow.color = e;
    }
  }
  _getWidth(e) {
    return e.width - e.minimap.minimapWidth - e.verticalScrollbarWidth;
  }
  _getLeft(e) {
    return e.minimap.minimapWidth > 0 && e.minimap.minimapLeft === 0 ? e.minimap.minimapWidth : 0;
  }
  _onViewZoneTop(e) {
    this.domNode.style.top = e + "px";
  }
  _onViewZoneHeight(e) {
    var t;
    if (this.domNode.style.height = `${e}px`, this.container) {
      const i = e - this._decoratingElementsHeight();
      this.container.style.height = `${i}px`;
      const n = this.editor.getLayoutInfo();
      this._doLayout(i, this._getWidth(n));
    }
    (t = this._resizeSash) === null || t === void 0 || t.layout();
  }
  get position() {
    const e = this._positionMarkerId.getRange(0);
    if (e)
      return e.getStartPosition();
  }
  show(e, t) {
    const i = S.isIRange(e) ? S.lift(e) : S.fromPositions(e);
    this._isShowing = !0, this._showImpl(i, t), this._isShowing = !1, this._positionMarkerId.set([{ range: i, options: Y.EMPTY }]);
  }
  hide() {
    var e;
    this._viewZone && (this.editor.changeViewZones((t) => {
      this._viewZone && t.removeZone(this._viewZone.id);
    }), this._viewZone = null), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), (e = this._arrow) === null || e === void 0 || e.hide(), this._positionMarkerId.clear();
  }
  _decoratingElementsHeight() {
    const e = this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    let t = 0;
    if (this.options.showArrow) {
      const i = Math.round(e / 3);
      t += 2 * i;
    }
    if (this.options.showFrame) {
      const i = Math.round(e / 9);
      t += 2 * i;
    }
    return t;
  }
  _showImpl(e, t) {
    const i = e.getStartPosition(), n = this.editor.getLayoutInfo(), s = this._getWidth(n);
    this.domNode.style.width = `${s}px`, this.domNode.style.left = this._getLeft(n) + "px";
    const o = document.createElement("div");
    o.style.overflow = "hidden";
    const a = this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    if (!this.options.allowUnlimitedHeight) {
      const u = Math.max(12, this.editor.getLayoutInfo().height / a * 0.8);
      t = Math.min(t, u);
    }
    let l = 0, d = 0;
    if (this._arrow && this.options.showArrow && (l = Math.round(a / 3), this._arrow.height = l, this._arrow.show(i)), this.options.showFrame && (d = Math.round(a / 9)), this.editor.changeViewZones((u) => {
      this._viewZone && u.removeZone(this._viewZone.id), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this.domNode.style.top = "-1000px", this._viewZone = new vL(o, i.lineNumber, i.column, t, (p) => this._onViewZoneTop(p), (p) => this._onViewZoneHeight(p), this.options.showInHiddenAreas, this.options.ordinal), this._viewZone.id = u.addZone(this._viewZone), this._overlayWidget = new bL(_L + this._viewZone.id, this.domNode), this.editor.addOverlayWidget(this._overlayWidget);
    }), this.container && this.options.showFrame) {
      const u = this.options.frameWidth ? this.options.frameWidth : d;
      this.container.style.borderTopWidth = u + "px", this.container.style.borderBottomWidth = u + "px";
    }
    const c = t * a - this._decoratingElementsHeight();
    this.container && (this.container.style.top = l + "px", this.container.style.height = c + "px", this.container.style.overflow = "hidden"), this._doLayout(c, s), this.options.keepEditorSelection || this.editor.setSelection(e);
    const h = this.editor.getModel();
    if (h) {
      const u = h.validateRange(new S(e.startLineNumber, 1, e.endLineNumber + 1, 1));
      this.revealRange(u, u.startLineNumber === h.getLineCount());
    }
  }
  revealRange(e, t) {
    t ? this.editor.revealLineNearTop(
      e.endLineNumber,
      0
      /* ScrollType.Smooth */
    ) : this.editor.revealRange(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  setCssClass(e, t) {
    this.container && (t && this.container.classList.remove(t), this.container.classList.add(e));
  }
  _onWidth(e) {
  }
  _doLayout(e, t) {
  }
  _relayout(e) {
    this._viewZone && this._viewZone.heightInLines !== e && this.editor.changeViewZones((t) => {
      this._viewZone && (this._viewZone.heightInLines = e, t.layoutZone(this._viewZone.id));
    });
  }
  // --- sash
  _initSash() {
    if (this._resizeSash)
      return;
    this._resizeSash = this._disposables.add(new Ds(this.domNode, this, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    })), this.options.isResizeable || (this._resizeSash.state = 0);
    let e;
    this._disposables.add(this._resizeSash.onDidStart((t) => {
      this._viewZone && (e = {
        startY: t.startY,
        heightInLines: this._viewZone.heightInLines
      });
    })), this._disposables.add(this._resizeSash.onDidEnd(() => {
      e = void 0;
    })), this._disposables.add(this._resizeSash.onDidChange((t) => {
      if (e) {
        const i = (t.currentY - e.startY) / this.editor.getOption(
          67
          /* EditorOption.lineHeight */
        ), n = i < 0 ? Math.ceil(i) : Math.floor(i), s = e.heightInLines + n;
        s > 5 && s < 35 && this._relayout(s);
      }
    }));
  }
  getHorizontalSashLeft() {
    return 0;
  }
  getHorizontalSashTop() {
    return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
  }
  getHorizontalSashWidth() {
    const e = this.editor.getLayoutInfo();
    return e.width - e.minimap.minimapWidth;
  }
}
var eb = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, tb = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const ib = Ti("IPeekViewService");
Ai(
  ib,
  class {
    constructor() {
      this._widgets = /* @__PURE__ */ new Map();
    }
    addExclusiveWidget(r, e) {
      const t = this._widgets.get(r);
      t && (t.listener.dispose(), t.widget.dispose());
      const i = () => {
        const n = this._widgets.get(r);
        n && n.widget === e && (n.listener.dispose(), this._widgets.delete(r));
      };
      this._widgets.set(r, { widget: e, listener: e.onDidClose(i) });
    }
  },
  1
  /* InstantiationType.Delayed */
);
var Qe;
(function(r) {
  r.inPeekEditor = new Q("inReferenceSearchEditor", !0, g("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek")), r.notInPeekEditor = r.inPeekEditor.toNegated();
})(Qe || (Qe = {}));
let Lr = class {
  constructor(e, t) {
    e instanceof an && Qe.inPeekEditor.bindTo(t);
  }
  dispose() {
  }
};
Lr.ID = "editor.contrib.referenceController";
Lr = eb([
  tb(1, ee)
], Lr);
Z(
  Lr.ID,
  Lr,
  0
  /* EditorContributionInstantiation.Eager */
);
function SL(r) {
  const e = r.get(_e).getFocusedCodeEditor();
  return e instanceof an ? e.getParentEditor() : e;
}
const wL = {
  headerBackgroundColor: K.white,
  primaryHeadingColor: K.fromHex("#333333"),
  secondaryHeadingColor: K.fromHex("#6c6c6cb3")
};
let El = class extends CL {
  constructor(e, t, i) {
    super(e, t), this.instantiationService = i, this._onDidClose = new G(), this.onDidClose = this._onDidClose.event, rg(this.options, wL, !1);
  }
  dispose() {
    this.disposed || (this.disposed = !0, super.dispose(), this._onDidClose.fire(this));
  }
  style(e) {
    const t = this.options;
    e.headerBackgroundColor && (t.headerBackgroundColor = e.headerBackgroundColor), e.primaryHeadingColor && (t.primaryHeadingColor = e.primaryHeadingColor), e.secondaryHeadingColor && (t.secondaryHeadingColor = e.secondaryHeadingColor), super.style(e);
  }
  _applyStyles() {
    super._applyStyles();
    const e = this.options;
    this._headElement && e.headerBackgroundColor && (this._headElement.style.backgroundColor = e.headerBackgroundColor.toString()), this._primaryHeading && e.primaryHeadingColor && (this._primaryHeading.style.color = e.primaryHeadingColor.toString()), this._secondaryHeading && e.secondaryHeadingColor && (this._secondaryHeading.style.color = e.secondaryHeadingColor.toString()), this._bodyElement && e.frameColor && (this._bodyElement.style.borderColor = e.frameColor.toString());
  }
  _fillContainer(e) {
    this.setCssClass("peekview-widget"), this._headElement = O(".head"), this._bodyElement = O(".body"), this._fillHead(this._headElement), this._fillBody(this._bodyElement), e.appendChild(this._headElement), e.appendChild(this._bodyElement);
  }
  _fillHead(e, t) {
    this._titleElement = O(".peekview-title"), this.options.supportOnTitleClick && (this._titleElement.classList.add("clickable"), Bn(this._titleElement, "click", (s) => this._onTitleClick(s))), A(this._headElement, this._titleElement), this._fillTitleIcon(this._titleElement), this._primaryHeading = O("span.filename"), this._secondaryHeading = O("span.dirname"), this._metaHeading = O("span.meta"), A(this._titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
    const i = O(".peekview-actions");
    A(this._headElement, i);
    const n = this._getActionBarOptions();
    this._actionbarWidget = new ur(i, n), this._disposables.add(this._actionbarWidget), t || this._actionbarWidget.push(new qs("peekview.close", g("label.close", "Close"), oe.asClassName(j.close), !0, () => (this.dispose(), Promise.resolve())), { label: !1, icon: !0 });
  }
  _fillTitleIcon(e) {
  }
  _getActionBarOptions() {
    return {
      actionViewItemProvider: CS.bind(void 0, this.instantiationService),
      orientation: 0
      /* ActionsOrientation.HORIZONTAL */
    };
  }
  _onTitleClick(e) {
  }
  setTitle(e, t) {
    this._primaryHeading && this._secondaryHeading && (this._primaryHeading.innerText = e, this._primaryHeading.setAttribute("title", e), t ? this._secondaryHeading.innerText = t : Qi(this._secondaryHeading));
  }
  setMetaTitle(e) {
    this._metaHeading && (e ? (this._metaHeading.innerText = e, Dt(this._metaHeading)) : ut(this._metaHeading));
  }
  _doLayout(e, t) {
    if (!this._isShowing && e < 0) {
      this.dispose();
      return;
    }
    const i = Math.ceil(this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    ) * 1.2), n = Math.round(e - (i + 2));
    this._doLayoutHead(i, t), this._doLayoutBody(n, t);
  }
  _doLayoutHead(e, t) {
    this._headElement && (this._headElement.style.height = `${e}px`, this._headElement.style.lineHeight = this._headElement.style.height);
  }
  _doLayoutBody(e, t) {
    this._bodyElement && (this._bodyElement.style.height = `${e}px`);
  }
};
El = eb([
  tb(2, q)
], El);
const yL = W("peekViewTitle.background", { dark: "#252526", light: "#F3F3F3", hcDark: K.black, hcLight: K.white }, g("peekViewTitleBackground", "Background color of the peek view title area.")), nb = W("peekViewTitleLabel.foreground", { dark: K.white, light: K.black, hcDark: K.white, hcLight: $i }, g("peekViewTitleForeground", "Color of the peek view title.")), sb = W("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161", hcDark: "#FFFFFF99", hcLight: "#292929" }, g("peekViewTitleInfoForeground", "Color of the peek view title info.")), xL = W("peekView.border", { dark: th, light: th, hcDark: Di, hcLight: Di }, g("peekViewBorder", "Color of the peek view borders and arrow.")), LL = W("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hcDark: K.black, hcLight: K.white }, g("peekViewResultsBackground", "Background color of the peek view result list."));
W("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hcDark: K.white, hcLight: $i }, g("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
W("peekViewResult.fileForeground", { dark: K.white, light: "#1E1E1E", hcDark: K.white, hcLight: $i }, g("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
W("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hcDark: null, hcLight: null }, g("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
W("peekViewResult.selectionForeground", { dark: K.white, light: "#6C6C6C", hcDark: K.white, hcLight: $i }, g("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
const qi = W("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hcDark: K.black, hcLight: K.white }, g("peekViewEditorBackground", "Background color of the peek view editor."));
W("peekViewEditorGutter.background", { dark: qi, light: qi, hcDark: qi, hcLight: qi }, g("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
W("peekViewEditorStickyScroll.background", { dark: qi, light: qi, hcDark: qi, hcLight: qi }, g("peekViewEditorStickScrollBackground", "Background color of sticky scroll in the peek view editor."));
W("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hcDark: null, hcLight: null }, g("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
W("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hcDark: null, hcLight: null }, g("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
W("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hcDark: Hn, hcLight: Hn }, g("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));
class ln {
  constructor(e, t, i, n) {
    this.isProviderFirst = e, this.parent = t, this.link = i, this._rangeCallback = n, this.id = SS.nextId();
  }
  get uri() {
    return this.link.uri;
  }
  get range() {
    var e, t;
    return (t = (e = this._range) !== null && e !== void 0 ? e : this.link.targetSelectionRange) !== null && t !== void 0 ? t : this.link.range;
  }
  set range(e) {
    this._range = e, this._rangeCallback(this);
  }
  get ariaMessage() {
    var e;
    const t = (e = this.parent.getPreview(this)) === null || e === void 0 ? void 0 : e.preview(this.range);
    return t ? g({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "{0} in {1} on line {2} at column {3}", t.value, oi(this.uri), this.range.startLineNumber, this.range.startColumn) : g("aria.oneReference", "in {0} on line {1} at column {2}", oi(this.uri), this.range.startLineNumber, this.range.startColumn);
  }
}
class IL {
  constructor(e) {
    this._modelReference = e;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(e, t = 8) {
    const i = this._modelReference.object.textEditorModel;
    if (!i)
      return;
    const { startLineNumber: n, startColumn: s, endLineNumber: o, endColumn: a } = e, l = i.getWordUntilPosition({ lineNumber: n, column: s - t }), d = new S(n, l.startColumn, n, s), c = new S(
      o,
      a,
      o,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ), h = i.getValueInRange(d).replace(/^\s+/, ""), u = i.getValueInRange(e), p = i.getValueInRange(c).replace(/\s+$/, "");
    return {
      value: h + u + p,
      highlight: { start: h.length, end: h.length + u.length }
    };
  }
}
class Ir {
  constructor(e, t) {
    this.parent = e, this.uri = t, this.children = [], this._previews = new ri();
  }
  dispose() {
    $e(this._previews.values()), this._previews.clear();
  }
  getPreview(e) {
    return this._previews.get(e.uri);
  }
  get ariaMessage() {
    const e = this.children.length;
    return e === 1 ? g("aria.fileReferences.1", "1 symbol in {0}, full path {1}", oi(this.uri), this.uri.fsPath) : g("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", e, oi(this.uri), this.uri.fsPath);
  }
  async resolve(e) {
    if (this._previews.size !== 0)
      return this;
    for (const t of this.children)
      if (!this._previews.has(t.uri))
        try {
          const i = await e.createModelReference(t.uri);
          this._previews.set(t.uri, new IL(i));
        } catch (i) {
          re(i);
        }
    return this;
  }
}
class st {
  constructor(e, t) {
    this.groups = [], this.references = [], this._onDidChangeReferenceRange = new G(), this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event, this._links = e, this._title = t;
    const [i] = e;
    e.sort(st._compareReferences);
    let n;
    for (const s of e)
      if ((!n || !yp.isEqual(n.uri, s.uri, !0)) && (n = new Ir(this, s.uri), this.groups.push(n)), n.children.length === 0 || st._compareReferences(s, n.children[n.children.length - 1]) !== 0) {
        const o = new ln(i === s, n, s, (a) => this._onDidChangeReferenceRange.fire(a));
        this.references.push(o), n.children.push(o);
      }
  }
  dispose() {
    $e(this.groups), this._onDidChangeReferenceRange.dispose(), this.groups.length = 0;
  }
  clone() {
    return new st(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    return this.isEmpty ? g("aria.result.0", "No results found") : this.references.length === 1 ? g("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath) : this.groups.length === 1 ? g("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath) : g("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
  }
  nextOrPreviousReference(e, t) {
    const { parent: i } = e;
    let n = i.children.indexOf(e);
    const s = i.children.length, o = i.parent.groups.length;
    return o === 1 || t && n + 1 < s || !t && n > 0 ? (t ? n = (n + 1) % s : n = (n + s - 1) % s, i.children[n]) : (n = i.parent.groups.indexOf(i), t ? (n = (n + 1) % o, i.parent.groups[n].children[0]) : (n = (n + o - 1) % o, i.parent.groups[n].children[i.parent.groups[n].children.length - 1]));
  }
  nearestReference(e, t) {
    const i = this.references.map((n, s) => ({
      idx: s,
      prefixLen: ta(n.uri.toString(), e.toString()),
      offsetDist: Math.abs(n.range.startLineNumber - t.lineNumber) * 100 + Math.abs(n.range.startColumn - t.column)
    })).sort((n, s) => n.prefixLen > s.prefixLen ? -1 : n.prefixLen < s.prefixLen ? 1 : n.offsetDist < s.offsetDist ? -1 : n.offsetDist > s.offsetDist ? 1 : 0)[0];
    if (i)
      return this.references[i.idx];
  }
  referenceAt(e, t) {
    for (const i of this.references)
      if (i.uri.toString() === e.toString() && S.containsPosition(i.range, t))
        return i;
  }
  firstReference() {
    for (const e of this.references)
      if (e.isProviderFirst)
        return e;
    return this.references[0];
  }
  static _compareReferences(e, t) {
    return yp.compare(e.uri, t.uri) || S.compareRangesUsingStarts(e.range, t.range);
  }
}
var Dd = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, kd = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Sh;
let wh = class {
  constructor(e) {
    this._resolverService = e;
  }
  hasChildren(e) {
    return e instanceof st || e instanceof Ir;
  }
  getChildren(e) {
    if (e instanceof st)
      return e.groups;
    if (e instanceof Ir)
      return e.resolve(this._resolverService).then((t) => t.children);
    throw new Error("bad tree");
  }
};
wh = Dd([
  kd(0, Zt)
], wh);
class DL {
  getHeight() {
    return 23;
  }
  getTemplateId(e) {
    return e instanceof Ir ? Dr.id : ha.id;
  }
}
let yh = class {
  constructor(e) {
    this._keybindingService = e;
  }
  getKeyboardNavigationLabel(e) {
    var t;
    if (e instanceof ln) {
      const i = (t = e.parent.getPreview(e)) === null || t === void 0 ? void 0 : t.preview(e.range);
      if (i)
        return i.value;
    }
    return oi(e.uri);
  }
};
yh = Dd([
  kd(0, xe)
], yh);
class kL {
  getId(e) {
    return e instanceof ln ? e.id : e.uri;
  }
}
let xh = class extends P {
  constructor(e, t) {
    super(), this._labelService = t;
    const i = document.createElement("div");
    i.classList.add("reference-file"), this.file = this._register(new $m(i, { supportHighlights: !0 })), this.badge = new wS(A(i, O(".count")), {}, yS), e.appendChild(i);
  }
  set(e, t) {
    const i = ag(e.uri);
    this.file.setLabel(this._labelService.getUriBasenameLabel(e.uri), this._labelService.getUriLabel(i, { relative: !0 }), { title: this._labelService.getUriLabel(e.uri), matches: t });
    const n = e.children.length;
    this.badge.setCount(n), n > 1 ? this.badge.setTitleFormat(g("referencesCount", "{0} references", n)) : this.badge.setTitleFormat(g("referenceCount", "{0} reference", n));
  }
};
xh = Dd([
  kd(1, fr)
], xh);
let Dr = Sh = class {
  constructor(e) {
    this._instantiationService = e, this.templateId = Sh.id;
  }
  renderTemplate(e) {
    return this._instantiationService.createInstance(xh, e);
  }
  renderElement(e, t, i) {
    i.set(e.element, ad(e.filterData));
  }
  disposeTemplate(e) {
    e.dispose();
  }
};
Dr.id = "FileReferencesRenderer";
Dr = Sh = Dd([
  kd(0, q)
], Dr);
class NL {
  constructor(e) {
    this.label = new xS(e);
  }
  set(e, t) {
    var i;
    const n = (i = e.parent.getPreview(e)) === null || i === void 0 ? void 0 : i.preview(e.range);
    if (!n || !n.value)
      this.label.set(`${oi(e.uri)}:${e.range.startLineNumber + 1}:${e.range.startColumn + 1}`);
    else {
      const { value: s, highlight: o } = n;
      t && !mr.isDefault(t) ? (this.label.element.classList.toggle("referenceMatch", !1), this.label.set(s, ad(t))) : (this.label.element.classList.toggle("referenceMatch", !0), this.label.set(s, [o]));
    }
  }
}
class ha {
  constructor() {
    this.templateId = ha.id;
  }
  renderTemplate(e) {
    return new NL(e);
  }
  renderElement(e, t, i) {
    i.set(e.element, e.filterData);
  }
  disposeTemplate() {
  }
}
ha.id = "OneReferenceRenderer";
class RL {
  getWidgetAriaLabel() {
    return g("treeAriaLabel", "References");
  }
  getAriaLabel(e) {
    return e.ariaMessage;
  }
}
var PL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, _i = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class Nd {
  constructor(e, t) {
    this._editor = e, this._model = t, this._decorations = /* @__PURE__ */ new Map(), this._decorationIgnoreSet = /* @__PURE__ */ new Set(), this._callOnDispose = new M(), this._callOnModelChange = new M(), this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged())), this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose(), this._callOnDispose.dispose(), this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const e = this._editor.getModel();
    if (e) {
      for (const t of this._model.references)
        if (t.uri.toString() === e.uri.toString()) {
          this._addDecorations(t.parent);
          return;
        }
    }
  }
  _addDecorations(e) {
    if (!this._editor.hasModel())
      return;
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const t = [], i = [];
    for (let n = 0, s = e.children.length; n < s; n++) {
      const o = e.children[n];
      this._decorationIgnoreSet.has(o.id) || o.uri.toString() === this._editor.getModel().uri.toString() && (t.push({
        range: o.range,
        options: Nd.DecorationOptions
      }), i.push(n));
    }
    this._editor.changeDecorations((n) => {
      const s = n.deltaDecorations([], t);
      for (let o = 0; o < s.length; o++)
        this._decorations.set(s[o], e.children[i[o]]);
    });
  }
  _onDecorationChanged() {
    const e = [], t = this._editor.getModel();
    if (t) {
      for (const [i, n] of this._decorations) {
        const s = t.getDecorationRange(i);
        if (!s)
          continue;
        let o = !1;
        if (!S.equalsRange(s, n.range)) {
          if (S.spansMultipleLines(s))
            o = !0;
          else {
            const a = n.range.endColumn - n.range.startColumn, l = s.endColumn - s.startColumn;
            a !== l && (o = !0);
          }
          o ? (this._decorationIgnoreSet.add(n.id), e.push(i)) : n.range = s;
        }
      }
      for (let i = 0, n = e.length; i < n; i++)
        this._decorations.delete(e[i]);
      this._editor.removeDecorations(e);
    }
  }
  removeDecorations() {
    this._editor.removeDecorations([...this._decorations.keys()]), this._decorations.clear();
  }
}
Nd.DecorationOptions = Y.register({
  description: "reference-decoration",
  stickiness: 1,
  className: "reference-decoration"
});
class ML {
  constructor() {
    this.ratio = 0.7, this.heightInLines = 18;
  }
  static fromJSON(e) {
    let t, i;
    try {
      const n = JSON.parse(e);
      t = n.ratio, i = n.heightInLines;
    } catch {
    }
    return {
      ratio: t || 0.7,
      heightInLines: i || 18
    };
  }
}
class EL extends kS {
}
let Lh = class extends El {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u) {
    super(e, { showFrame: !1, showArrow: !0, isResizeable: !0, isAccessible: !0, supportOnTitleClick: !0 }, o), this._defaultTreeKeyboardSupport = t, this.layoutData = i, this._textModelResolverService = s, this._instantiationService = o, this._peekViewService = a, this._uriLabel = l, this._undoRedoService = d, this._keybindingService = c, this._languageService = h, this._languageConfigurationService = u, this._disposeOnNewModel = new M(), this._callOnDispose = new M(), this._onDidSelectReference = new G(), this.onDidSelectReference = this._onDidSelectReference.event, this._dim = new ae(0, 0), this._applyTheme(n.getColorTheme()), this._callOnDispose.add(n.onDidColorThemeChange(this._applyTheme.bind(this))), this._peekViewService.addExclusiveWidget(e, this), this.create();
  }
  dispose() {
    this.setModel(void 0), this._callOnDispose.dispose(), this._disposeOnNewModel.dispose(), $e(this._preview), $e(this._previewNotAvailableMessage), $e(this._tree), $e(this._previewModelReference), this._splitView.dispose(), super.dispose();
  }
  _applyTheme(e) {
    const t = e.getColor(xL) || K.transparent;
    this.style({
      arrowColor: t,
      frameColor: t,
      headerBackgroundColor: e.getColor(yL) || K.transparent,
      primaryHeadingColor: e.getColor(nb),
      secondaryHeadingColor: e.getColor(sb)
    });
  }
  show(e) {
    super.show(e, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    this._preview && this._preview.getModel() && this._onDidSelectReference.fire({
      element: this._getFocusedReference(),
      kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
      source: "title"
    });
  }
  _fillBody(e) {
    this.setCssClass("reference-zone-widget"), this._messageContainer = A(e, O("div.messages")), ut(this._messageContainer), this._splitView = new IS(e, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    }), this._previewContainer = A(e, O("div.preview.inline"));
    const t = {
      scrollBeyondLastLine: !1,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        alwaysConsumeMouseWheel: !0
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: !0,
      minimap: {
        enabled: !1
      }
    };
    this._preview = this._instantiationService.createInstance(an, this._previewContainer, t, {}, this.editor), ut(this._previewContainer), this._previewNotAvailableMessage = new xp(g("missingPreviewMessage", "no preview available"), jm, xp.DEFAULT_CREATION_OPTIONS, null, this._undoRedoService, this._languageService, this._languageConfigurationService), this._treeContainer = A(e, O("div.ref-tree.inline"));
    const i = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new RL(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(yh),
      identityProvider: new kL(),
      openOnSingleClick: !0,
      selectionNavigation: !0,
      overrideStyles: {
        listBackground: LL
      }
    };
    this._defaultTreeKeyboardSupport && this._callOnDispose.add(Bn(this._treeContainer, "keydown", (s) => {
      s.equals(
        9
        /* KeyCode.Escape */
      ) && (this._keybindingService.dispatchEvent(s, s.target), s.stopPropagation());
    }, !0)), this._tree = this._instantiationService.createInstance(EL, "ReferencesWidget", this._treeContainer, new DL(), [
      this._instantiationService.createInstance(Dr),
      this._instantiationService.createInstance(ha)
    ], this._instantiationService.createInstance(wh), i), this._splitView.addView({
      onDidChange: De.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (s) => {
        this._preview.layout({ height: this._dim.height, width: s });
      }
    }, Lp.Distribute), this._splitView.addView({
      onDidChange: De.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (s) => {
        this._treeContainer.style.height = `${this._dim.height}px`, this._treeContainer.style.width = `${s}px`, this._tree.layout(this._dim.height, s);
      }
    }, Lp.Distribute), this._disposables.add(this._splitView.onDidSashChange(() => {
      this._dim.width && (this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width);
    }, void 0));
    const n = (s, o) => {
      s instanceof ln && (o === "show" && this._revealReference(s, !1), this._onDidSelectReference.fire({ element: s, kind: o, source: "tree" }));
    };
    this._tree.onDidOpen((s) => {
      s.sideBySide ? n(s.element, "side") : s.editorOptions.pinned ? n(s.element, "goto") : n(s.element, "show");
    }), ut(this._treeContainer);
  }
  _onWidth(e) {
    this._dim && this._doLayoutBody(this._dim.height, e);
  }
  _doLayoutBody(e, t) {
    super._doLayoutBody(e, t), this._dim = new ae(t, e), this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines, this._splitView.layout(t), this._splitView.resizeView(0, t * this.layoutData.ratio);
  }
  setSelection(e) {
    return this._revealReference(e, !0).then(() => {
      this._model && (this._tree.setSelection([e]), this._tree.setFocus([e]));
    });
  }
  setModel(e) {
    return this._disposeOnNewModel.clear(), this._model = e, this._model ? this._onNewModel() : Promise.resolve();
  }
  _onNewModel() {
    return this._model ? this._model.isEmpty ? (this.setTitle(""), this._messageContainer.innerText = g("noResults", "No results"), Dt(this._messageContainer), Promise.resolve(void 0)) : (ut(this._messageContainer), this._decorationsManager = new Nd(this._preview, this._model), this._disposeOnNewModel.add(this._decorationsManager), this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((e) => this._tree.rerender(e))), this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const { event: t, target: i } = e;
      if (t.detail !== 2)
        return;
      const n = this._getFocusedReference();
      n && this._onDidSelectReference.fire({
        element: { uri: n.uri, range: i.range },
        kind: t.ctrlKey || t.metaKey || t.altKey ? "side" : "open",
        source: "editor"
      });
    })), this.container.classList.add("results-loaded"), Dt(this._treeContainer), Dt(this._previewContainer), this._splitView.layout(this._dim.width), this.focusOnReferenceTree(), this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model)) : Promise.resolve(void 0);
  }
  _getFocusedReference() {
    const [e] = this._tree.getFocus();
    if (e instanceof ln)
      return e;
    if (e instanceof Ir && e.children.length > 0)
      return e.children[0];
  }
  async revealReference(e) {
    await this._revealReference(e, !1), this._onDidSelectReference.fire({ element: e, kind: "goto", source: "tree" });
  }
  async _revealReference(e, t) {
    if (this._revealedReference === e)
      return;
    this._revealedReference = e, e.uri.scheme !== wt.inMemory ? this.setTitle(DS(e.uri), this._uriLabel.getUriLabel(ag(e.uri))) : this.setTitle(g("peekView.alternateTitle", "References"));
    const i = this._textModelResolverService.createModelReference(e.uri);
    this._tree.getInput() === e.parent ? this._tree.reveal(e) : (t && this._tree.reveal(e.parent), await this._tree.expand(e.parent), this._tree.reveal(e));
    const n = await i;
    if (!this._model) {
      n.dispose();
      return;
    }
    $e(this._previewModelReference);
    const s = n.object;
    if (s) {
      const o = this._preview.getModel() === s.textEditorModel ? 0 : 1, a = S.lift(e.range).collapseToStart();
      this._previewModelReference = n, this._preview.setModel(s.textEditorModel), this._preview.setSelection(a), this._preview.revealRangeInCenter(a, o);
    } else
      this._preview.setModel(this._previewNotAvailableMessage), n.dispose();
  }
};
Lh = PL([
  _i(3, Mt),
  _i(4, Zt),
  _i(5, q),
  _i(6, ib),
  _i(7, fr),
  _i(8, LS),
  _i(9, xe),
  _i(10, Et),
  _i(11, fe)
], Lh);
var TL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, us = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, hl;
const as = new Q("referenceSearchVisible", !1, g("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
let dn = hl = class {
  static get(e) {
    return e.getContribution(hl.ID);
  }
  constructor(e, t, i, n, s, o, a, l) {
    this._defaultTreeKeyboardSupport = e, this._editor = t, this._editorService = n, this._notificationService = s, this._instantiationService = o, this._storageService = a, this._configurationService = l, this._disposables = new M(), this._requestIdPool = 0, this._ignoreModelChangeEvent = !1, this._referenceSearchVisible = as.bindTo(i);
  }
  dispose() {
    var e, t;
    this._referenceSearchVisible.reset(), this._disposables.dispose(), (e = this._widget) === null || e === void 0 || e.dispose(), (t = this._model) === null || t === void 0 || t.dispose(), this._widget = void 0, this._model = void 0;
  }
  toggleWidget(e, t, i) {
    let n;
    if (this._widget && (n = this._widget.position), this.closeWidget(), n && e.containsPosition(n))
      return;
    this._peekMode = i, this._referenceSearchVisible.set(!0), this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    })), this._disposables.add(this._editor.onDidChangeModel(() => {
      this._ignoreModelChangeEvent || this.closeWidget();
    }));
    const s = "peekViewLayout", o = ML.fromJSON(this._storageService.get(s, 0, "{}"));
    this._widget = this._instantiationService.createInstance(Lh, this._editor, this._defaultTreeKeyboardSupport, o), this._widget.setTitle(g("labelLoading", "Loading...")), this._widget.show(e), this._disposables.add(this._widget.onDidClose(() => {
      t.cancel(), this._widget && (this._storageService.store(
        s,
        JSON.stringify(this._widget.layoutData),
        0,
        1
        /* StorageTarget.MACHINE */
      ), this._widget = void 0), this.closeWidget();
    })), this._disposables.add(this._widget.onDidSelectReference((l) => {
      const { element: d, kind: c } = l;
      if (d)
        switch (c) {
          case "open":
            (l.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) && this.openReference(d, !1, !1);
            break;
          case "side":
            this.openReference(d, !0, !1);
            break;
          case "goto":
            i ? this._gotoReference(d, !0) : this.openReference(d, !1, !0);
            break;
        }
    }));
    const a = ++this._requestIdPool;
    t.then((l) => {
      var d;
      if (a !== this._requestIdPool || !this._widget) {
        l.dispose();
        return;
      }
      return (d = this._model) === null || d === void 0 || d.dispose(), this._model = l, this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          this._model.isEmpty ? this._widget.setMetaTitle("") : this._widget.setMetaTitle(g("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
          const c = this._editor.getModel().uri, h = new F(e.startLineNumber, e.startColumn), u = this._model.nearestReference(c, h);
          if (u)
            return this._widget.setSelection(u).then(() => {
              this._widget && this._editor.getOption(
                87
                /* EditorOption.peekWidgetDefaultFocus */
              ) === "editor" && this._widget.focusOnPreviewEditor();
            });
        }
      });
    }, (l) => {
      this._notificationService.error(l);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    this._widget && (this._widget.isPreviewEditorFocused() ? this._widget.focusOnReferenceTree() : this._widget.focusOnPreviewEditor());
  }
  async goToNextOrPreviousReference(e) {
    if (!this._editor.hasModel() || !this._model || !this._widget)
      return;
    const t = this._widget.position;
    if (!t)
      return;
    const i = this._model.nearestReference(this._editor.getModel().uri, t);
    if (!i)
      return;
    const n = this._model.nextOrPreviousReference(i, e), s = this._editor.hasTextFocus(), o = this._widget.isPreviewEditorFocused();
    await this._widget.setSelection(n), await this._gotoReference(n, !1), s ? this._editor.focus() : this._widget && o && this._widget.focusOnPreviewEditor();
  }
  async revealReference(e) {
    !this._editor.hasModel() || !this._model || !this._widget || await this._widget.revealReference(e);
  }
  closeWidget(e = !0) {
    var t, i;
    (t = this._widget) === null || t === void 0 || t.dispose(), (i = this._model) === null || i === void 0 || i.dispose(), this._referenceSearchVisible.reset(), this._disposables.clear(), this._widget = void 0, this._model = void 0, e && this._editor.focus(), this._requestIdPool += 1;
  }
  _gotoReference(e, t) {
    var i;
    (i = this._widget) === null || i === void 0 || i.hide(), this._ignoreModelChangeEvent = !0;
    const n = S.lift(e.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: e.uri,
      options: { selection: n, selectionSource: "code.jump", pinned: t }
    }, this._editor).then((s) => {
      var o;
      if (this._ignoreModelChangeEvent = !1, !s || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === s)
        this._widget.show(n), this._widget.focusOnReferenceTree();
      else {
        const a = hl.get(s), l = this._model.clone();
        this.closeWidget(), s.focus(), a == null || a.toggleWidget(n, Pe((d) => Promise.resolve(l)), (o = this._peekMode) !== null && o !== void 0 ? o : !1);
      }
    }, (s) => {
      this._ignoreModelChangeEvent = !1, re(s);
    });
  }
  openReference(e, t, i) {
    t || this.closeWidget();
    const { uri: n, range: s } = e;
    this._editorService.openCodeEditor({
      resource: n,
      options: { selection: s, selectionSource: "code.jump", pinned: i }
    }, this._editor, t);
  }
};
dn.ID = "editor.contrib.referencesController";
dn = hl = TL([
  us(2, ee),
  us(3, _e),
  us(4, Je),
  us(5, q),
  us(6, vn),
  us(7, he)
], dn);
function ls(r, e) {
  const t = SL(r);
  if (!t)
    return;
  const i = dn.get(t);
  i && e(i);
}
gi.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: ye(
    2089,
    60
    /* KeyCode.F2 */
  ),
  when: L.or(as, Qe.inPeekEditor),
  handler(r) {
    ls(r, (e) => {
      e.changeFocusBetweenPreviewAndReferences();
    });
  }
});
gi.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 90,
  primary: 62,
  secondary: [
    70
    /* KeyCode.F12 */
  ],
  when: L.or(as, Qe.inPeekEditor),
  handler(r) {
    ls(r, (e) => {
      e.goToNextOrPreviousReference(!0);
    });
  }
});
gi.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 90,
  primary: 1086,
  secondary: [
    1094
    /* KeyCode.F12 */
  ],
  when: L.or(as, Qe.inPeekEditor),
  handler(r) {
    ls(r, (e) => {
      e.goToNextOrPreviousReference(!1);
    });
  }
});
de.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
de.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
de.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
de.registerCommand("closeReferenceSearch", (r) => ls(r, (e) => e.closeWidget()));
gi.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: -1,
  primary: 9,
  secondary: [
    1033
    /* KeyCode.Escape */
  ],
  when: L.and(Qe.inPeekEditor, L.not("config.editor.stablePeek"))
});
gi.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 250,
  primary: 9,
  secondary: [
    1033
    /* KeyCode.Escape */
  ],
  when: L.and(as, L.not("config.editor.stablePeek"), L.or(b.editorTextFocus, NS.negate()))
});
gi.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [
      2066
      /* KeyCode.DownArrow */
    ]
  },
  when: L.and(as, qm, Km.negate(), Gm.negate()),
  handler(r) {
    var e;
    const i = (e = r.get(lg).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
    Array.isArray(i) && i[0] instanceof ln && ls(r, (n) => n.revealReference(i[0]));
  }
});
gi.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2051,
  mac: {
    primary: 259
    /* KeyCode.Enter */
  },
  when: L.and(as, qm, Km.negate(), Gm.negate()),
  handler(r) {
    var e;
    const i = (e = r.get(lg).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
    Array.isArray(i) && i[0] instanceof ln && ls(r, (n) => n.openReference(i[0], !0, !0));
  }
});
de.registerCommand("openReference", (r) => {
  var e;
  const i = (e = r.get(lg).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
  Array.isArray(i) && i[0] instanceof ln && ls(r, (n) => n.openReference(i[0], !1, !0));
});
var ob = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, jo = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Fg = new Q("hasSymbols", !1, g("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only.")), Rd = Ti("ISymbolNavigationService");
let Ih = class {
  constructor(e, t, i, n) {
    this._editorService = t, this._notificationService = i, this._keybindingService = n, this._currentModel = void 0, this._currentIdx = -1, this._ignoreEditorChange = !1, this._ctxHasSymbols = Fg.bindTo(e);
  }
  reset() {
    var e, t;
    this._ctxHasSymbols.reset(), (e = this._currentState) === null || e === void 0 || e.dispose(), (t = this._currentMessage) === null || t === void 0 || t.dispose(), this._currentModel = void 0, this._currentIdx = -1;
  }
  put(e) {
    const t = e.parent.parent;
    if (t.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = t, this._currentIdx = t.references.indexOf(e), this._ctxHasSymbols.set(!0), this._showMessage();
    const i = new Dh(this._editorService), n = i.onDidChange((s) => {
      if (this._ignoreEditorChange)
        return;
      const o = this._editorService.getActiveCodeEditor();
      if (!o)
        return;
      const a = o.getModel(), l = o.getPosition();
      if (!a || !l)
        return;
      let d = !1, c = !1;
      for (const h of t.references)
        if (Hm(h.uri, a.uri))
          d = !0, c = c || S.containsPosition(h.range, l);
        else if (d)
          break;
      (!d || !c) && this.reset();
    });
    this._currentState = Zm(i, n);
  }
  revealNext(e) {
    if (!this._currentModel)
      return Promise.resolve();
    this._currentIdx += 1, this._currentIdx %= this._currentModel.references.length;
    const t = this._currentModel.references[this._currentIdx];
    return this._showMessage(), this._ignoreEditorChange = !0, this._editorService.openCodeEditor({
      resource: t.uri,
      options: {
        selection: S.collapseToStart(t.range),
        selectionRevealType: 3
        /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */
      }
    }, e).finally(() => {
      this._ignoreEditorChange = !1;
    });
  }
  _showMessage() {
    var e;
    (e = this._currentMessage) === null || e === void 0 || e.dispose();
    const t = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult"), i = t ? g("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, t.getLabel()) : g("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(i);
  }
};
Ih = ob([
  jo(0, ee),
  jo(1, _e),
  jo(2, Je),
  jo(3, xe)
], Ih);
Ai(
  Rd,
  Ih,
  1
  /* InstantiationType.Delayed */
);
B(new class extends bt {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: Fg,
      kbOpts: {
        weight: 100,
        primary: 70
        /* KeyCode.F12 */
      }
    });
  }
  runEditorCommand(r, e) {
    return r.get(Rd).revealNext(e);
  }
}());
gi.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: Fg,
  primary: 9,
  handler(r) {
    r.get(Rd).reset();
  }
});
let Dh = class {
  constructor(e) {
    this._listener = /* @__PURE__ */ new Map(), this._disposables = new M(), this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this._disposables.add(e.onCodeEditorRemove(this._onDidRemoveEditor, this)), this._disposables.add(e.onCodeEditorAdd(this._onDidAddEditor, this)), e.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose(), $e(this._listener.values());
  }
  _onDidAddEditor(e) {
    this._listener.set(e, Zm(e.onDidChangeCursorPosition((t) => this._onDidChange.fire({ editor: e })), e.onDidChangeModelContent((t) => this._onDidChange.fire({ editor: e }))));
  }
  _onDidRemoveEditor(e) {
    var t;
    (t = this._listener.get(e)) === null || t === void 0 || t.dispose(), this._listener.delete(e);
  }
};
Dh = ob([
  jo(0, _e)
], Dh);
async function ua(r, e, t, i) {
  const s = t.ordered(r).map((a) => Promise.resolve(i(a, r, e)).then(void 0, (l) => {
    Ie(l);
  })), o = await Promise.all(s);
  return Ii(o.flat());
}
function Pd(r, e, t, i) {
  return ua(e, t, r, (n, s, o) => n.provideDefinition(s, o, i));
}
function rb(r, e, t, i) {
  return ua(e, t, r, (n, s, o) => n.provideDeclaration(s, o, i));
}
function ab(r, e, t, i) {
  return ua(e, t, r, (n, s, o) => n.provideImplementation(s, o, i));
}
function lb(r, e, t, i) {
  return ua(e, t, r, (n, s, o) => n.provideTypeDefinition(s, o, i));
}
function Md(r, e, t, i, n) {
  return ua(e, t, r, async (s, o, a) => {
    const l = await s.provideReferences(o, a, { includeDeclaration: !0 }, n);
    if (!i || !l || l.length !== 2)
      return l;
    const d = await s.provideReferences(o, a, { includeDeclaration: !1 }, n);
    return d && d.length === 1 ? d : l;
  });
}
async function ga(r) {
  const e = await r(), t = new st(e, ""), i = t.references.map((n) => n.link);
  return t.dispose(), i;
}
pi("_executeDefinitionProvider", (r, e, t) => {
  const i = r.get(V), n = Pd(i.definitionProvider, e, t, X.None);
  return ga(() => n);
});
pi("_executeTypeDefinitionProvider", (r, e, t) => {
  const i = r.get(V), n = lb(i.typeDefinitionProvider, e, t, X.None);
  return ga(() => n);
});
pi("_executeDeclarationProvider", (r, e, t) => {
  const i = r.get(V), n = rb(i.declarationProvider, e, t, X.None);
  return ga(() => n);
});
pi("_executeReferenceProvider", (r, e, t) => {
  const i = r.get(V), n = Md(i.referenceProvider, e, t, !1, X.None);
  return ga(() => n);
});
pi("_executeImplementationProvider", (r, e, t) => {
  const i = r.get(V), n = ab(i.implementationProvider, e, t, X.None);
  return ga(() => n);
});
var Eo, To, Ao, Ma, Ea, Ta, Aa, Oa;
qt.appendMenuItem(E.EditorContext, {
  submenu: E.EditorContextPeek,
  title: g("peek.submenu", "Peek"),
  group: "navigation",
  order: 100
});
class Js {
  static is(e) {
    return !e || typeof e != "object" ? !1 : !!(e instanceof Js || F.isIPosition(e.position) && e.model);
  }
  constructor(e, t) {
    this.model = e, this.position = t;
  }
}
class Be extends Kt {
  static all() {
    return Be._allSymbolNavigationCommands.values();
  }
  static _patchConfig(e) {
    const t = { ...e, f1: !0 };
    if (t.menu)
      for (const i of Si.wrap(t.menu))
        (i.id === E.EditorContext || i.id === E.EditorContextPeek) && (i.when = L.and(e.precondition, i.when));
    return t;
  }
  constructor(e, t) {
    super(Be._patchConfig(t)), this.configuration = e, Be._allSymbolNavigationCommands.set(t.id, this);
  }
  runEditorCommand(e, t, i, n) {
    if (!t.hasModel())
      return Promise.resolve(void 0);
    const s = e.get(Je), o = e.get(_e), a = e.get(Qr), l = e.get(Rd), d = e.get(V), c = e.get(q), h = t.getModel(), u = t.getPosition(), p = Js.is(i) ? i : new Js(h, u), f = new Vs(
      t,
      5
      /* CodeEditorStateFlag.Position */
    ), m = Zr(this._getLocationModel(d, p.model, p.position, f.token), f.token).then(async (_) => {
      var v;
      if (!_ || f.token.isCancellationRequested)
        return;
      xt(_.ariaMessage);
      let C;
      if (_.referenceAt(h.uri, u)) {
        const y = this._getAlternativeCommand(t);
        !Be._activeAlternativeCommands.has(y) && Be._allSymbolNavigationCommands.has(y) && (C = Be._allSymbolNavigationCommands.get(y));
      }
      const w = _.references.length;
      if (w === 0) {
        if (!this.configuration.muteMessage) {
          const y = h.getWordAtPosition(u);
          (v = qe.get(t)) === null || v === void 0 || v.showMessage(this._getNoResultFoundMessage(y), u);
        }
      } else if (w === 1 && C)
        Be._activeAlternativeCommands.add(this.desc.id), c.invokeFunction((y) => C.runEditorCommand(y, t, i, n).finally(() => {
          Be._activeAlternativeCommands.delete(this.desc.id);
        }));
      else
        return this._onResult(o, l, t, _, n);
    }, (_) => {
      s.error(_);
    }).finally(() => {
      f.dispose();
    });
    return a.showWhile(m, 250), m;
  }
  async _onResult(e, t, i, n, s) {
    const o = this._getGoToPreference(i);
    if (!(i instanceof an) && (this.configuration.openInPeek || o === "peek" && n.references.length > 1))
      this._openInPeek(i, n, s);
    else {
      const a = n.firstReference(), l = n.references.length > 1 && o === "gotoAndPeek", d = await this._openReference(i, e, a, this.configuration.openToSide, !l);
      l && d ? this._openInPeek(d, n, s) : n.dispose(), o === "goto" && t.put(a);
    }
  }
  async _openReference(e, t, i, n, s) {
    let o;
    if (RS(i) && (o = i.targetSelectionRange), o || (o = i.range), !o)
      return;
    const a = await t.openCodeEditor({
      resource: i.uri,
      options: {
        selection: S.collapseToStart(o),
        selectionRevealType: 3,
        selectionSource: "code.jump"
        /* TextEditorSelectionSource.JUMP */
      }
    }, e, n);
    if (a) {
      if (s) {
        const l = a.getModel(), d = a.createDecorationsCollection([{ range: o, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
        setTimeout(() => {
          a.getModel() === l && d.clear();
        }, 350);
      }
      return a;
    }
  }
  _openInPeek(e, t, i) {
    const n = dn.get(e);
    n && e.hasModel() ? n.toggleWidget(i ?? e.getSelection(), Pe((s) => Promise.resolve(t)), this.configuration.openInPeek) : t.dispose();
  }
}
Be._allSymbolNavigationCommands = /* @__PURE__ */ new Map();
Be._activeAlternativeCommands = /* @__PURE__ */ new Set();
class pa extends Be {
  async _getLocationModel(e, t, i, n) {
    return new st(await Pd(e.definitionProvider, t, i, n), g("def.title", "Definitions"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? g("noResultWord", "No definition found for '{0}'", e.word) : g("generic.noResults", "No definition found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeDefinitionCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleDefinitions;
  }
}
ne((Eo = class extends pa {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Eo.id,
      title: {
        ...$("actions.goToDecl.label", "Go to Definition"),
        mnemonicTitle: g({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
      },
      precondition: b.hasDefinitionProvider,
      keybinding: [{
        when: b.editorTextFocus,
        primary: 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: L.and(b.editorTextFocus, Qm),
        primary: 2118,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }],
      menu: [{
        id: E.EditorContext,
        group: "navigation",
        order: 1.1
      }, {
        id: E.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 2
      }]
    }), de.registerCommandAlias("editor.action.goToDeclaration", Eo.id);
  }
}, Eo.id = "editor.action.revealDefinition", Eo));
ne((To = class extends pa {
  constructor() {
    super({
      openToSide: !0,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: To.id,
      title: $("actions.goToDeclToSide.label", "Open Definition to the Side"),
      precondition: L.and(b.hasDefinitionProvider, b.isInEmbeddedEditor.toNegated()),
      keybinding: [{
        when: b.editorTextFocus,
        primary: ye(
          2089,
          70
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: L.and(b.editorTextFocus, Qm),
        primary: ye(
          2089,
          2118
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    }), de.registerCommandAlias("editor.action.openDeclarationToTheSide", To.id);
  }
}, To.id = "editor.action.revealDefinitionAside", To));
ne((Ao = class extends pa {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: Ao.id,
      title: $("actions.previewDecl.label", "Peek Definition"),
      precondition: L.and(b.hasDefinitionProvider, Qe.notInPeekEditor, b.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: b.editorTextFocus,
        primary: 582,
        linux: {
          primary: 3140
          /* KeyCode.F10 */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: E.EditorContextPeek,
        group: "peek",
        order: 2
      }
    }), de.registerCommandAlias("editor.action.previewDeclaration", Ao.id);
  }
}, Ao.id = "editor.action.peekDefinition", Ao));
class db extends Be {
  async _getLocationModel(e, t, i, n) {
    return new st(await rb(e.declarationProvider, t, i, n), g("decl.title", "Declarations"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? g("decl.noResultWord", "No declaration found for '{0}'", e.word) : g("decl.generic.noResults", "No declaration found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeDeclarationCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleDeclarations;
  }
}
ne((Ma = class extends db {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Ma.id,
      title: {
        ...$("actions.goToDeclaration.label", "Go to Declaration"),
        mnemonicTitle: g({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
      },
      precondition: L.and(b.hasDeclarationProvider, b.isInEmbeddedEditor.toNegated()),
      menu: [{
        id: E.EditorContext,
        group: "navigation",
        order: 1.3
      }, {
        id: E.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? g("decl.noResultWord", "No declaration found for '{0}'", e.word) : g("decl.generic.noResults", "No declaration found");
  }
}, Ma.id = "editor.action.revealDeclaration", Ma));
ne(class extends db {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: "editor.action.peekDeclaration",
      title: $("actions.peekDecl.label", "Peek Declaration"),
      precondition: L.and(b.hasDeclarationProvider, Qe.notInPeekEditor, b.isInEmbeddedEditor.toNegated()),
      menu: {
        id: E.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
});
class cb extends Be {
  async _getLocationModel(e, t, i, n) {
    return new st(await lb(e.typeDefinitionProvider, t, i, n), g("typedef.title", "Type Definitions"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? g("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", e.word) : g("goToTypeDefinition.generic.noResults", "No type definition found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleTypeDefinitions;
  }
}
ne((Ea = class extends cb {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Ea.ID,
      title: {
        ...$("actions.goToTypeDefinition.label", "Go to Type Definition"),
        mnemonicTitle: g({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
      },
      precondition: b.hasTypeDefinitionProvider,
      keybinding: {
        when: b.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: E.EditorContext,
        group: "navigation",
        order: 1.4
      }, {
        id: E.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
}, Ea.ID = "editor.action.goToTypeDefinition", Ea));
ne((Ta = class extends cb {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: Ta.ID,
      title: $("actions.peekTypeDefinition.label", "Peek Type Definition"),
      precondition: L.and(b.hasTypeDefinitionProvider, Qe.notInPeekEditor, b.isInEmbeddedEditor.toNegated()),
      menu: {
        id: E.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, Ta.ID = "editor.action.peekTypeDefinition", Ta));
class hb extends Be {
  async _getLocationModel(e, t, i, n) {
    return new st(await ab(e.implementationProvider, t, i, n), g("impl.title", "Implementations"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? g("goToImplementation.noResultWord", "No implementation found for '{0}'", e.word) : g("goToImplementation.generic.noResults", "No implementation found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeImplementationCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleImplementations;
  }
}
ne((Aa = class extends hb {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Aa.ID,
      title: {
        ...$("actions.goToImplementation.label", "Go to Implementations"),
        mnemonicTitle: g({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
      },
      precondition: b.hasImplementationProvider,
      keybinding: {
        when: b.editorTextFocus,
        primary: 2118,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: E.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: E.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 4
      }]
    });
  }
}, Aa.ID = "editor.action.goToImplementation", Aa));
ne((Oa = class extends hb {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: Oa.ID,
      title: $("actions.peekImplementation.label", "Peek Implementations"),
      precondition: L.and(b.hasImplementationProvider, Qe.notInPeekEditor, b.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: b.editorTextFocus,
        primary: 3142,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: E.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, Oa.ID = "editor.action.peekImplementation", Oa));
class ub extends Be {
  _getNoResultFoundMessage(e) {
    return e ? g("references.no", "No references found for '{0}'", e.word) : g("references.noGeneric", "No references found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeReferenceCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
}
ne(class extends ub {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: "editor.action.goToReferences",
      title: {
        ...$("goToReferences.label", "Go to References"),
        mnemonicTitle: g({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
      },
      precondition: L.and(b.hasReferenceProvider, Qe.notInPeekEditor, b.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: b.editorTextFocus,
        primary: 1094,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: E.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: E.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 5
      }]
    });
  }
  async _getLocationModel(e, t, i, n) {
    return new st(await Md(e.referenceProvider, t, i, !0, n), g("ref.title", "References"));
  }
});
ne(class extends ub {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: "editor.action.referenceSearch.trigger",
      title: $("references.action.label", "Peek References"),
      precondition: L.and(b.hasReferenceProvider, Qe.notInPeekEditor, b.isInEmbeddedEditor.toNegated()),
      menu: {
        id: E.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  async _getLocationModel(e, t, i, n) {
    return new st(await Md(e.referenceProvider, t, i, !1, n), g("ref.title", "References"));
  }
});
class AL extends Be {
  constructor(e, t, i) {
    super(e, {
      id: "editor.action.goToLocation",
      title: $("label.generic", "Go to Any Symbol"),
      precondition: L.and(Qe.notInPeekEditor, b.isInEmbeddedEditor.toNegated())
    }), this._references = t, this._gotoMultipleBehaviour = i;
  }
  async _getLocationModel(e, t, i, n) {
    return new st(this._references, g("generic.title", "Locations"));
  }
  _getNoResultFoundMessage(e) {
    return e && g("generic.noResult", "No results for '{0}'", e.word) || "";
  }
  _getGoToPreference(e) {
    var t;
    return (t = this._gotoMultipleBehaviour) !== null && t !== void 0 ? t : e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
  _getAlternativeCommand() {
    return "";
  }
}
de.registerCommand({
  id: "editor.action.goToLocations",
  metadata: {
    description: "Go to locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: ce },
      { name: "position", description: "The position at which to start", constraint: F.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" },
      { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
    ]
  },
  handler: async (r, e, t, i, n, s, o) => {
    ie(ce.isUri(e)), ie(F.isIPosition(t)), ie(Array.isArray(i)), ie(typeof n > "u" || typeof n == "string"), ie(typeof o > "u" || typeof o == "boolean");
    const a = r.get(_e), l = await a.openCodeEditor({ resource: e }, a.getFocusedCodeEditor());
    if (Xm(l))
      return l.setPosition(t), l.revealPositionInCenterIfOutsideViewport(
        t,
        0
        /* ScrollType.Smooth */
      ), l.invokeWithinContext((d) => {
        const c = new class extends AL {
          _getNoResultFoundMessage(h) {
            return s || super._getNoResultFoundMessage(h);
          }
        }({
          muteMessage: !s,
          openInPeek: !!o,
          openToSide: !1
        }, i, n);
        d.get(q).invokeFunction(c.run.bind(c), l);
      });
  }
});
de.registerCommand({
  id: "editor.action.peekLocations",
  metadata: {
    description: "Peek locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: ce },
      { name: "position", description: "The position at which to start", constraint: F.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" }
    ]
  },
  handler: async (r, e, t, i, n) => {
    r.get(Fe).executeCommand("editor.action.goToLocations", e, t, i, n, void 0, !0);
  }
});
de.registerCommand({
  id: "editor.action.findReferences",
  handler: (r, e, t) => {
    ie(ce.isUri(e)), ie(F.isIPosition(t));
    const i = r.get(V), n = r.get(_e);
    return n.openCodeEditor({ resource: e }, n.getFocusedCodeEditor()).then((s) => {
      if (!Xm(s) || !s.hasModel())
        return;
      const o = dn.get(s);
      if (!o)
        return;
      const a = Pe((d) => Md(i.referenceProvider, s.getModel(), F.lift(t), !1, d).then((c) => new st(c, g("ref.title", "References")))), l = new S(t.lineNumber, t.column, t.lineNumber, t.column);
      return Promise.resolve(o.toggleWidget(l, a, !1));
    });
  }
});
de.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
var OL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Rc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, qo;
let Kn = qo = class {
  constructor(e, t, i, n) {
    this.textModelResolverService = t, this.languageService = i, this.languageFeaturesService = n, this.toUnhook = new M(), this.toUnhookForKeyboard = new M(), this.currentWordAtPosition = null, this.previousPromise = null, this.editor = e, this.linkDecorations = this.editor.createDecorationsCollection();
    const s = new Ld(e);
    this.toUnhook.add(s), this.toUnhook.add(s.onMouseMoveOrRelevantKeyDown(([o, a]) => {
      this.startFindDefinitionFromMouse(o, a ?? void 0);
    })), this.toUnhook.add(s.onExecute((o) => {
      this.isEnabled(o) && this.gotoDefinition(o.target.position, o.hasSideBySideModifier).catch((a) => {
        re(a);
      }).finally(() => {
        this.removeLinkDecorations();
      });
    })), this.toUnhook.add(s.onCancel(() => {
      this.removeLinkDecorations(), this.currentWordAtPosition = null;
    }));
  }
  static get(e) {
    return e.getContribution(qo.ID);
  }
  async startFindDefinitionFromCursor(e) {
    await this.startFindDefinition(e), this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
      this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear();
    })), this.toUnhookForKeyboard.add(this.editor.onKeyDown((t) => {
      t && (this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear());
    }));
  }
  startFindDefinitionFromMouse(e, t) {
    if (e.target.type === 9 && this.linkDecorations.length > 0)
      return;
    if (!this.editor.hasModel() || !this.isEnabled(e, t)) {
      this.currentWordAtPosition = null, this.removeLinkDecorations();
      return;
    }
    const i = e.target.position;
    this.startFindDefinition(i);
  }
  async startFindDefinition(e) {
    var t;
    this.toUnhookForKeyboard.clear();
    const i = e ? (t = this.editor.getModel()) === null || t === void 0 ? void 0 : t.getWordAtPosition(e) : null;
    if (!i) {
      this.currentWordAtPosition = null, this.removeLinkDecorations();
      return;
    }
    if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === i.startColumn && this.currentWordAtPosition.endColumn === i.endColumn && this.currentWordAtPosition.word === i.word)
      return;
    this.currentWordAtPosition = i;
    const n = new Ym(
      this.editor,
      15
      /* CodeEditorStateFlag.Scroll */
    );
    this.previousPromise && (this.previousPromise.cancel(), this.previousPromise = null), this.previousPromise = Pe((a) => this.findDefinition(e, a));
    let s;
    try {
      s = await this.previousPromise;
    } catch (a) {
      re(a);
      return;
    }
    if (!s || !s.length || !n.validate(this.editor)) {
      this.removeLinkDecorations();
      return;
    }
    const o = s[0].originSelectionRange ? S.lift(s[0].originSelectionRange) : new S(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn);
    if (s.length > 1) {
      let a = o;
      for (const { originSelectionRange: l } of s)
        l && (a = S.plusRange(a, l));
      this.addDecoration(a, new Ue().appendText(g("multipleResults", "Click to show {0} definitions.", s.length)));
    } else {
      const a = s[0];
      if (!a.uri)
        return;
      this.textModelResolverService.createModelReference(a.uri).then((l) => {
        if (!l.object || !l.object.textEditorModel) {
          l.dispose();
          return;
        }
        const { object: { textEditorModel: d } } = l, { startLineNumber: c } = a.range;
        if (c < 1 || c > d.getLineCount()) {
          l.dispose();
          return;
        }
        const h = this.getPreviewValue(d, c, a), u = this.languageService.guessLanguageIdByFilepathOrFirstLine(d.uri);
        this.addDecoration(o, h ? new Ue().appendCodeblock(u || "", h) : void 0), l.dispose();
      });
    }
  }
  getPreviewValue(e, t, i) {
    let n = i.range;
    return n.endLineNumber - n.startLineNumber >= qo.MAX_SOURCE_PREVIEW_LINES && (n = this.getPreviewRangeBasedOnIndentation(e, t)), this.stripIndentationFromPreviewRange(e, t, n);
  }
  stripIndentationFromPreviewRange(e, t, i) {
    let s = e.getLineFirstNonWhitespaceColumn(t);
    for (let a = t + 1; a < i.endLineNumber; a++) {
      const l = e.getLineFirstNonWhitespaceColumn(a);
      s = Math.min(s, l);
    }
    return e.getValueInRange(i).replace(new RegExp(`^\\s{${s - 1}}`, "gm"), "").trim();
  }
  getPreviewRangeBasedOnIndentation(e, t) {
    const i = e.getLineFirstNonWhitespaceColumn(t), n = Math.min(e.getLineCount(), t + qo.MAX_SOURCE_PREVIEW_LINES);
    let s = t + 1;
    for (; s < n; s++) {
      const o = e.getLineFirstNonWhitespaceColumn(s);
      if (i === o)
        break;
    }
    return new S(t, 1, s + 1, 1);
  }
  addDecoration(e, t) {
    const i = {
      range: e,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage: t
      }
    };
    this.linkDecorations.set([i]);
  }
  removeLinkDecorations() {
    this.linkDecorations.clear();
  }
  isEnabled(e, t) {
    var i;
    return this.editor.hasModel() && e.isLeftClick && e.isNoneOrSingleMouseDown && e.target.type === 6 && !(((i = e.target.detail.injectedText) === null || i === void 0 ? void 0 : i.options) instanceof dg) && (e.hasTriggerModifier || (t ? t.keyCodeIsTriggerKey : !1)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
  }
  findDefinition(e, t) {
    const i = this.editor.getModel();
    return i ? Pd(this.languageFeaturesService.definitionProvider, i, e, t) : Promise.resolve(null);
  }
  gotoDefinition(e, t) {
    return this.editor.setPosition(e), this.editor.invokeWithinContext((i) => {
      const n = !t && this.editor.getOption(
        88
        /* EditorOption.definitionLinkOpensInPeek */
      ) && !this.isInPeekEditor(i);
      return new pa({ openToSide: t, openInPeek: n, muteMessage: !0 }, { title: { value: "", original: "" }, id: "", precondition: void 0 }).run(i);
    });
  }
  isInPeekEditor(e) {
    const t = e.get(ee);
    return Qe.inPeekEditor.getValue(t);
  }
  dispose() {
    this.toUnhook.dispose(), this.toUnhookForKeyboard.dispose();
  }
};
Kn.ID = "editor.contrib.gotodefinitionatposition";
Kn.MAX_SOURCE_PREVIEW_LINES = 8;
Kn = qo = OL([
  Rc(1, Zt),
  Rc(2, Et),
  Rc(3, V)
], Kn);
Z(
  Kn.ID,
  Kn,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
let FL = class {
  constructor(e, t, i) {
    this.value = e, this.isComplete = t, this.hasLoadingMessage = i;
  }
};
class gb extends P {
  constructor(e, t) {
    super(), this._editor = e, this._computer = t, this._onResult = this._register(new G()), this.onResult = this._onResult.event, this._firstWaitScheduler = this._register(new Re(() => this._triggerAsyncComputation(), 0)), this._secondWaitScheduler = this._register(new Re(() => this._triggerSyncComputation(), 0)), this._loadingMessageScheduler = this._register(new Re(() => this._triggerLoadingMessage(), 0)), this._state = 0, this._asyncIterable = null, this._asyncIterableDone = !1, this._result = [];
  }
  dispose() {
    this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), super.dispose();
  }
  get _hoverTime() {
    return this._editor.getOption(
      60
      /* EditorOption.hover */
    ).delay;
  }
  get _firstWaitTime() {
    return this._hoverTime / 2;
  }
  get _secondWaitTime() {
    return this._hoverTime - this._firstWaitTime;
  }
  get _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _setState(e, t = !0) {
    this._state = e, t && this._fireResult();
  }
  _triggerAsyncComputation() {
    this._setState(
      2
      /* HoverOperationState.SecondWait */
    ), this._secondWaitScheduler.schedule(this._secondWaitTime), this._computer.computeAsync ? (this._asyncIterableDone = !1, this._asyncIterable = PS((e) => this._computer.computeAsync(e)), (async () => {
      try {
        for await (const e of this._asyncIterable)
          e && (this._result.push(e), this._fireResult());
        this._asyncIterableDone = !0, (this._state === 3 || this._state === 4) && this._setState(
          0
          /* HoverOperationState.Idle */
        );
      } catch (e) {
        re(e);
      }
    })()) : this._asyncIterableDone = !0;
  }
  _triggerSyncComputation() {
    this._computer.computeSync && (this._result = this._result.concat(this._computer.computeSync())), this._setState(
      this._asyncIterableDone ? 0 : 3
      /* HoverOperationState.WaitingForAsync */
    );
  }
  _triggerLoadingMessage() {
    this._state === 3 && this._setState(
      4
      /* HoverOperationState.WaitingForAsyncShowingLoading */
    );
  }
  _fireResult() {
    if (this._state === 1 || this._state === 2)
      return;
    const e = this._state === 0, t = this._state === 4;
    this._onResult.fire(new FL(this._result.slice(0), e, t));
  }
  start(e) {
    if (e === 0)
      this._state === 0 && (this._setState(
        1
        /* HoverOperationState.FirstWait */
      ), this._firstWaitScheduler.schedule(this._firstWaitTime), this._loadingMessageScheduler.schedule(this._loadingMessageTime));
    else
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation(), this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
          break;
      }
  }
  cancel() {
    this._firstWaitScheduler.cancel(), this._secondWaitScheduler.cancel(), this._loadingMessageScheduler.cancel(), this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), this._result = [], this._setState(0, !1);
  }
}
class Pc {
  constructor(e, t, i, n) {
    this.priority = e, this.range = t, this.initialMousePosX = i, this.initialMousePosY = n, this.type = 1;
  }
  equals(e) {
    return e.type === 1 && this.range.equalsRange(e.range);
  }
  canAdoptVisibleHover(e, t) {
    return e.type === 1 && t.lineNumber === this.range.startLineNumber;
  }
}
class An {
  constructor(e, t, i, n, s, o) {
    this.priority = e, this.owner = t, this.range = i, this.initialMousePosX = n, this.initialMousePosY = s, this.supportsMarkerHover = o, this.type = 2;
  }
  equals(e) {
    return e.type === 2 && this.owner === e.owner;
  }
  canAdoptVisibleHover(e, t) {
    return e.type === 2 && this.owner === e.owner;
  }
}
const bn = new class {
  constructor() {
    this._participants = [];
  }
  register(e) {
    this._participants.push(e);
  }
  getAll() {
    return this._participants;
  }
}();
class Wg {
  constructor() {
    this._onDidWillResize = new G(), this.onDidWillResize = this._onDidWillResize.event, this._onDidResize = new G(), this.onDidResize = this._onDidResize.event, this._sashListener = new M(), this._size = new ae(0, 0), this._minSize = new ae(0, 0), this._maxSize = new ae(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER), this.domNode = document.createElement("div"), this._eastSash = new Ds(this.domNode, { getVerticalSashLeft: () => this._size.width }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }), this._westSash = new Ds(this.domNode, { getVerticalSashLeft: () => 0 }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }), this._northSash = new Ds(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: Ip.North }), this._southSash = new Ds(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: Ip.South }), this._northSash.orthogonalStartSash = this._westSash, this._northSash.orthogonalEndSash = this._eastSash, this._southSash.orthogonalStartSash = this._westSash, this._southSash.orthogonalEndSash = this._eastSash;
    let e, t = 0, i = 0;
    this._sashListener.add(De.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
      e === void 0 && (this._onDidWillResize.fire(), e = this._size, t = 0, i = 0);
    })), this._sashListener.add(De.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
      e !== void 0 && (e = void 0, t = 0, i = 0, this._onDidResize.fire({ dimension: this._size, done: !0 }));
    })), this._sashListener.add(this._eastSash.onDidChange((n) => {
      e && (i = n.currentX - n.startX, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, east: !0 }));
    })), this._sashListener.add(this._westSash.onDidChange((n) => {
      e && (i = -(n.currentX - n.startX), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, west: !0 }));
    })), this._sashListener.add(this._northSash.onDidChange((n) => {
      e && (t = -(n.currentY - n.startY), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, north: !0 }));
    })), this._sashListener.add(this._southSash.onDidChange((n) => {
      e && (t = n.currentY - n.startY, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, south: !0 }));
    })), this._sashListener.add(De.any(this._eastSash.onDidReset, this._westSash.onDidReset)((n) => {
      this._preferredSize && (this.layout(this._size.height, this._preferredSize.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
    })), this._sashListener.add(De.any(this._northSash.onDidReset, this._southSash.onDidReset)((n) => {
      this._preferredSize && (this.layout(this._preferredSize.height, this._size.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
    }));
  }
  dispose() {
    this._northSash.dispose(), this._southSash.dispose(), this._eastSash.dispose(), this._westSash.dispose(), this._sashListener.dispose(), this._onDidResize.dispose(), this._onDidWillResize.dispose(), this.domNode.remove();
  }
  enableSashes(e, t, i, n) {
    this._northSash.state = e ? 3 : 0, this._eastSash.state = t ? 3 : 0, this._southSash.state = i ? 3 : 0, this._westSash.state = n ? 3 : 0;
  }
  layout(e = this.size.height, t = this.size.width) {
    const { height: i, width: n } = this._minSize, { height: s, width: o } = this._maxSize;
    e = Math.max(i, Math.min(s, e)), t = Math.max(n, Math.min(o, t));
    const a = new ae(t, e);
    ae.equals(a, this._size) || (this.domNode.style.height = e + "px", this.domNode.style.width = t + "px", this._size = a, this._northSash.layout(), this._eastSash.layout(), this._southSash.layout(), this._westSash.layout());
  }
  clearSashHoverState() {
    this._eastSash.clearSashHoverState(), this._westSash.clearSashHoverState(), this._northSash.clearSashHoverState(), this._southSash.clearSashHoverState();
  }
  get size() {
    return this._size;
  }
  set maxSize(e) {
    this._maxSize = e;
  }
  get maxSize() {
    return this._maxSize;
  }
  set minSize(e) {
    this._minSize = e;
  }
  get minSize() {
    return this._minSize;
  }
  set preferredSize(e) {
    this._preferredSize = e;
  }
  get preferredSize() {
    return this._preferredSize;
  }
}
const WL = 30, HL = 24;
class BL extends P {
  constructor(e, t = new ae(10, 10)) {
    super(), this._editor = e, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._resizableNode = this._register(new Wg()), this._contentPosition = null, this._isResizing = !1, this._resizableNode.domNode.style.position = "absolute", this._resizableNode.minSize = ae.lift(t), this._resizableNode.layout(t.height, t.width), this._resizableNode.enableSashes(!0, !0, !0, !0), this._register(this._resizableNode.onDidResize((i) => {
      this._resize(new ae(i.dimension.width, i.dimension.height)), i.done && (this._isResizing = !1);
    })), this._register(this._resizableNode.onDidWillResize(() => {
      this._isResizing = !0;
    }));
  }
  get isResizing() {
    return this._isResizing;
  }
  getDomNode() {
    return this._resizableNode.domNode;
  }
  getPosition() {
    return this._contentPosition;
  }
  get position() {
    var e;
    return !((e = this._contentPosition) === null || e === void 0) && e.position ? F.lift(this._contentPosition.position) : void 0;
  }
  _availableVerticalSpaceAbove(e) {
    const t = this._editor.getDomNode(), i = this._editor.getScrolledVisiblePosition(e);
    return !t || !i ? void 0 : mt(t).top + i.top - WL;
  }
  _availableVerticalSpaceBelow(e) {
    const t = this._editor.getDomNode(), i = this._editor.getScrolledVisiblePosition(e);
    if (!t || !i)
      return;
    const n = mt(t), s = ia(t.ownerDocument.body), o = n.top + i.top + i.height;
    return s.height - o - HL;
  }
  _findPositionPreference(e, t) {
    var i, n;
    const s = Math.min((i = this._availableVerticalSpaceBelow(t)) !== null && i !== void 0 ? i : 1 / 0, e), o = Math.min((n = this._availableVerticalSpaceAbove(t)) !== null && n !== void 0 ? n : 1 / 0, e), a = Math.min(Math.max(o, s), e), l = Math.min(e, a);
    let d;
    return this._editor.getOption(
      60
      /* EditorOption.hover */
    ).above ? d = l <= o ? 1 : 2 : d = l <= s ? 2 : 1, d === 1 ? this._resizableNode.enableSashes(!0, !0, !1, !1) : this._resizableNode.enableSashes(!1, !0, !0, !1), d;
  }
  _resize(e) {
    this._resizableNode.layout(e.height, e.width);
  }
}
var Hg = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Rn = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, ul, Jt;
const vf = O;
let Tl = ul = class extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._instantiationService = t, this._keybindingService = i, this._currentResult = null, this._widget = this._register(this._instantiationService.createInstance(Ji, this._editor)), this._participants = [];
    for (const n of bn.getAll())
      this._participants.push(this._instantiationService.createInstance(n, this._editor));
    this._participants.sort((n, s) => n.hoverOrdinal - s.hoverOrdinal), this._computer = new Ol(this._editor, this._participants), this._hoverOperation = this._register(new gb(this._editor, this._computer)), this._register(this._hoverOperation.onResult((n) => {
      if (!this._computer.anchor)
        return;
      const s = n.hasLoadingMessage ? this._addLoadingMessage(n.value) : n.value;
      this._withResult(new pb(this._computer.anchor, s, n.isComplete));
    })), this._register(Bn(this._widget.getDomNode(), "keydown", (n) => {
      n.equals(
        9
        /* KeyCode.Escape */
      ) && this.hide();
    })), this._register(ld.onDidChange(() => {
      this._widget.position && this._currentResult && this._setCurrentResult(this._currentResult);
    }));
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  _startShowingOrUpdateHover(e, t, i, n, s) {
    return !this._widget.position || !this._currentResult ? e ? (this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : !1 : this._editor.getOption(
      60
      /* EditorOption.hover */
    ).sticky && s && this._widget.isMouseGettingCloser(s.event.posx, s.event.posy) ? (e && this._startHoverOperationIfNecessary(e, t, i, n, !0), !0) : e ? e && this._currentResult.anchor.equals(e) ? !0 : e.canAdoptVisibleHover(this._currentResult.anchor, this._widget.position) ? (this._setCurrentResult(this._currentResult.filter(e)), this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : (this._setCurrentResult(null), this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : (this._setCurrentResult(null), !1);
  }
  _startHoverOperationIfNecessary(e, t, i, n, s) {
    this._computer.anchor && this._computer.anchor.equals(e) || (this._hoverOperation.cancel(), this._computer.anchor = e, this._computer.shouldFocus = n, this._computer.source = i, this._computer.insistOnKeepingHoverVisible = s, this._hoverOperation.start(t));
  }
  _setCurrentResult(e) {
    this._currentResult !== e && (e && e.messages.length === 0 && (e = null), this._currentResult = e, this._currentResult ? this._renderMessages(this._currentResult.anchor, this._currentResult.messages) : this._widget.hide());
  }
  _addLoadingMessage(e) {
    if (this._computer.anchor) {
      for (const t of this._participants)
        if (t.createLoadingMessage) {
          const i = t.createLoadingMessage(this._computer.anchor);
          if (i)
            return e.slice(0).concat([i]);
        }
    }
    return e;
  }
  _withResult(e) {
    this._widget.position && this._currentResult && this._currentResult.isComplete && (!e.isComplete || this._computer.insistOnKeepingHoverVisible && e.messages.length === 0) || this._setCurrentResult(e);
  }
  _renderMessages(e, t) {
    const { showAtPosition: i, showAtSecondaryPosition: n, highlightRange: s } = ul.computeHoverRanges(this._editor, e.range, t), o = new M(), a = o.add(new Al(this._keybindingService)), l = document.createDocumentFragment();
    let d = null;
    const c = {
      fragment: l,
      statusBar: a,
      setColorPicker: (u) => d = u,
      onContentsChanged: () => this._widget.onContentsChanged(),
      setMinimumDimensions: (u) => this._widget.setMinimumDimensions(u),
      hide: () => this.hide()
    };
    for (const u of this._participants) {
      const p = t.filter((f) => f.owner === u);
      p.length > 0 && o.add(u.renderHoverParts(c, p));
    }
    const h = t.some((u) => u.isBeforeContent);
    if (a.hasContent && l.appendChild(a.hoverElement), l.hasChildNodes()) {
      if (s) {
        const u = this._editor.createDecorationsCollection();
        u.set([{
          range: s,
          options: ul._DECORATION_OPTIONS
        }]), o.add(pe(() => {
          u.clear();
        }));
      }
      this._widget.showAt(l, new UL(e.initialMousePosX, e.initialMousePosY, d, i, n, this._editor.getOption(
        60
        /* EditorOption.hover */
      ).above, this._computer.shouldFocus, this._computer.source, h, o));
    } else
      o.dispose();
  }
  static computeHoverRanges(e, t, i) {
    let n = 1;
    if (e.hasModel()) {
      const h = e._getViewModel(), u = h.coordinatesConverter, p = u.convertModelRangeToViewRange(t), f = new F(p.startLineNumber, h.getLineMinColumn(p.startLineNumber));
      n = u.convertViewPositionToModelPosition(f).column;
    }
    const s = t.startLineNumber;
    let o = t.startColumn, a = i[0].range, l = null;
    for (const h of i)
      a = S.plusRange(a, h.range), h.range.startLineNumber === s && h.range.endLineNumber === s && (o = Math.max(Math.min(o, h.range.startColumn), n)), h.forceShowAtRange && (l = h.range);
    const d = l ? l.getStartPosition() : new F(s, t.startColumn), c = l ? l.getStartPosition() : new F(s, o);
    return {
      showAtPosition: d,
      showAtSecondaryPosition: c,
      highlightRange: a
    };
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  showsOrWillShow(e) {
    if (this._widget.isResizing)
      return !0;
    const t = [];
    for (const n of this._participants)
      if (n.suggestHoverAnchor) {
        const s = n.suggestHoverAnchor(e);
        s && t.push(s);
      }
    const i = e.target;
    if (i.type === 6 && t.push(new Pc(0, i.range, e.event.posx, e.event.posy)), i.type === 7) {
      const n = this._editor.getOption(
        50
        /* EditorOption.fontInfo */
      ).typicalHalfwidthCharacterWidth / 2;
      !i.detail.isAfterLines && typeof i.detail.horizontalDistanceToText == "number" && i.detail.horizontalDistanceToText < n && t.push(new Pc(0, i.range, e.event.posx, e.event.posy));
    }
    return t.length === 0 ? this._startShowingOrUpdateHover(null, 0, 0, !1, e) : (t.sort((n, s) => s.priority - n.priority), this._startShowingOrUpdateHover(t[0], 0, 0, !1, e));
  }
  startShowingAtRange(e, t, i, n) {
    this._startShowingOrUpdateHover(new Pc(0, e, void 0, void 0), t, i, n, null);
  }
  containsNode(e) {
    return e ? this._widget.getDomNode().contains(e) : !1;
  }
  focus() {
    this._widget.focus();
  }
  scrollUp() {
    this._widget.scrollUp();
  }
  scrollDown() {
    this._widget.scrollDown();
  }
  scrollLeft() {
    this._widget.scrollLeft();
  }
  scrollRight() {
    this._widget.scrollRight();
  }
  pageUp() {
    this._widget.pageUp();
  }
  pageDown() {
    this._widget.pageDown();
  }
  goToTop() {
    this._widget.goToTop();
  }
  goToBottom() {
    this._widget.goToBottom();
  }
  hide() {
    this._computer.anchor = null, this._hoverOperation.cancel(), this._setCurrentResult(null);
  }
  get isColorPickerVisible() {
    return this._widget.isColorPickerVisible;
  }
  get isVisibleFromKeyboard() {
    return this._widget.isVisibleFromKeyboard;
  }
  get isVisible() {
    return this._widget.isVisible;
  }
  get isFocused() {
    return this._widget.isFocused;
  }
  get isResizing() {
    return this._widget.isResizing;
  }
  get widget() {
    return this._widget;
  }
};
Tl._DECORATION_OPTIONS = Y.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
});
Tl = ul = Hg([
  Rn(1, q),
  Rn(2, xe)
], Tl);
class pb {
  constructor(e, t, i) {
    this.anchor = e, this.messages = t, this.isComplete = i;
  }
  filter(e) {
    const t = this.messages.filter((i) => i.isValidForHoverAnchor(e));
    return t.length === this.messages.length ? this : new VL(this, this.anchor, t, this.isComplete);
  }
}
class VL extends pb {
  constructor(e, t, i, n) {
    super(t, i, n), this.original = e;
  }
  filter(e) {
    return this.original.filter(e);
  }
}
class UL {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    this.initialMousePosX = e, this.initialMousePosY = t, this.colorPicker = i, this.showAtPosition = n, this.showAtSecondaryPosition = s, this.preferAbove = o, this.stoleFocus = a, this.source = l, this.isBeforeContent = d, this.disposables = c, this.closestMouseDistance = void 0;
  }
}
const bf = 30, Mc = 10, zL = 6;
let Ji = Jt = class extends BL {
  get isColorPickerVisible() {
    var e;
    return !!(!((e = this._visibleData) === null || e === void 0) && e.colorPicker);
  }
  get isVisibleFromKeyboard() {
    var e;
    return ((e = this._visibleData) === null || e === void 0 ? void 0 : e.source) === 1;
  }
  get isVisible() {
    var e;
    return (e = this._hoverVisibleKey.get()) !== null && e !== void 0 ? e : !1;
  }
  get isFocused() {
    var e;
    return (e = this._hoverFocusedKey.get()) !== null && e !== void 0 ? e : !1;
  }
  constructor(e, t, i, n, s) {
    const o = e.getOption(
      67
      /* EditorOption.lineHeight */
    ) + 8, a = 150, l = new ae(a, o);
    super(e, l), this._configurationService = i, this._accessibilityService = n, this._keybindingService = s, this._hover = this._register(new Jm()), this._minimumSize = l, this._hoverVisibleKey = b.hoverVisible.bindTo(t), this._hoverFocusedKey = b.hoverFocused.bindTo(t), A(this._resizableNode.domNode, this._hover.containerDomNode), this._resizableNode.domNode.style.zIndex = "50", this._register(this._editor.onDidLayoutChange(() => {
      this.isVisible && this._updateMaxDimensions();
    })), this._register(this._editor.onDidChangeConfiguration((c) => {
      c.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    }));
    const d = this._register(Us(this._resizableNode.domNode));
    this._register(d.onDidFocus(() => {
      this._hoverFocusedKey.set(!0);
    })), this._register(d.onDidBlur(() => {
      this._hoverFocusedKey.set(!1);
    })), this._setHoverData(void 0), this._editor.addContentWidget(this);
  }
  dispose() {
    var e;
    super.dispose(), (e = this._visibleData) === null || e === void 0 || e.disposables.dispose(), this._editor.removeContentWidget(this);
  }
  getId() {
    return Jt.ID;
  }
  static _applyDimensions(e, t, i) {
    const n = typeof t == "number" ? `${t}px` : t, s = typeof i == "number" ? `${i}px` : i;
    e.style.width = n, e.style.height = s;
  }
  _setContentsDomNodeDimensions(e, t) {
    const i = this._hover.contentsDomNode;
    return Jt._applyDimensions(i, e, t);
  }
  _setContainerDomNodeDimensions(e, t) {
    const i = this._hover.containerDomNode;
    return Jt._applyDimensions(i, e, t);
  }
  _setHoverWidgetDimensions(e, t) {
    this._setContentsDomNodeDimensions(e, t), this._setContainerDomNodeDimensions(e, t), this._layoutContentWidget();
  }
  static _applyMaxDimensions(e, t, i) {
    const n = typeof t == "number" ? `${t}px` : t, s = typeof i == "number" ? `${i}px` : i;
    e.style.maxWidth = n, e.style.maxHeight = s;
  }
  _setHoverWidgetMaxDimensions(e, t) {
    Jt._applyMaxDimensions(this._hover.contentsDomNode, e, t), Jt._applyMaxDimensions(this._hover.containerDomNode, e, t), this._hover.containerDomNode.style.setProperty("--vscode-hover-maxWidth", typeof e == "number" ? `${e}px` : e), this._layoutContentWidget();
  }
  _hasHorizontalScrollbar() {
    const e = this._hover.scrollbar.getScrollDimensions();
    return e.scrollWidth > e.width;
  }
  _adjustContentsBottomPadding() {
    const e = this._hover.contentsDomNode, t = `${this._hover.scrollbar.options.horizontalScrollbarSize}px`;
    e.style.paddingBottom !== t && (e.style.paddingBottom = t);
  }
  _setAdjustedHoverWidgetDimensions(e) {
    this._setHoverWidgetMaxDimensions("none", "none");
    const t = e.width, i = e.height;
    this._setHoverWidgetDimensions(t, i), this._hasHorizontalScrollbar() && (this._adjustContentsBottomPadding(), this._setContentsDomNodeDimensions(t, i - Mc));
  }
  _updateResizableNodeMaxDimensions() {
    var e, t;
    const i = (e = this._findMaximumRenderingWidth()) !== null && e !== void 0 ? e : 1 / 0, n = (t = this._findMaximumRenderingHeight()) !== null && t !== void 0 ? t : 1 / 0;
    this._resizableNode.maxSize = new ae(i, n), this._setHoverWidgetMaxDimensions(i, n);
  }
  _resize(e) {
    var t, i;
    Jt._lastDimensions = new ae(e.width, e.height), this._setAdjustedHoverWidgetDimensions(e), this._resizableNode.layout(e.height, e.width), this._updateResizableNodeMaxDimensions(), this._hover.scrollbar.scanDomNode(), this._editor.layoutContentWidget(this), (i = (t = this._visibleData) === null || t === void 0 ? void 0 : t.colorPicker) === null || i === void 0 || i.layout();
  }
  _findAvailableSpaceVertically() {
    var e;
    const t = (e = this._visibleData) === null || e === void 0 ? void 0 : e.showAtPosition;
    if (t)
      return this._positionPreference === 1 ? this._availableVerticalSpaceAbove(t) : this._availableVerticalSpaceBelow(t);
  }
  _findMaximumRenderingHeight() {
    const e = this._findAvailableSpaceVertically();
    if (!e)
      return;
    let t = zL;
    return Array.from(this._hover.contentsDomNode.children).forEach((i) => {
      t += i.clientHeight;
    }), this._hasHorizontalScrollbar() && (t += Mc), Math.min(e, t);
  }
  _isHoverTextOverflowing() {
    this._hover.containerDomNode.style.setProperty("--vscode-hover-whiteSpace", "nowrap"), this._hover.containerDomNode.style.setProperty("--vscode-hover-sourceWhiteSpace", "nowrap");
    const e = Array.from(this._hover.contentsDomNode.children).some((t) => t.scrollWidth > t.clientWidth);
    return this._hover.containerDomNode.style.removeProperty("--vscode-hover-whiteSpace"), this._hover.containerDomNode.style.removeProperty("--vscode-hover-sourceWhiteSpace"), e;
  }
  _findMaximumRenderingWidth() {
    if (!this._editor || !this._editor.hasModel())
      return;
    const e = this._isHoverTextOverflowing(), t = typeof this._contentWidth > "u" ? 0 : this._contentWidth - 2;
    return e || this._hover.containerDomNode.clientWidth < t ? ia(this._hover.containerDomNode.ownerDocument.body).width - 14 : this._hover.containerDomNode.clientWidth + 2;
  }
  isMouseGettingCloser(e, t) {
    if (!this._visibleData)
      return !1;
    if (typeof this._visibleData.initialMousePosX > "u" || typeof this._visibleData.initialMousePosY > "u")
      return this._visibleData.initialMousePosX = e, this._visibleData.initialMousePosY = t, !1;
    const i = mt(this.getDomNode());
    typeof this._visibleData.closestMouseDistance > "u" && (this._visibleData.closestMouseDistance = Cf(this._visibleData.initialMousePosX, this._visibleData.initialMousePosY, i.left, i.top, i.width, i.height));
    const n = Cf(e, t, i.left, i.top, i.width, i.height);
    return n > this._visibleData.closestMouseDistance + 4 ? !1 : (this._visibleData.closestMouseDistance = Math.min(this._visibleData.closestMouseDistance, n), !0);
  }
  _setHoverData(e) {
    var t;
    (t = this._visibleData) === null || t === void 0 || t.disposables.dispose(), this._visibleData = e, this._hoverVisibleKey.set(!!e), this._hover.containerDomNode.classList.toggle("hidden", !e);
  }
  _updateFont() {
    const { fontSize: e, lineHeight: t } = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), i = this._hover.contentsDomNode;
    i.style.fontSize = `${e}px`, i.style.lineHeight = `${t / e}`, Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((s) => this._editor.applyFontInfo(s));
  }
  _updateContent(e) {
    const t = this._hover.contentsDomNode;
    t.style.paddingBottom = "", t.textContent = "", t.appendChild(e);
  }
  _layoutContentWidget() {
    this._editor.layoutContentWidget(this), this._hover.onContentsChanged();
  }
  _updateMaxDimensions() {
    const e = Math.max(this._editor.getLayoutInfo().height / 4, 250, Jt._lastDimensions.height), t = Math.max(this._editor.getLayoutInfo().width * 0.66, 500, Jt._lastDimensions.width);
    this._setHoverWidgetMaxDimensions(t, e);
  }
  _render(e, t) {
    this._setHoverData(t), this._updateFont(), this._updateContent(e), this._updateMaxDimensions(), this.onContentsChanged(), this._editor.render();
  }
  getPosition() {
    var e;
    return this._visibleData ? {
      position: this._visibleData.showAtPosition,
      secondaryPosition: this._visibleData.showAtSecondaryPosition,
      positionAffinity: this._visibleData.isBeforeContent ? 3 : void 0,
      preference: [
        (e = this._positionPreference) !== null && e !== void 0 ? e : 1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    } : null;
  }
  showAt(e, t) {
    var i, n, s, o;
    if (!this._editor || !this._editor.hasModel())
      return;
    this._render(e, t);
    const a = ks(this._hover.containerDomNode), l = t.showAtPosition;
    this._positionPreference = (i = this._findPositionPreference(a, l)) !== null && i !== void 0 ? i : 1, this.onContentsChanged(), t.stoleFocus && this._hover.containerDomNode.focus(), (n = t.colorPicker) === null || n === void 0 || n.layout();
    const c = this._hover.containerDomNode.ownerDocument.activeElement === this._hover.containerDomNode && MS(this._configurationService.getValue("accessibility.verbosity.hover") === !0 && this._accessibilityService.isScreenReaderOptimized(), (o = (s = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) === null || s === void 0 ? void 0 : s.getAriaLabel()) !== null && o !== void 0 ? o : "");
    c && (this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ", " + c);
  }
  hide() {
    if (!this._visibleData)
      return;
    const e = this._visibleData.stoleFocus || this._hoverFocusedKey.get();
    this._setHoverData(void 0), this._resizableNode.maxSize = new ae(1 / 0, 1 / 0), this._resizableNode.clearSashHoverState(), this._hoverFocusedKey.set(!1), this._editor.layoutContentWidget(this), e && this._editor.focus();
  }
  _removeConstraintsRenderNormally() {
    const e = this._editor.getLayoutInfo();
    this._resizableNode.layout(e.height, e.width), this._setHoverWidgetDimensions("auto", "auto");
  }
  _adjustHoverHeightForScrollbar(e) {
    var t;
    const i = this._hover.containerDomNode, n = this._hover.contentsDomNode, s = (t = this._findMaximumRenderingHeight()) !== null && t !== void 0 ? t : 1 / 0;
    this._setContainerDomNodeDimensions(lt(i), Math.min(s, e)), this._setContentsDomNodeDimensions(lt(n), Math.min(s, e - Mc));
  }
  setMinimumDimensions(e) {
    this._minimumSize = new ae(Math.max(this._minimumSize.width, e.width), Math.max(this._minimumSize.height, e.height)), this._updateMinimumWidth();
  }
  _updateMinimumWidth() {
    const e = typeof this._contentWidth > "u" ? this._minimumSize.width : Math.min(this._contentWidth, this._minimumSize.width);
    this._resizableNode.minSize = new ae(e, this._minimumSize.height);
  }
  onContentsChanged() {
    var e;
    this._removeConstraintsRenderNormally();
    const t = this._hover.containerDomNode;
    let i = ks(t), n = lt(t);
    if (this._resizableNode.layout(i, n), this._setHoverWidgetDimensions(n, i), i = ks(t), n = lt(t), this._contentWidth = n, this._updateMinimumWidth(), this._resizableNode.layout(i, n), this._hasHorizontalScrollbar() && (this._adjustContentsBottomPadding(), this._adjustHoverHeightForScrollbar(i)), !((e = this._visibleData) === null || e === void 0) && e.showAtPosition) {
      const s = ks(this._hover.containerDomNode);
      this._positionPreference = this._findPositionPreference(s, this._visibleData.showAtPosition);
    }
    this._layoutContentWidget();
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  scrollUp() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: e - t.lineHeight });
  }
  scrollDown() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: e + t.lineHeight });
  }
  scrollLeft() {
    const e = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: e - bf });
  }
  scrollRight() {
    const e = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: e + bf });
  }
  pageUp() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: e - t });
  }
  pageDown() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: e + t });
  }
  goToTop() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: 0 });
  }
  goToBottom() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight });
  }
};
Ji.ID = "editor.contrib.resizableContentHoverWidget";
Ji._lastDimensions = new ae(0, 0);
Ji = Jt = Hg([
  Rn(1, ee),
  Rn(2, he),
  Rn(3, og),
  Rn(4, xe)
], Ji);
let Al = class extends P {
  get hasContent() {
    return this._hasContent;
  }
  constructor(e) {
    super(), this._keybindingService = e, this._hasContent = !1, this.hoverElement = vf("div.hover-row.status-bar"), this.actionsElement = A(this.hoverElement, vf("div.actions"));
  }
  addAction(e) {
    const t = this._keybindingService.lookupKeybinding(e.commandId), i = t ? t.getLabel() : null;
    return this._hasContent = !0, this._register(ES.render(this.actionsElement, e, i));
  }
  append(e) {
    const t = A(this.actionsElement, e);
    return this._hasContent = !0, t;
  }
};
Al = Hg([
  Rn(0, xe)
], Al);
class Ol {
  get anchor() {
    return this._anchor;
  }
  set anchor(e) {
    this._anchor = e;
  }
  get shouldFocus() {
    return this._shouldFocus;
  }
  set shouldFocus(e) {
    this._shouldFocus = e;
  }
  get source() {
    return this._source;
  }
  set source(e) {
    this._source = e;
  }
  get insistOnKeepingHoverVisible() {
    return this._insistOnKeepingHoverVisible;
  }
  set insistOnKeepingHoverVisible(e) {
    this._insistOnKeepingHoverVisible = e;
  }
  constructor(e, t) {
    this._editor = e, this._participants = t, this._anchor = null, this._shouldFocus = !1, this._source = 0, this._insistOnKeepingHoverVisible = !1;
  }
  static _getLineDecorations(e, t) {
    if (t.type !== 1 && !t.supportsMarkerHover)
      return [];
    const i = e.getModel(), n = t.range.startLineNumber;
    if (n > i.getLineCount())
      return [];
    const s = i.getLineMaxColumn(n);
    return e.getLineDecorations(n).filter((o) => {
      if (o.options.isWholeLine)
        return !0;
      const a = o.range.startLineNumber === n ? o.range.startColumn : 1, l = o.range.endLineNumber === n ? o.range.endColumn : s;
      if (o.options.showIfCollapsed) {
        if (a > t.range.startColumn + 1 || t.range.endColumn - 1 > l)
          return !1;
      } else if (a > t.range.startColumn || t.range.endColumn > l)
        return !1;
      return !0;
    });
  }
  computeAsync(e) {
    const t = this._anchor;
    if (!this._editor.hasModel() || !t)
      return zt.EMPTY;
    const i = Ol._getLineDecorations(this._editor, t);
    return zt.merge(this._participants.map((n) => n.computeAsync ? n.computeAsync(t, i, e) : zt.EMPTY));
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._anchor)
      return [];
    const e = Ol._getLineDecorations(this._editor, this._anchor);
    let t = [];
    for (const i of this._participants)
      t = t.concat(i.computeSync(this._anchor, e));
    return Ii(t);
  }
}
function Cf(r, e, t, i, n, s) {
  const o = t + n / 2, a = i + s / 2, l = Math.max(Math.abs(r - o) - n / 2, 0), d = Math.max(Math.abs(e - a) - s / 2, 0);
  return Math.sqrt(l * l + d * d);
}
const Sf = O;
class Fs extends P {
  constructor(e, t, i) {
    super(), this._renderDisposeables = this._register(new M()), this._editor = e, this._isVisible = !1, this._messages = [], this._hover = this._register(new Jm()), this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible), this._markdownRenderer = this._register(new po({ editor: this._editor }, t, i)), this._computer = new $L(this._editor), this._hoverOperation = this._register(new gb(this._editor, this._computer)), this._register(this._hoverOperation.onResult((n) => {
      this._withResult(n.value);
    })), this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged())), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    })), this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this), super.dispose();
  }
  getId() {
    return Fs.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _updateFont() {
    Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((t) => this._editor.applyFontInfo(t));
  }
  _onModelDecorationsChanged() {
    this._isVisible && (this._hoverOperation.cancel(), this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    ));
  }
  startShowingAt(e, t) {
    this._computer.lineNumber === e && this._computer.lane === t || (this._hoverOperation.cancel(), this.hide(), this._computer.lineNumber = e, this._computer.lane = t, this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    ));
  }
  hide() {
    this._computer.lineNumber = -1, this._hoverOperation.cancel(), this._isVisible && (this._isVisible = !1, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
  }
  _withResult(e) {
    this._messages = e, this._messages.length > 0 ? this._renderMessages(this._computer.lineNumber, this._messages) : this.hide();
  }
  _renderMessages(e, t) {
    this._renderDisposeables.clear();
    const i = document.createDocumentFragment();
    for (const n of t) {
      const s = Sf("div.hover-row.markdown-hover"), o = A(s, Sf("div.hover-contents")), a = this._renderDisposeables.add(this._markdownRenderer.render(n.value));
      o.appendChild(a.element), i.appendChild(s);
    }
    this._updateContents(i), this._showAt(e);
  }
  _updateContents(e) {
    this._hover.contentsDomNode.textContent = "", this._hover.contentsDomNode.appendChild(e), this._updateFont();
  }
  _showAt(e) {
    this._isVisible || (this._isVisible = !0, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
    const t = this._editor.getLayoutInfo(), i = this._editor.getTopForLineNumber(e), n = this._editor.getScrollTop(), s = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), o = this._hover.containerDomNode.clientHeight, a = i - n - (o - s) / 2, l = t.glyphMarginLeft + t.glyphMarginWidth + (this._computer.lane === "lineNo" ? t.lineNumbersWidth : 0);
    this._hover.containerDomNode.style.left = `${l}px`, this._hover.containerDomNode.style.top = `${Math.max(Math.round(a), 0)}px`;
  }
}
Fs.ID = "editor.contrib.modesGlyphHoverWidget";
class $L {
  get lineNumber() {
    return this._lineNumber;
  }
  set lineNumber(e) {
    this._lineNumber = e;
  }
  get lane() {
    return this._laneOrLine;
  }
  set lane(e) {
    this._laneOrLine = e;
  }
  constructor(e) {
    this._editor = e, this._lineNumber = -1, this._laneOrLine = Dp.Center;
  }
  computeSync() {
    var e, t;
    const i = (a) => ({
      value: a
    }), n = this._editor.getLineDecorations(this._lineNumber), s = [], o = this._laneOrLine === "lineNo";
    if (!n)
      return s;
    for (const a of n) {
      const l = (t = (e = a.options.glyphMargin) === null || e === void 0 ? void 0 : e.position) !== null && t !== void 0 ? t : Dp.Center;
      if (!o && l !== this._laneOrLine)
        continue;
      const d = o ? a.options.lineNumberHoverMessage : a.options.glyphMarginHoverMessage;
      !d || _r(d) || s.push(...e_(d).map(i));
    }
    return s;
  }
}
class jL {
  constructor(e, t, i) {
    this.provider = e, this.hover = t, this.ordinal = i;
  }
}
async function qL(r, e, t, i, n) {
  try {
    const s = await Promise.resolve(r.provideHover(t, i, n));
    if (s && GL(s))
      return new jL(r, s, e);
  } catch (s) {
    Ie(s);
  }
}
function Bg(r, e, t, i) {
  const s = r.ordered(e).map((o, a) => qL(o, a, e, t, i));
  return zt.fromPromises(s).coalesce();
}
function KL(r, e, t, i) {
  return Bg(r, e, t, i).map((n) => n.hover).toPromise();
}
pi("_executeHoverProvider", (r, e, t) => {
  const i = r.get(V);
  return KL(i.hoverProvider, e, t, X.None);
});
function GL(r) {
  const e = typeof r.range < "u", t = typeof r.contents < "u" && r.contents && r.contents.length > 0;
  return e && t;
}
var ZL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Fa = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const wf = O;
class Vt {
  constructor(e, t, i, n, s) {
    this.owner = e, this.range = t, this.contents = i, this.isBeforeContent = n, this.ordinal = s;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let Fl = class {
  constructor(e, t, i, n, s) {
    this._editor = e, this._languageService = t, this._openerService = i, this._configurationService = n, this._languageFeaturesService = s, this.hoverOrdinal = 3;
  }
  createLoadingMessage(e) {
    return new Vt(this, e.range, [new Ue().appendText(g("modesContentHover.loading", "Loading..."))], !1, 2e3);
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1)
      return [];
    const i = this._editor.getModel(), n = e.range.startLineNumber, s = i.getLineMaxColumn(n), o = [];
    let a = 1e3;
    const l = i.getLineLength(n), d = i.getLanguageIdAtPosition(e.range.startLineNumber, e.range.startColumn), c = this._editor.getOption(
      117
      /* EditorOption.stopRenderingLineAfter */
    ), h = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: d
    });
    let u = !1;
    c >= 0 && l > c && e.range.startColumn >= c && (u = !0, o.push(new Vt(this, e.range, [{
      value: g("stopped rendering", "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
    }], !1, a++))), !u && typeof h == "number" && l >= h && o.push(new Vt(this, e.range, [{
      value: g("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
    }], !1, a++));
    let p = !1;
    for (const f of t) {
      const m = f.range.startLineNumber === n ? f.range.startColumn : 1, _ = f.range.endLineNumber === n ? f.range.endColumn : s, v = f.options.hoverMessage;
      if (!v || _r(v))
        continue;
      f.options.beforeContentClassName && (p = !0);
      const C = new S(e.range.startLineNumber, m, e.range.startLineNumber, _);
      o.push(new Vt(this, C, e_(v), p, a++));
    }
    return o;
  }
  computeAsync(e, t, i) {
    if (!this._editor.hasModel() || e.type !== 1)
      return zt.EMPTY;
    const n = this._editor.getModel();
    if (!this._languageFeaturesService.hoverProvider.has(n))
      return zt.EMPTY;
    const s = new F(e.range.startLineNumber, e.range.startColumn);
    return Bg(this._languageFeaturesService.hoverProvider, n, s, i).filter((o) => !_r(o.hover.contents)).map((o) => {
      const a = o.hover.range ? S.lift(o.hover.range) : e.range;
      return new Vt(this, a, o.hover.contents, !1, o.ordinal);
    });
  }
  renderHoverParts(e, t) {
    return fb(e, t, this._editor, this._languageService, this._openerService);
  }
};
Fl = ZL([
  Fa(1, Et),
  Fa(2, Gt),
  Fa(3, he),
  Fa(4, V)
], Fl);
function fb(r, e, t, i, n) {
  e.sort((o, a) => o.ordinal - a.ordinal);
  const s = new M();
  for (const o of e)
    for (const a of o.contents) {
      if (_r(a))
        continue;
      const l = wf("div.hover-row.markdown-hover"), d = A(l, wf("div.hover-contents")), c = s.add(new po({ editor: t }, i, n));
      s.add(c.onDidRenderAsync(() => {
        d.className = "hover-contents code-hover-contents", r.onContentsChanged();
      }));
      const h = s.add(c.render(a));
      d.appendChild(h.element), r.fragment.appendChild(l);
    }
  return s;
}
var mb = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Wl = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class yf {
  constructor(e, t, i) {
    this.marker = e, this.index = t, this.total = i;
  }
}
let kh = class {
  constructor(e, t, i) {
    this._markerService = t, this._configService = i, this._onDidChange = new G(), this.onDidChange = this._onDidChange.event, this._dispoables = new M(), this._markers = [], this._nextIdx = -1, ce.isUri(e) ? this._resourceFilter = (a) => a.toString() === e.toString() : e && (this._resourceFilter = e);
    const n = this._configService.getValue("problems.sortOrder"), s = (a, l) => {
      let d = kp(a.resource.toString(), l.resource.toString());
      return d === 0 && (n === "position" ? d = S.compareRangesUsingStarts(a, l) || je.compare(a.severity, l.severity) : d = je.compare(a.severity, l.severity) || S.compareRangesUsingStarts(a, l)), d;
    }, o = () => {
      this._markers = this._markerService.read({
        resource: ce.isUri(e) ? e : void 0,
        severities: je.Error | je.Warning | je.Info
      }), typeof e == "function" && (this._markers = this._markers.filter((a) => this._resourceFilter(a.resource))), this._markers.sort(s);
    };
    o(), this._dispoables.add(t.onMarkerChanged((a) => {
      (!this._resourceFilter || a.some((l) => this._resourceFilter(l))) && (o(), this._nextIdx = -1, this._onDidChange.fire());
    }));
  }
  dispose() {
    this._dispoables.dispose(), this._onDidChange.dispose();
  }
  matches(e) {
    return !this._resourceFilter && !e ? !0 : !this._resourceFilter || !e ? !1 : this._resourceFilter(e);
  }
  get selected() {
    const e = this._markers[this._nextIdx];
    return e && new yf(e, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(e, t, i) {
    let n = !1, s = this._markers.findIndex((o) => o.resource.toString() === e.uri.toString());
    s < 0 && (s = Sl(this._markers, { resource: e.uri }, (o, a) => kp(o.resource.toString(), a.resource.toString())), s < 0 && (s = ~s));
    for (let o = s; o < this._markers.length; o++) {
      let a = S.lift(this._markers[o]);
      if (a.isEmpty()) {
        const l = e.getWordAtPosition(a.getStartPosition());
        l && (a = new S(a.startLineNumber, l.startColumn, a.startLineNumber, l.endColumn));
      }
      if (t && (a.containsPosition(t) || t.isBeforeOrEqual(a.getStartPosition()))) {
        this._nextIdx = o, n = !0;
        break;
      }
      if (this._markers[o].resource.toString() !== e.uri.toString())
        break;
    }
    n || (this._nextIdx = i ? 0 : this._markers.length - 1), this._nextIdx < 0 && (this._nextIdx = this._markers.length - 1);
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(e, t, i) {
    if (this._markers.length === 0)
      return !1;
    const n = this._nextIdx;
    return this._nextIdx === -1 ? this._initIdx(t, i, e) : e ? this._nextIdx = (this._nextIdx + 1) % this._markers.length : e || (this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length), n !== this._nextIdx;
  }
  find(e, t) {
    let i = this._markers.findIndex((n) => n.resource.toString() === e.toString());
    if (!(i < 0)) {
      for (; i < this._markers.length; i++)
        if (S.containsPosition(this._markers[i], t))
          return new yf(this._markers[i], i + 1, this._markers.length);
    }
  }
};
kh = mb([
  Wl(1, ig),
  Wl(2, he)
], kh);
const _b = Ti("IMarkerNavigationService");
let Nh = class {
  constructor(e, t) {
    this._markerService = e, this._configService = t, this._provider = new t_();
  }
  getMarkerList(e) {
    for (const t of this._provider) {
      const i = t.getMarkerList(e);
      if (i)
        return i;
    }
    return new kh(e, this._markerService, this._configService);
  }
};
Nh = mb([
  Wl(0, ig),
  Wl(1, he)
], Nh);
Ai(
  _b,
  Nh,
  1
  /* InstantiationType.Delayed */
);
var Rh;
(function(r) {
  function e(t) {
    switch (t) {
      case Sa.Ignore:
        return "severity-ignore " + oe.asClassName(j.info);
      case Sa.Info:
        return oe.asClassName(j.info);
      case Sa.Warning:
        return oe.asClassName(j.warning);
      case Sa.Error:
        return oe.asClassName(j.error);
      default:
        return "";
    }
  }
  r.className = e;
})(Rh || (Rh = {}));
var XL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, gs = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Ph;
class QL {
  constructor(e, t, i, n, s) {
    this._openerService = n, this._labelService = s, this._lines = 0, this._longestLineLength = 0, this._relatedDiagnostics = /* @__PURE__ */ new WeakMap(), this._disposables = new M(), this._editor = t;
    const o = document.createElement("div");
    o.className = "descriptioncontainer", this._messageBlock = document.createElement("div"), this._messageBlock.classList.add("message"), this._messageBlock.setAttribute("aria-live", "assertive"), this._messageBlock.setAttribute("role", "alert"), o.appendChild(this._messageBlock), this._relatedBlock = document.createElement("div"), o.appendChild(this._relatedBlock), this._disposables.add(Bn(this._relatedBlock, "click", (a) => {
      a.preventDefault();
      const l = this._relatedDiagnostics.get(a.target);
      l && i(l);
    })), this._scrollable = new HS(o, {
      horizontal: 1,
      vertical: 1,
      useShadows: !1,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    }), e.appendChild(this._scrollable.getDomNode()), this._disposables.add(this._scrollable.onScroll((a) => {
      o.style.left = `-${a.scrollLeft}px`, o.style.top = `-${a.scrollTop}px`;
    })), this._disposables.add(this._scrollable);
  }
  dispose() {
    $e(this._disposables);
  }
  update(e) {
    const { source: t, message: i, relatedInformation: n, code: s } = e;
    let o = ((t == null ? void 0 : t.length) || 0) + 2;
    s && (typeof s == "string" ? o += s.length : o += s.value.length);
    const a = dd(i);
    this._lines = a.length, this._longestLineLength = 0;
    for (const u of a)
      this._longestLineLength = Math.max(u.length + o, this._longestLineLength);
    Qi(this._messageBlock), this._messageBlock.setAttribute("aria-label", this.getAriaLabel(e)), this._editor.applyFontInfo(this._messageBlock);
    let l = this._messageBlock;
    for (const u of a)
      l = document.createElement("div"), l.innerText = u, u === "" && (l.style.height = this._messageBlock.style.lineHeight), this._messageBlock.appendChild(l);
    if (t || s) {
      const u = document.createElement("span");
      if (u.classList.add("details"), l.appendChild(u), t) {
        const p = document.createElement("span");
        p.innerText = t, p.classList.add("source"), u.appendChild(p);
      }
      if (s)
        if (typeof s == "string") {
          const p = document.createElement("span");
          p.innerText = `(${s})`, p.classList.add("code"), u.appendChild(p);
        } else {
          this._codeLink = O("a.code-link"), this._codeLink.setAttribute("href", `${s.target.toString()}`), this._codeLink.onclick = (f) => {
            this._openerService.open(s.target, { allowCommands: !0 }), f.preventDefault(), f.stopPropagation();
          };
          const p = A(this._codeLink, O("span"));
          p.innerText = s.value, u.appendChild(this._codeLink);
        }
    }
    if (Qi(this._relatedBlock), this._editor.applyFontInfo(this._relatedBlock), nt(n)) {
      const u = this._relatedBlock.appendChild(document.createElement("div"));
      u.style.paddingTop = `${Math.floor(this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      ) * 0.66)}px`, this._lines += 1;
      for (const p of n) {
        const f = document.createElement("div"), m = document.createElement("a");
        m.classList.add("filename"), m.innerText = `${this._labelService.getUriBasenameLabel(p.resource)}(${p.startLineNumber}, ${p.startColumn}): `, m.title = this._labelService.getUriLabel(p.resource), this._relatedDiagnostics.set(m, p);
        const _ = document.createElement("span");
        _.innerText = p.message, f.appendChild(m), f.appendChild(_), this._lines += 1, u.appendChild(f);
      }
    }
    const d = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), c = Math.ceil(d.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75), h = d.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth: c, scrollHeight: h });
  }
  layout(e, t) {
    this._scrollable.getDomNode().style.height = `${e}px`, this._scrollable.getDomNode().style.width = `${t}px`, this._scrollable.setScrollDimensions({ width: t, height: e });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(e) {
    let t = "";
    switch (e.severity) {
      case je.Error:
        t = g("Error", "Error");
        break;
      case je.Warning:
        t = g("Warning", "Warning");
        break;
      case je.Info:
        t = g("Info", "Info");
        break;
      case je.Hint:
        t = g("Hint", "Hint");
        break;
    }
    let i = g("marker aria", "{0} at {1}. ", t, e.startLineNumber + ":" + e.startColumn);
    const n = this._editor.getModel();
    return n && e.startLineNumber <= n.getLineCount() && e.startLineNumber >= 1 && (i = `${n.getLineContent(e.startLineNumber)}, ${i}`), i;
  }
}
let eo = Ph = class extends El {
  constructor(e, t, i, n, s, o, a) {
    super(e, { showArrow: !0, showFrame: !0, isAccessible: !0, frameWidth: 1 }, s), this._themeService = t, this._openerService = i, this._menuService = n, this._contextKeyService = o, this._labelService = a, this._callOnDispose = new M(), this._onDidSelectRelatedInformation = new G(), this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event, this._severity = je.Warning, this._backgroundColor = K.white, this._applyTheme(t.getColorTheme()), this._callOnDispose.add(t.onDidColorThemeChange(this._applyTheme.bind(this))), this.create();
  }
  _applyTheme(e) {
    this._backgroundColor = e.getColor(tI);
    let t = Mh, i = YL;
    this._severity === je.Warning ? (t = gl, i = JL) : this._severity === je.Info && (t = Eh, i = eI);
    const n = e.getColor(t), s = e.getColor(i);
    this.style({
      arrowColor: n,
      frameColor: n,
      headerBackgroundColor: s,
      primaryHeadingColor: e.getColor(nb),
      secondaryHeadingColor: e.getColor(sb)
    });
  }
  _applyStyles() {
    this._parentContainer && (this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : ""), super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose(), super.dispose();
  }
  _fillHead(e) {
    super._fillHead(e), this._disposables.add(this._actionbarWidget.actionRunner.onWillRun((n) => this.editor.focus()));
    const t = [], i = this._menuService.createMenu(Ph.TitleMenu, this._contextKeyService);
    cg(i, void 0, t), this._actionbarWidget.push(t, { label: !1, icon: !0, index: 0 }), i.dispose();
  }
  _fillTitleIcon(e) {
    this._icon = A(e, O(""));
  }
  _fillBody(e) {
    this._parentContainer = e, e.classList.add("marker-widget"), this._parentContainer.tabIndex = 0, this._parentContainer.setAttribute("role", "tooltip"), this._container = document.createElement("div"), e.appendChild(this._container), this._message = new QL(this._container, this.editor, (t) => this._onDidSelectRelatedInformation.fire(t), this._openerService, this._labelService), this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(e, t, i) {
    this._container.classList.remove("stale"), this._message.update(e), this._severity = e.severity, this._applyTheme(this._themeService.getColorTheme());
    const n = S.lift(e), s = this.editor.getPosition(), o = s && n.containsPosition(s) ? s : n.getStartPosition();
    super.show(o, this.computeRequiredHeight());
    const a = this.editor.getModel();
    if (a) {
      const l = i > 1 ? g("problems", "{0} of {1} problems", t, i) : g("change", "{0} of {1} problem", t, i);
      this.setTitle(oi(a.uri), l);
    }
    this._icon.className = `codicon ${Rh.className(je.toSeverity(this._severity))}`, this.editor.revealPositionNearTop(
      o,
      0
      /* ScrollType.Smooth */
    ), this.editor.focus();
  }
  updateMarker(e) {
    this._container.classList.remove("stale"), this._message.update(e);
  }
  showStale() {
    this._container.classList.add("stale"), this._relayout();
  }
  _doLayoutBody(e, t) {
    super._doLayoutBody(e, t), this._heightInPixel = e, this._message.layout(e, t), this._container.style.height = `${e}px`;
  }
  _onWidth(e) {
    this._message.layout(this._heightInPixel, e);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
};
eo.TitleMenu = new E("gotoErrorTitleMenu");
eo = Ph = XL([
  gs(1, Mt),
  gs(2, Gt),
  gs(3, is),
  gs(4, q),
  gs(5, ee),
  gs(6, fr)
], eo);
const xf = hg(AS, TS), Lf = hg(FS, OS), If = hg(th, WS), Mh = W("editorMarkerNavigationError.background", { dark: xf, light: xf, hcDark: Di, hcLight: Di }, g("editorMarkerNavigationError", "Editor marker navigation widget error color.")), YL = W("editorMarkerNavigationError.headerBackground", { dark: yt(Mh, 0.1), light: yt(Mh, 0.1), hcDark: null, hcLight: null }, g("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background.")), gl = W("editorMarkerNavigationWarning.background", { dark: Lf, light: Lf, hcDark: Di, hcLight: Di }, g("editorMarkerNavigationWarning", "Editor marker navigation widget warning color.")), JL = W("editorMarkerNavigationWarning.headerBackground", { dark: yt(gl, 0.1), light: yt(gl, 0.1), hcDark: "#0C141F", hcLight: yt(gl, 0.2) }, g("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background.")), Eh = W("editorMarkerNavigationInfo.background", { dark: If, light: If, hcDark: Di, hcLight: Di }, g("editorMarkerNavigationInfo", "Editor marker navigation widget info color.")), eI = W("editorMarkerNavigationInfo.headerBackground", { dark: yt(Eh, 0.1), light: yt(Eh, 0.1), hcDark: null, hcLight: null }, g("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background.")), tI = W("editorMarkerNavigation.background", { dark: wa, light: wa, hcDark: wa, hcLight: wa }, g("editorMarkerNavigationBackground", "Editor marker navigation widget background."));
var iI = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Wa = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Ko;
let cn = Ko = class {
  static get(e) {
    return e.getContribution(Ko.ID);
  }
  constructor(e, t, i, n, s) {
    this._markerNavigationService = t, this._contextKeyService = i, this._editorService = n, this._instantiationService = s, this._sessionDispoables = new M(), this._editor = e, this._widgetVisible = vb.bindTo(this._contextKeyService);
  }
  dispose() {
    this._cleanUp(), this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset(), this._sessionDispoables.clear(), this._widget = void 0, this._model = void 0;
  }
  _getOrCreateModel(e) {
    if (this._model && this._model.matches(e))
      return this._model;
    let t = !1;
    return this._model && (t = !0, this._cleanUp()), this._model = this._markerNavigationService.getMarkerList(e), t && this._model.move(!0, this._editor.getModel(), this._editor.getPosition()), this._widget = this._instantiationService.createInstance(eo, this._editor), this._widget.onDidClose(() => this.close(), this, this._sessionDispoables), this._widgetVisible.set(!0), this._sessionDispoables.add(this._model), this._sessionDispoables.add(this._widget), this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((i) => {
      var n, s, o;
      (!(!((n = this._model) === null || n === void 0) && n.selected) || !S.containsPosition((s = this._model) === null || s === void 0 ? void 0 : s.selected.marker, i.position)) && ((o = this._model) === null || o === void 0 || o.resetIndex());
    })), this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model)
        return;
      const i = this._model.find(this._editor.getModel().uri, this._widget.position);
      i ? this._widget.updateMarker(i.marker) : this._widget.showStale();
    })), this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((i) => {
      this._editorService.openCodeEditor({
        resource: i.resource,
        options: { pinned: !0, revealIfOpened: !0, selection: S.lift(i).collapseToStart() }
      }, this._editor), this.close(!1);
    })), this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp())), this._model;
  }
  close(e = !0) {
    this._cleanUp(), e && this._editor.focus();
  }
  showAtMarker(e) {
    if (this._editor.hasModel()) {
      const t = this._getOrCreateModel(this._editor.getModel().uri);
      t.resetIndex(), t.move(!0, this._editor.getModel(), new F(e.startLineNumber, e.startColumn)), t.selected && this._widget.showAtMarker(t.selected.marker, t.selected.index, t.selected.total);
    }
  }
  async nagivate(e, t) {
    var i, n;
    if (this._editor.hasModel()) {
      const s = this._getOrCreateModel(t ? void 0 : this._editor.getModel().uri);
      if (s.move(e, this._editor.getModel(), this._editor.getPosition()), !s.selected)
        return;
      if (s.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
        this._cleanUp();
        const o = await this._editorService.openCodeEditor({
          resource: s.selected.marker.resource,
          options: { pinned: !1, revealIfOpened: !0, selectionRevealType: 2, selection: s.selected.marker }
        }, this._editor);
        o && ((i = Ko.get(o)) === null || i === void 0 || i.close(), (n = Ko.get(o)) === null || n === void 0 || n.nagivate(e, t));
      } else
        this._widget.showAtMarker(s.selected.marker, s.selected.index, s.selected.total);
    }
  }
};
cn.ID = "editor.contrib.markerController";
cn = Ko = iI([
  Wa(1, _b),
  Wa(2, ee),
  Wa(3, _e),
  Wa(4, q)
], cn);
class Ed extends D {
  constructor(e, t, i) {
    super(i), this._next = e, this._multiFile = t;
  }
  async run(e, t) {
    var i;
    t.hasModel() && ((i = cn.get(t)) === null || i === void 0 || i.nagivate(this._next, this._multiFile));
  }
}
class en extends Ed {
  constructor() {
    super(!0, !1, {
      id: en.ID,
      label: en.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 578,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: eo.TitleMenu,
        title: en.LABEL,
        icon: Ae("marker-navigation-next", j.arrowDown, g("nextMarkerIcon", "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
}
en.ID = "editor.action.marker.next";
en.LABEL = g("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
class On extends Ed {
  constructor() {
    super(!1, !1, {
      id: On.ID,
      label: On.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 1602,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: eo.TitleMenu,
        title: On.LABEL,
        icon: Ae("marker-navigation-previous", j.arrowUp, g("previousMarkerIcon", "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
}
On.ID = "editor.action.marker.prev";
On.LABEL = g("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
class nI extends Ed {
  constructor() {
    super(!0, !0, {
      id: "editor.action.marker.nextInFiles",
      label: g("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarGoMenu,
        title: g({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
}
class sI extends Ed {
  constructor() {
    super(!1, !0, {
      id: "editor.action.marker.prevInFiles",
      label: g("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 1090,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarGoMenu,
        title: g({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
}
Z(
  cn.ID,
  cn,
  4
  /* EditorContributionInstantiation.Lazy */
);
x(en);
x(On);
x(nI);
x(sI);
const vb = new Q("markersNavigationVisible", !1), oI = bt.bindToContribution(cn.get);
B(new oI({
  id: "closeMarkersNavigation",
  precondition: vb,
  handler: (r) => r.close(),
  kbOpts: {
    weight: 150,
    kbExpr: b.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
var rI = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ec = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Lt = O;
class aI {
  constructor(e, t, i) {
    this.owner = e, this.range = t, this.marker = i;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
const Df = {
  type: 1,
  filter: { include: H.QuickFix },
  triggerAction: ot.QuickFixHover
};
let Th = class {
  constructor(e, t, i, n) {
    this._editor = e, this._markerDecorationsService = t, this._openerService = i, this._languageFeaturesService = n, this.hoverOrdinal = 1, this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1 && !e.supportsMarkerHover)
      return [];
    const i = this._editor.getModel(), n = e.range.startLineNumber, s = i.getLineMaxColumn(n), o = [];
    for (const a of t) {
      const l = a.range.startLineNumber === n ? a.range.startColumn : 1, d = a.range.endLineNumber === n ? a.range.endColumn : s, c = this._markerDecorationsService.getMarker(i.uri, a);
      if (!c)
        continue;
      const h = new S(e.range.startLineNumber, l, e.range.startLineNumber, d);
      o.push(new aI(this, h, c));
    }
    return o;
  }
  renderHoverParts(e, t) {
    if (!t.length)
      return P.None;
    const i = new M();
    t.forEach((s) => e.fragment.appendChild(this.renderMarkerHover(s, i)));
    const n = t.length === 1 ? t[0] : t.sort((s, o) => je.compare(s.marker.severity, o.marker.severity))[0];
    return this.renderMarkerStatusbar(e, n, i), i;
  }
  renderMarkerHover(e, t) {
    const i = Lt("div.hover-row"), n = A(i, Lt("div.marker.hover-contents")), { source: s, message: o, code: a, relatedInformation: l } = e.marker;
    this._editor.applyFontInfo(n);
    const d = A(n, Lt("span"));
    if (d.style.whiteSpace = "pre-wrap", d.innerText = o, s || a)
      if (a && typeof a != "string") {
        const c = Lt("span");
        if (s) {
          const f = A(c, Lt("span"));
          f.innerText = s;
        }
        const h = A(c, Lt("a.code-link"));
        h.setAttribute("href", a.target.toString()), t.add(le(h, "click", (f) => {
          this._openerService.open(a.target, { allowCommands: !0 }), f.preventDefault(), f.stopPropagation();
        }));
        const u = A(h, Lt("span"));
        u.innerText = a.value;
        const p = A(n, c);
        p.style.opacity = "0.6", p.style.paddingLeft = "6px";
      } else {
        const c = A(n, Lt("span"));
        c.style.opacity = "0.6", c.style.paddingLeft = "6px", c.innerText = s && a ? `${s}(${a})` : s || `(${a})`;
      }
    if (nt(l))
      for (const { message: c, resource: h, startLineNumber: u, startColumn: p } of l) {
        const f = A(n, Lt("div"));
        f.style.marginTop = "8px";
        const m = A(f, Lt("a"));
        m.innerText = `${oi(h)}(${u}, ${p}): `, m.style.cursor = "pointer", t.add(le(m, "click", (v) => {
          v.stopPropagation(), v.preventDefault(), this._openerService && this._openerService.open(h, {
            fromUserGesture: !0,
            editorOptions: { selection: { startLineNumber: u, startColumn: p } }
          }).catch(re);
        }));
        const _ = A(f, Lt("span"));
        _.innerText = c, this._editor.applyFontInfo(_);
      }
    return i;
  }
  renderMarkerStatusbar(e, t, i) {
    if (t.marker.severity === je.Error || t.marker.severity === je.Warning || t.marker.severity === je.Info) {
      const n = cn.get(this._editor);
      n && e.statusBar.addAction({
        label: g("view problem", "View Problem"),
        commandId: en.ID,
        run: () => {
          e.hide(), n.showAtMarker(t.marker), this._editor.focus();
        }
      });
    }
    if (!this._editor.getOption(
      91
      /* EditorOption.readOnly */
    )) {
      const n = e.statusBar.append(Lt("div"));
      this.recentMarkerCodeActionsInfo && (Np.makeKey(this.recentMarkerCodeActionsInfo.marker) === Np.makeKey(t.marker) ? this.recentMarkerCodeActionsInfo.hasCodeActions || (n.textContent = g("noQuickFixes", "No quick fixes available")) : this.recentMarkerCodeActionsInfo = void 0);
      const s = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? P.None : hr(() => n.textContent = g("checkingForQuickFixes", "Checking for quick fixes..."), 200, i);
      n.textContent || (n.textContent = "");
      const o = this.getCodeActions(t.marker);
      i.add(pe(() => o.cancel())), o.then((a) => {
        if (s.dispose(), this.recentMarkerCodeActionsInfo = { marker: t.marker, hasCodeActions: a.validActions.length > 0 }, !this.recentMarkerCodeActionsInfo.hasCodeActions) {
          a.dispose(), n.textContent = g("noQuickFixes", "No quick fixes available");
          return;
        }
        n.style.display = "none";
        let l = !1;
        i.add(pe(() => {
          l || a.dispose();
        })), e.statusBar.addAction({
          label: g("quick fixes", "Quick Fix..."),
          commandId: Pg,
          run: (d) => {
            l = !0;
            const c = on.get(this._editor), h = mt(d);
            e.hide(), c == null || c.showCodeActions(Df, a, {
              x: h.left,
              y: h.top,
              width: h.width,
              height: h.height
            });
          }
        });
      }, re);
    }
  }
  getCodeActions(e) {
    return Pe((t) => nr(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new S(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), Df, Xi.None, t));
  }
};
Th = rI([
  Ec(1, BS),
  Ec(2, Gt),
  Ec(3, V)
], Th);
const bb = "editor.action.inlineSuggest.commit", Cb = "editor.action.inlineSuggest.showPrevious", Sb = "editor.action.inlineSuggest.showNext";
var Vg = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ut = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, pl;
let Ah = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.instantiationService = i, this.alwaysShowToolbar = it(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).showToolbar === "always"), this.sessionPosition = void 0, this.position = Xe(this, (n) => {
      var s, o, a;
      const l = (s = this.model.read(n)) === null || s === void 0 ? void 0 : s.primaryGhostText.read(n);
      if (!this.alwaysShowToolbar.read(n) || !l || l.parts.length === 0)
        return this.sessionPosition = void 0, null;
      const d = l.parts[0].column;
      this.sessionPosition && this.sessionPosition.lineNumber !== l.lineNumber && (this.sessionPosition = void 0);
      const c = new F(l.lineNumber, Math.min(d, (a = (o = this.sessionPosition) === null || o === void 0 ? void 0 : o.column) !== null && a !== void 0 ? a : Number.MAX_SAFE_INTEGER));
      return this.sessionPosition = c, c;
    }), this._register(ug((n, s) => {
      const o = this.model.read(n);
      if (!o || !this.alwaysShowToolbar.read(n))
        return;
      const a = s.add(this.instantiationService.createInstance(hn, this.editor, !0, this.position, o.selectedInlineCompletionIndex, o.inlineCompletionsCount, o.selectedInlineCompletion.map((l) => {
        var d;
        return (d = l == null ? void 0 : l.inlineCompletion.source.inlineCompletions.commands) !== null && d !== void 0 ? d : [];
      })));
      e.addContentWidget(a), s.add(pe(() => e.removeContentWidget(a))), s.add(Ne((l) => {
        this.position.read(l) && o.lastTriggerKind.read(l) !== Tn.Explicit && o.triggerExplicitly();
      }));
    }));
  }
};
Ah = Vg([
  Ut(2, q)
], Ah);
const lI = Ae("inline-suggestion-hints-next", j.chevronRight, g("parameterHintsNextIcon", "Icon for show next parameter hint.")), dI = Ae("inline-suggestion-hints-previous", j.chevronLeft, g("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
let hn = pl = class extends P {
  static get dropDownVisible() {
    return this._dropDownVisible;
  }
  createCommandAction(e, t, i) {
    const n = new qs(e, t, i, !0, () => this._commandService.executeCommand(e)), s = this.keybindingService.lookupKeybinding(e, this._contextKeyService);
    let o = t;
    return s && (o = g({ key: "content", comment: ["A label", "A keybinding"] }, "{0} ({1})", t, s.getLabel())), n.tooltip = o, n;
  }
  constructor(e, t, i, n, s, o, a, l, d, c, h) {
    super(), this.editor = e, this.withBorder = t, this._position = i, this._currentSuggestionIdx = n, this._suggestionCount = s, this._extraCommands = o, this._commandService = a, this.keybindingService = d, this._contextKeyService = c, this._menuService = h, this.id = `InlineSuggestionHintsContentWidget${pl.id++}`, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this.nodes = Ks("div.inlineSuggestionsHints", { className: this.withBorder ? ".withBorder" : "" }, [
      Ks("div@toolBar")
    ]), this.previousAction = this.createCommandAction(Cb, g("previous", "Previous"), oe.asClassName(dI)), this.availableSuggestionCountAction = new qs("inlineSuggestionHints.availableSuggestionCount", "", void 0, !1), this.nextAction = this.createCommandAction(Sb, g("next", "Next"), oe.asClassName(lI)), this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(E.InlineCompletionsActions, this._contextKeyService)), this.clearAvailableSuggestionCountLabelDebounced = this._register(new Re(() => {
      this.availableSuggestionCountAction.label = "";
    }, 100)), this.disableButtonsDebounced = this._register(new Re(() => {
      this.previousAction.enabled = this.nextAction.enabled = !1;
    }, 100)), this.lastCommands = [], this.toolBar = this._register(l.createInstance(Oh, this.nodes.toolBar, E.InlineSuggestionToolbar, {
      menuOptions: { renderShortTitle: !0 },
      toolbarOptions: { primaryGroup: (u) => u.startsWith("primary") },
      actionViewItemProvider: (u, p) => {
        if (u instanceof Gs)
          return l.createInstance(hI, u, void 0);
        if (u === this.availableSuggestionCountAction) {
          const f = new cI(void 0, u, { label: !0, icon: !1 });
          return f.setClass("availableSuggestionCount"), f;
        }
      },
      telemetrySource: "InlineSuggestionToolbar"
    })), this.toolBar.setPrependedPrimaryActions([
      this.previousAction,
      this.availableSuggestionCountAction,
      this.nextAction
    ]), this._register(this.toolBar.onDidChangeDropdownVisibility((u) => {
      pl._dropDownVisible = u;
    })), this._register(Ne((u) => {
      this._position.read(u), this.editor.layoutContentWidget(this);
    })), this._register(Ne((u) => {
      const p = this._suggestionCount.read(u), f = this._currentSuggestionIdx.read(u);
      p !== void 0 ? (this.clearAvailableSuggestionCountLabelDebounced.cancel(), this.availableSuggestionCountAction.label = `${f + 1}/${p}`) : this.clearAvailableSuggestionCountLabelDebounced.schedule(), p !== void 0 && p > 1 ? (this.disableButtonsDebounced.cancel(), this.previousAction.enabled = this.nextAction.enabled = !0) : this.disableButtonsDebounced.schedule();
    })), this._register(Ne((u) => {
      const p = this._extraCommands.read(u);
      if (jt(this.lastCommands, p))
        return;
      this.lastCommands = p;
      const f = p.map((m) => ({
        class: void 0,
        id: m.id,
        enabled: !0,
        tooltip: m.tooltip || "",
        label: m.title,
        run: (_) => this._commandService.executeCommand(m.id)
      }));
      for (const [m, _] of this.inlineCompletionsActionsMenus.getActions())
        for (const v of _)
          v instanceof Gs && f.push(v);
      f.length > 0 && f.unshift(new vr()), this.toolBar.setAdditionalSecondaryActions(f);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ],
      positionAffinity: 3
    };
  }
};
hn._dropDownVisible = !1;
hn.id = 0;
hn = pl = Vg([
  Ut(6, Fe),
  Ut(7, q),
  Ut(8, xe),
  Ut(9, ee),
  Ut(10, is)
], hn);
class cI extends ih {
  constructor() {
    super(...arguments), this._className = void 0;
  }
  setClass(e) {
    this._className = e;
  }
  render(e) {
    super.render(e), this._className && e.classList.add(this._className);
  }
  updateTooltip() {
  }
}
let hI = class extends gg {
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    if (this.label) {
      const t = Ks("div.keybinding").root;
      new Ju(t, eg, { disableTitle: !0, ...i_ }).set(e), this.label.textContent = this._action.label, this.label.appendChild(t), this.label.classList.add("inlineSuggestionStatusBarItemLabel");
    }
  }
  updateTooltip() {
  }
}, Oh = class extends n_ {
  constructor(e, t, i, n, s, o, a, l) {
    super(e, { resetMenu: t, ...i }, n, s, o, a, l), this.menuId = t, this.options2 = i, this.menuService = n, this.contextKeyService = s, this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: !0 })), this.additionalActions = [], this.prependedPrimaryActions = [], this._store.add(this.menu.onDidChange(() => this.updateToolbar())), this.updateToolbar();
  }
  updateToolbar() {
    var e, t, i, n, s, o, a;
    const l = [], d = [];
    cg(this.menu, (e = this.options2) === null || e === void 0 ? void 0 : e.menuOptions, { primary: l, secondary: d }, (i = (t = this.options2) === null || t === void 0 ? void 0 : t.toolbarOptions) === null || i === void 0 ? void 0 : i.primaryGroup, (s = (n = this.options2) === null || n === void 0 ? void 0 : n.toolbarOptions) === null || s === void 0 ? void 0 : s.shouldInlineSubmenu, (a = (o = this.options2) === null || o === void 0 ? void 0 : o.toolbarOptions) === null || a === void 0 ? void 0 : a.useSeparatorsInPrimaryActions), d.push(...this.additionalActions), l.unshift(...this.prependedPrimaryActions), this.setActions(l, d);
  }
  setPrependedPrimaryActions(e) {
    jt(this.prependedPrimaryActions, e, (t, i) => t === i) || (this.prependedPrimaryActions = e, this.updateToolbar());
  }
  setAdditionalSecondaryActions(e) {
    jt(this.additionalActions, e, (t, i) => t === i) || (this.additionalActions = e, this.updateToolbar());
  }
};
Oh = Vg([
  Ut(3, is),
  Ut(4, ee),
  Ut(5, co),
  Ut(6, xe),
  Ut(7, ui)
], Oh);
var uI = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ha = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Fh;
const gI = !1;
let Ye = Fh = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._editor = e, this._instantiationService = t, this._openerService = i, this._languageService = n, this._keybindingService = s, this._listenersStore = new M(), this._hoverState = {
      mouseDown: !1,
      contentHoverFocused: !1,
      activatedByDecoratorClick: !1
    }, this._reactToEditorMouseMoveRunner = this._register(new Re(() => this._reactToEditorMouseMove(this._mouseMoveEvent), 0)), this._hookListeners(), this._register(this._editor.onDidChangeConfiguration((o) => {
      o.hasChanged(
        60
        /* EditorOption.hover */
      ) && (this._unhookListeners(), this._hookListeners());
    }));
  }
  static get(e) {
    return e.getContribution(Fh.ID);
  }
  _hookListeners() {
    const e = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._hoverSettings = {
      enabled: e.enabled,
      sticky: e.sticky,
      hidingDelay: e.delay
    }, e.enabled ? (this._listenersStore.add(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._listenersStore.add(this._editor.onMouseUp(() => this._onEditorMouseUp())), this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))) : (this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))), this._listenersStore.add(this._editor.onMouseLeave((t) => this._onEditorMouseLeave(t))), this._listenersStore.add(this._editor.onDidChangeModel(() => {
      this._cancelScheduler(), this._hideWidgets();
    })), this._listenersStore.add(this._editor.onDidChangeModelContent(() => this._cancelScheduler())), this._listenersStore.add(this._editor.onDidScrollChange((t) => this._onEditorScrollChanged(t)));
  }
  _unhookListeners() {
    this._listenersStore.clear();
  }
  _cancelScheduler() {
    this._mouseMoveEvent = void 0, this._reactToEditorMouseMoveRunner.cancel();
  }
  _onEditorScrollChanged(e) {
    (e.scrollTopChanged || e.scrollLeftChanged) && this._hideWidgets();
  }
  _onEditorMouseDown(e) {
    var t;
    this._hoverState.mouseDown = !0;
    const i = e.target;
    if (i.type === 9 && i.detail === Ji.ID) {
      this._hoverState.contentHoverFocused = !0;
      return;
    }
    i.type === 12 && i.detail === Fs.ID || (i.type !== 12 && (this._hoverState.contentHoverFocused = !1), !(!((t = this._contentWidget) === null || t === void 0) && t.widget.isResizing) && this._hideWidgets());
  }
  _onEditorMouseUp() {
    this._hoverState.mouseDown = !1;
  }
  _onEditorMouseLeave(e) {
    var t, i;
    this._cancelScheduler();
    const n = e.event.browserEvent.relatedTarget;
    !((t = this._contentWidget) === null || t === void 0) && t.widget.isResizing || !((i = this._contentWidget) === null || i === void 0) && i.containsNode(n) || this._hideWidgets();
  }
  _isMouseOverWidget(e) {
    var t, i, n, s, o;
    const a = e.target, l = this._hoverSettings.sticky;
    return !!(l && a.type === 9 && a.detail === Ji.ID || l && (!((t = this._contentWidget) === null || t === void 0) && t.containsNode((i = e.event.browserEvent.view) === null || i === void 0 ? void 0 : i.document.activeElement)) && !(!((s = (n = e.event.browserEvent.view) === null || n === void 0 ? void 0 : n.getSelection()) === null || s === void 0) && s.isCollapsed) || !l && a.type === 9 && a.detail === Ji.ID && (!((o = this._contentWidget) === null || o === void 0) && o.isColorPickerVisible) || l && a.type === 12 && a.detail === Fs.ID);
  }
  _onEditorMouseMove(e) {
    var t, i, n, s;
    if (this._mouseMoveEvent = e, !((t = this._contentWidget) === null || t === void 0) && t.isFocused || !((i = this._contentWidget) === null || i === void 0) && i.isResizing || this._hoverState.mouseDown && this._hoverState.contentHoverFocused)
      return;
    const o = this._hoverSettings.sticky;
    if (o && (!((n = this._contentWidget) === null || n === void 0) && n.isVisibleFromKeyboard))
      return;
    if (this._isMouseOverWidget(e)) {
      this._reactToEditorMouseMoveRunner.cancel();
      return;
    }
    const l = this._hoverSettings.hidingDelay;
    if (!((s = this._contentWidget) === null || s === void 0) && s.isVisible && o && l > 0) {
      this._reactToEditorMouseMoveRunner.isScheduled() || this._reactToEditorMouseMoveRunner.schedule(l);
      return;
    }
    this._reactToEditorMouseMove(e);
  }
  _reactToEditorMouseMove(e) {
    var t, i, n, s;
    if (!e)
      return;
    const o = e.target, a = (t = o.element) === null || t === void 0 ? void 0 : t.classList.contains("colorpicker-color-decoration"), l = this._editor.getOption(
      147
      /* EditorOption.colorDecoratorsActivatedOn */
    ), d = this._hoverSettings.enabled, c = this._hoverState.activatedByDecoratorClick;
    if (a && (l === "click" && !c || l === "hover" && !d && !gI || l === "clickAndHover" && !d && !c) || !a && !d && !c) {
      this._hideWidgets();
      return;
    }
    if (this._getOrCreateContentWidget().showsOrWillShow(e)) {
      (i = this._glyphWidget) === null || i === void 0 || i.hide();
      return;
    }
    if (o.type === 2 && o.position && o.detail.glyphMarginLane) {
      (n = this._contentWidget) === null || n === void 0 || n.hide(), this._getOrCreateGlyphWidget().startShowingAt(o.position.lineNumber, o.detail.glyphMarginLane);
      return;
    }
    if (o.type === 3 && o.position) {
      (s = this._contentWidget) === null || s === void 0 || s.hide(), this._getOrCreateGlyphWidget().startShowingAt(o.position.lineNumber, "lineNo");
      return;
    }
    this._hideWidgets();
  }
  _onKeyDown(e) {
    var t;
    if (!this._editor.hasModel())
      return;
    const i = this._keybindingService.softDispatch(e, this._editor.getDomNode()), n = i.kind === 1 || i.kind === 2 && i.commandId === "editor.action.showHover" && ((t = this._contentWidget) === null || t === void 0 ? void 0 : t.isVisible);
    e.keyCode === 5 || e.keyCode === 6 || e.keyCode === 57 || e.keyCode === 4 || n || this._hideWidgets();
  }
  _hideWidgets() {
    var e, t, i;
    this._hoverState.mouseDown && this._hoverState.contentHoverFocused && (!((e = this._contentWidget) === null || e === void 0) && e.isColorPickerVisible) || hn.dropDownVisible || (this._hoverState.activatedByDecoratorClick = !1, this._hoverState.contentHoverFocused = !1, (t = this._glyphWidget) === null || t === void 0 || t.hide(), (i = this._contentWidget) === null || i === void 0 || i.hide());
  }
  _getOrCreateContentWidget() {
    return this._contentWidget || (this._contentWidget = this._instantiationService.createInstance(Tl, this._editor)), this._contentWidget;
  }
  _getOrCreateGlyphWidget() {
    return this._glyphWidget || (this._glyphWidget = new Fs(this._editor, this._languageService, this._openerService)), this._glyphWidget;
  }
  showContentHover(e, t, i, n, s = !1) {
    this._hoverState.activatedByDecoratorClick = s, this._getOrCreateContentWidget().startShowingAtRange(e, t, i, n);
  }
  focus() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.focus();
  }
  scrollUp() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.scrollUp();
  }
  scrollDown() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.scrollDown();
  }
  scrollLeft() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.scrollLeft();
  }
  scrollRight() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.scrollRight();
  }
  pageUp() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.pageUp();
  }
  pageDown() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.pageDown();
  }
  goToTop() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.goToTop();
  }
  goToBottom() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.goToBottom();
  }
  get isColorPickerVisible() {
    var e;
    return (e = this._contentWidget) === null || e === void 0 ? void 0 : e.isColorPickerVisible;
  }
  get isHoverVisible() {
    var e;
    return (e = this._contentWidget) === null || e === void 0 ? void 0 : e.isVisible;
  }
  dispose() {
    var e, t;
    super.dispose(), this._unhookListeners(), this._listenersStore.dispose(), (e = this._glyphWidget) === null || e === void 0 || e.dispose(), (t = this._contentWidget) === null || t === void 0 || t.dispose();
  }
};
Ye.ID = "editor.contrib.hover";
Ye = Fh = uI([
  Ha(1, q),
  Ha(2, Gt),
  Ha(3, Et),
  Ha(4, xe)
], Ye);
var At;
(function(r) {
  r.NoAutoFocus = "noAutoFocus", r.FocusIfVisible = "focusIfVisible", r.AutoFocusImmediately = "autoFocusImmediately";
})(At || (At = {}));
class pI extends D {
  constructor() {
    super({
      id: "editor.action.showHover",
      label: g({
        key: "showOrFocusHover",
        comment: [
          "Label for action that will trigger the showing/focusing of a hover in the editor.",
          "If the hover is not visible, it will show the hover.",
          "This allows for users to show the hover without using the mouse."
        ]
      }, "Show or Focus Hover"),
      metadata: {
        description: "Show or Focus Hover",
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              focus: {
                description: "Controls if and when the hover should take focus upon being triggered by this action.",
                enum: [At.NoAutoFocus, At.FocusIfVisible, At.AutoFocusImmediately],
                enumDescriptions: [
                  g("showOrFocusHover.focus.noAutoFocus", "The hover will not automatically take focus."),
                  g("showOrFocusHover.focus.focusIfVisible", "The hover will take focus only if it is already visible."),
                  g("showOrFocusHover.focus.autoFocusImmediately", "The hover will automatically take focus when it appears.")
                ],
                default: At.FocusIfVisible
              }
            }
          }
        }]
      },
      alias: "Show or Focus Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2087
          /* KeyCode.KeyI */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = Ye.get(t);
    if (!n)
      return;
    const s = i == null ? void 0 : i.focus;
    let o = At.FocusIfVisible;
    Object.values(At).includes(s) ? o = s : typeof s == "boolean" && s && (o = At.AutoFocusImmediately);
    const a = (d) => {
      const c = t.getPosition(), h = new S(c.lineNumber, c.column, c.lineNumber, c.column);
      n.showContentHover(h, 1, 1, d);
    }, l = t.getOption(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2;
    n.isHoverVisible ? o !== At.NoAutoFocus ? n.focus() : a(l) : a(l || o === At.AutoFocusImmediately);
  }
}
class fI extends D {
  constructor() {
    super({
      id: "editor.action.showDefinitionPreviewHover",
      label: g({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    if (!i)
      return;
    const n = t.getPosition();
    if (!n)
      return;
    const s = new S(n.lineNumber, n.column, n.lineNumber, n.column), o = Kn.get(t);
    if (!o)
      return;
    o.startFindDefinitionFromCursor(n).then(() => {
      i.showContentHover(s, 1, 1, !0);
    });
  }
}
class mI extends D {
  constructor() {
    super({
      id: "editor.action.scrollUpHover",
      label: g({
        key: "scrollUpHover",
        comment: [
          "Action that allows to scroll up in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Up Hover"),
      alias: "Scroll Up Hover",
      precondition: b.hoverFocused,
      kbOpts: {
        kbExpr: b.hoverFocused,
        primary: 16,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    i && i.scrollUp();
  }
}
class _I extends D {
  constructor() {
    super({
      id: "editor.action.scrollDownHover",
      label: g({
        key: "scrollDownHover",
        comment: [
          "Action that allows to scroll down in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Down Hover"),
      alias: "Scroll Down Hover",
      precondition: b.hoverFocused,
      kbOpts: {
        kbExpr: b.hoverFocused,
        primary: 18,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    i && i.scrollDown();
  }
}
class vI extends D {
  constructor() {
    super({
      id: "editor.action.scrollLeftHover",
      label: g({
        key: "scrollLeftHover",
        comment: [
          "Action that allows to scroll left in the hover widget with the left arrow when the hover widget is focused."
        ]
      }, "Scroll Left Hover"),
      alias: "Scroll Left Hover",
      precondition: b.hoverFocused,
      kbOpts: {
        kbExpr: b.hoverFocused,
        primary: 15,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    i && i.scrollLeft();
  }
}
class bI extends D {
  constructor() {
    super({
      id: "editor.action.scrollRightHover",
      label: g({
        key: "scrollRightHover",
        comment: [
          "Action that allows to scroll right in the hover widget with the right arrow when the hover widget is focused."
        ]
      }, "Scroll Right Hover"),
      alias: "Scroll Right Hover",
      precondition: b.hoverFocused,
      kbOpts: {
        kbExpr: b.hoverFocused,
        primary: 17,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    i && i.scrollRight();
  }
}
class CI extends D {
  constructor() {
    super({
      id: "editor.action.pageUpHover",
      label: g({
        key: "pageUpHover",
        comment: [
          "Action that allows to page up in the hover widget with the page up command when the hover widget is focused."
        ]
      }, "Page Up Hover"),
      alias: "Page Up Hover",
      precondition: b.hoverFocused,
      kbOpts: {
        kbExpr: b.hoverFocused,
        primary: 11,
        secondary: [
          528
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    i && i.pageUp();
  }
}
class SI extends D {
  constructor() {
    super({
      id: "editor.action.pageDownHover",
      label: g({
        key: "pageDownHover",
        comment: [
          "Action that allows to page down in the hover widget with the page down command when the hover widget is focused."
        ]
      }, "Page Down Hover"),
      alias: "Page Down Hover",
      precondition: b.hoverFocused,
      kbOpts: {
        kbExpr: b.hoverFocused,
        primary: 12,
        secondary: [
          530
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    i && i.pageDown();
  }
}
class wI extends D {
  constructor() {
    super({
      id: "editor.action.goToTopHover",
      label: g({
        key: "goToTopHover",
        comment: [
          "Action that allows to go to the top of the hover widget with the home command when the hover widget is focused."
        ]
      }, "Go To Top Hover"),
      alias: "Go To Bottom Hover",
      precondition: b.hoverFocused,
      kbOpts: {
        kbExpr: b.hoverFocused,
        primary: 14,
        secondary: [
          2064
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    i && i.goToTop();
  }
}
class yI extends D {
  constructor() {
    super({
      id: "editor.action.goToBottomHover",
      label: g({
        key: "goToBottomHover",
        comment: [
          "Action that allows to go to the bottom in the hover widget with the end command when the hover widget is focused."
        ]
      }, "Go To Bottom Hover"),
      alias: "Go To Bottom Hover",
      precondition: b.hoverFocused,
      kbOpts: {
        kbExpr: b.hoverFocused,
        primary: 13,
        secondary: [
          2066
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ye.get(t);
    i && i.goToBottom();
  }
}
Z(
  Ye.ID,
  Ye,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
x(pI);
x(fI);
x(mI);
x(_I);
x(vI);
x(bI);
x(CI);
x(SI);
x(wI);
x(yI);
bn.register(Fl);
bn.register(Th);
od((r, e) => {
  const t = r.getColor(VS);
  t && (e.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${t.transparent(0.5)}; }`));
});
class Wh extends P {
  constructor(e) {
    super(), this._editor = e, this._register(e.onMouseDown((t) => this.onMouseDown(t)));
  }
  dispose() {
    super.dispose();
  }
  onMouseDown(e) {
    const t = this._editor.getOption(
      147
      /* EditorOption.colorDecoratorsActivatedOn */
    );
    if (t !== "click" && t !== "clickAndHover")
      return;
    const i = e.target;
    if (i.type !== 6 || !i.detail.injectedText || i.detail.injectedText.options.attachedData !== Kv || !i.range)
      return;
    const n = this._editor.getContribution(Ye.ID);
    if (n && !n.isColorPickerVisible) {
      const s = new S(i.range.startLineNumber, i.range.startColumn + 1, i.range.endLineNumber, i.range.endColumn + 1);
      n.showContentHover(s, 1, 0, !1, !0);
    }
  }
}
Wh.ID = "editor.contrib.colorContribution";
Z(
  Wh.ID,
  Wh,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
bn.register(Ml);
var wb = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ht = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Hh, Bh;
let un = Hh = class extends P {
  constructor(e, t, i, n, s, o, a) {
    super(), this._editor = e, this._modelService = i, this._keybindingService = n, this._instantiationService = s, this._languageFeatureService = o, this._languageConfigurationService = a, this._standaloneColorPickerWidget = null, this._standaloneColorPickerVisible = b.standaloneColorPickerVisible.bindTo(t), this._standaloneColorPickerFocused = b.standaloneColorPickerFocused.bindTo(t);
  }
  showOrFocus() {
    var e;
    this._editor.hasModel() && (this._standaloneColorPickerVisible.get() ? this._standaloneColorPickerFocused.get() || (e = this._standaloneColorPickerWidget) === null || e === void 0 || e.focus() : this._standaloneColorPickerWidget = new Hl(this._editor, this._standaloneColorPickerVisible, this._standaloneColorPickerFocused, this._instantiationService, this._modelService, this._keybindingService, this._languageFeatureService, this._languageConfigurationService));
  }
  hide() {
    var e;
    this._standaloneColorPickerFocused.set(!1), this._standaloneColorPickerVisible.set(!1), (e = this._standaloneColorPickerWidget) === null || e === void 0 || e.hide(), this._editor.focus();
  }
  insertColor() {
    var e;
    (e = this._standaloneColorPickerWidget) === null || e === void 0 || e.updateEditor(), this.hide();
  }
  static get(e) {
    return e.getContribution(Hh.ID);
  }
};
un.ID = "editor.contrib.standaloneColorPickerController";
un = Hh = wb([
  Ht(1, ee),
  Ht(2, Ge),
  Ht(3, xe),
  Ht(4, q),
  Ht(5, V),
  Ht(6, fe)
], un);
Z(
  un.ID,
  un,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
const kf = 8, xI = 22;
let Hl = Bh = class extends P {
  constructor(e, t, i, n, s, o, a, l) {
    var d;
    super(), this._editor = e, this._standaloneColorPickerVisible = t, this._standaloneColorPickerFocused = i, this._modelService = s, this._keybindingService = o, this._languageFeaturesService = a, this._languageConfigurationService = l, this.allowEditorOverflow = !0, this._position = void 0, this._body = document.createElement("div"), this._colorHover = null, this._selectionSetInEditor = !1, this._onResult = this._register(new G()), this.onResult = this._onResult.event, this._standaloneColorPickerVisible.set(!0), this._standaloneColorPickerParticipant = n.createInstance(xr, this._editor), this._position = (d = this._editor._getViewModel()) === null || d === void 0 ? void 0 : d.getPrimaryCursorState().modelState.position;
    const c = this._editor.getSelection(), h = c ? {
      startLineNumber: c.startLineNumber,
      startColumn: c.startColumn,
      endLineNumber: c.endLineNumber,
      endColumn: c.endColumn
    } : { startLineNumber: 0, endLineNumber: 0, endColumn: 0, startColumn: 0 }, u = this._register(Us(this._body));
    this._register(u.onDidBlur((p) => {
      this.hide();
    })), this._register(u.onDidFocus((p) => {
      this.focus();
    })), this._register(this._editor.onDidChangeCursorPosition(() => {
      this._selectionSetInEditor ? this._selectionSetInEditor = !1 : this.hide();
    })), this._register(this._editor.onMouseMove((p) => {
      var f;
      const m = (f = p.target.element) === null || f === void 0 ? void 0 : f.classList;
      m && m.contains("colorpicker-color-decoration") && this.hide();
    })), this._register(this.onResult((p) => {
      this._render(p.value, p.foundInEditor);
    })), this._start(h), this._body.style.zIndex = "50", this._editor.addContentWidget(this);
  }
  updateEditor() {
    this._colorHover && this._standaloneColorPickerParticipant.updateEditorModel(this._colorHover);
  }
  getId() {
    return Bh.ID;
  }
  getDomNode() {
    return this._body;
  }
  getPosition() {
    if (!this._position)
      return null;
    const e = this._editor.getOption(
      60
      /* EditorOption.hover */
    ).above;
    return {
      position: this._position,
      secondaryPosition: this._position,
      preference: e ? [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ] : [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ],
      positionAffinity: 2
      /* PositionAffinity.None */
    };
  }
  hide() {
    this.dispose(), this._standaloneColorPickerVisible.set(!1), this._standaloneColorPickerFocused.set(!1), this._editor.removeContentWidget(this), this._editor.focus();
  }
  focus() {
    this._standaloneColorPickerFocused.set(!0), this._body.focus();
  }
  async _start(e) {
    const t = await this._computeAsync(e);
    t && this._onResult.fire(new LI(t.result, t.foundInEditor));
  }
  async _computeAsync(e) {
    if (!this._editor.hasModel())
      return null;
    const t = {
      range: e,
      color: { red: 0, green: 0, blue: 0, alpha: 1 }
    }, i = await this._standaloneColorPickerParticipant.createColorHover(t, new Ag(this._modelService, this._languageConfigurationService), this._languageFeaturesService.colorProvider);
    return i ? { result: i.colorHover, foundInEditor: i.foundInEditor } : null;
  }
  _render(e, t) {
    const i = document.createDocumentFragment(), n = this._register(new Al(this._keybindingService));
    let s;
    const o = {
      fragment: i,
      statusBar: n,
      setColorPicker: (m) => s = m,
      onContentsChanged: () => {
      },
      hide: () => this.hide()
    };
    if (this._colorHover = e, this._register(this._standaloneColorPickerParticipant.renderHoverParts(o, [e])), s === void 0)
      return;
    this._body.classList.add("standalone-colorpicker-body"), this._body.style.maxHeight = Math.max(this._editor.getLayoutInfo().height / 4, 250) + "px", this._body.style.maxWidth = Math.max(this._editor.getLayoutInfo().width * 0.66, 500) + "px", this._body.tabIndex = 0, this._body.appendChild(i), s.layout();
    const a = s.body, l = a.saturationBox.domNode.clientWidth, d = a.domNode.clientWidth - l - xI - kf, c = s.body.enterButton;
    c == null || c.onClicked(() => {
      this.updateEditor(), this.hide();
    });
    const h = s.header, u = h.pickedColorNode;
    u.style.width = l + kf + "px";
    const p = h.originalColorNode;
    p.style.width = d + "px";
    const f = s.header.closeButton;
    f == null || f.onClicked(() => {
      this.hide();
    }), t && (c && (c.button.textContent = "Replace"), this._selectionSetInEditor = !0, this._editor.setSelection(e.range)), this._editor.layoutContentWidget(this);
  }
};
Hl.ID = "editor.contrib.standaloneColorPickerWidget";
Hl = Bh = wb([
  Ht(3, q),
  Ht(4, Ge),
  Ht(5, xe),
  Ht(6, V),
  Ht(7, fe)
], Hl);
class LI {
  // The color picker result consists of: an array of color results and a boolean indicating if the color was found in the editor
  constructor(e, t) {
    this.value = e, this.foundInEditor = t;
  }
}
class II extends Kt {
  constructor() {
    super({
      id: "editor.action.showOrFocusStandaloneColorPicker",
      title: {
        ...$("showOrFocusStandaloneColorPicker", "Show or Focus Standalone Color Picker"),
        mnemonicTitle: g({ key: "mishowOrFocusStandaloneColorPicker", comment: ["&& denotes a mnemonic"] }, "&&Show or Focus Standalone Color Picker")
      },
      precondition: void 0,
      menu: [
        { id: E.CommandPalette }
      ]
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = un.get(t)) === null || i === void 0 || i.showOrFocus();
  }
}
class DI extends D {
  constructor() {
    super({
      id: "editor.action.hideColorPicker",
      label: g({
        key: "hideColorPicker",
        comment: [
          "Action that hides the color picker"
        ]
      }, "Hide the Color Picker"),
      alias: "Hide the Color Picker",
      precondition: b.standaloneColorPickerVisible.isEqualTo(!0),
      kbOpts: {
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    var i;
    (i = un.get(t)) === null || i === void 0 || i.hide();
  }
}
class kI extends D {
  constructor() {
    super({
      id: "editor.action.insertColorWithStandaloneColorPicker",
      label: g({
        key: "insertColorWithStandaloneColorPicker",
        comment: [
          "Action that inserts color with standalone color picker"
        ]
      }, "Insert Color with Standalone Color Picker"),
      alias: "Insert Color with Standalone Color Picker",
      precondition: b.standaloneColorPickerFocused.isEqualTo(!0),
      kbOpts: {
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    var i;
    (i = un.get(t)) === null || i === void 0 || i.insertColor();
  }
}
x(DI);
x(kI);
ne(II);
class Ki {
  constructor(e, t, i) {
    this.languageConfigurationService = i, this._selection = e, this._insertSpace = t, this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(e, t, i) {
    if (i < 0)
      return !1;
    const n = t.length, s = e.length;
    if (i + n > s)
      return !1;
    for (let o = 0; o < n; o++) {
      const a = e.charCodeAt(i + o), l = t.charCodeAt(o);
      if (a !== l && !(a >= 65 && a <= 90 && a + 32 === l) && !(l >= 65 && l <= 90 && l + 32 === a))
        return !1;
    }
    return !0;
  }
  _createOperationsForBlockComment(e, t, i, n, s, o) {
    const a = e.startLineNumber, l = e.startColumn, d = e.endLineNumber, c = e.endColumn, h = s.getLineContent(a), u = s.getLineContent(d);
    let p = h.lastIndexOf(t, l - 1 + t.length), f = u.indexOf(i, c - 1 - i.length);
    if (p !== -1 && f !== -1)
      if (a === d)
        h.substring(p + t.length, f).indexOf(i) >= 0 && (p = -1, f = -1);
      else {
        const _ = h.substring(p + t.length), v = u.substring(0, f);
        (_.indexOf(i) >= 0 || v.indexOf(i) >= 0) && (p = -1, f = -1);
      }
    let m;
    p !== -1 && f !== -1 ? (n && p + t.length < h.length && h.charCodeAt(p + t.length) === 32 && (t = t + " "), n && f > 0 && u.charCodeAt(f - 1) === 32 && (i = " " + i, f -= 1), m = Ki._createRemoveBlockCommentOperations(new S(a, p + t.length + 1, d, f + 1), t, i)) : (m = Ki._createAddBlockCommentOperations(e, t, i, this._insertSpace), this._usedEndToken = m.length === 1 ? i : null);
    for (const _ of m)
      o.addTrackedEditOperation(_.range, _.text);
  }
  static _createRemoveBlockCommentOperations(e, t, i) {
    const n = [];
    return S.isEmpty(e) ? n.push(ue.delete(new S(e.startLineNumber, e.startColumn - t.length, e.endLineNumber, e.endColumn + i.length))) : (n.push(ue.delete(new S(e.startLineNumber, e.startColumn - t.length, e.startLineNumber, e.startColumn))), n.push(ue.delete(new S(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn + i.length)))), n;
  }
  static _createAddBlockCommentOperations(e, t, i, n) {
    const s = [];
    return S.isEmpty(e) ? s.push(ue.replace(new S(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), t + "  " + i)) : (s.push(ue.insert(new F(e.startLineNumber, e.startColumn), t + (n ? " " : ""))), s.push(ue.insert(new F(e.endLineNumber, e.endColumn), (n ? " " : "") + i))), s;
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber, n = this._selection.startColumn;
    e.tokenization.tokenizeIfCheap(i);
    const s = e.getLanguageIdAtPosition(i, n), o = this.languageConfigurationService.getLanguageConfiguration(s).comments;
    !o || !o.blockCommentStartToken || !o.blockCommentEndToken || this._createOperationsForBlockComment(this._selection, o.blockCommentStartToken, o.blockCommentEndToken, this._insertSpace, e, t);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations();
    if (i.length === 2) {
      const n = i[0], s = i[1];
      return new z(n.range.endLineNumber, n.range.endColumn, s.range.startLineNumber, s.range.startColumn);
    } else {
      const n = i[0].range, s = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new z(n.endLineNumber, n.endColumn + s, n.endLineNumber, n.endColumn + s);
    }
  }
}
class vi {
  constructor(e, t, i, n, s, o, a) {
    this.languageConfigurationService = e, this._selection = t, this._tabSize = i, this._type = n, this._insertSpace = s, this._selectionId = null, this._deltaColumn = 0, this._moveEndPositionDown = !1, this._ignoreEmptyLines = o, this._ignoreFirstLine = a || !1;
  }
  /**
   * Do an initial pass over the lines and gather info about the line comment string.
   * Returns null if any of the lines doesn't support a line comment string.
   */
  static _gatherPreflightCommentStrings(e, t, i, n) {
    e.tokenization.tokenizeIfCheap(t);
    const s = e.getLanguageIdAtPosition(t, 1), o = n.getLanguageConfiguration(s).comments, a = o ? o.lineCommentToken : null;
    if (!a)
      return null;
    const l = [];
    for (let d = 0, c = i - t + 1; d < c; d++)
      l[d] = {
        ignore: !1,
        commentStr: a,
        commentStrOffset: 0,
        commentStrLength: a.length
      };
    return l;
  }
  /**
   * Analyze lines and decide which lines are relevant and what the toggle should do.
   * Also, build up several offsets and lengths useful in the generation of editor operations.
   */
  static _analyzeLines(e, t, i, n, s, o, a, l) {
    let d = !0, c;
    e === 0 ? c = !0 : e === 1 ? c = !1 : c = !0;
    for (let h = 0, u = n.length; h < u; h++) {
      const p = n[h], f = s + h;
      if (f === s && a) {
        p.ignore = !0;
        continue;
      }
      const m = i.getLineContent(f), _ = nh(m);
      if (_ === -1) {
        p.ignore = o, p.commentStrOffset = m.length;
        continue;
      }
      if (d = !1, p.ignore = !1, p.commentStrOffset = _, c && !Ki._haystackHasNeedleAtOffset(m, p.commentStr, _) && (e === 0 ? c = !1 : e === 1 || (p.ignore = !0)), c && t) {
        const v = _ + p.commentStrLength;
        v < m.length && m.charCodeAt(v) === 32 && (p.commentStrLength += 1);
      }
    }
    if (e === 0 && d) {
      c = !1;
      for (let h = 0, u = n.length; h < u; h++)
        n[h].ignore = !1;
    }
    return {
      supported: !0,
      shouldRemoveComments: c,
      lines: n
    };
  }
  /**
   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
   */
  static _gatherPreflightData(e, t, i, n, s, o, a, l) {
    const d = vi._gatherPreflightCommentStrings(i, n, s, l);
    return d === null ? {
      supported: !1
    } : vi._analyzeLines(e, t, i, d, n, o, a, l);
  }
  /**
   * Given a successful analysis, execute either insert line comments, either remove line comments
   */
  _executeLineComments(e, t, i, n) {
    let s;
    i.shouldRemoveComments ? s = vi._createRemoveLineCommentsOperations(i.lines, n.startLineNumber) : (vi._normalizeInsertionPoint(e, i.lines, n.startLineNumber, this._tabSize), s = this._createAddLineCommentsOperations(i.lines, n.startLineNumber));
    const o = new F(n.positionLineNumber, n.positionColumn);
    for (let a = 0, l = s.length; a < l; a++)
      t.addEditOperation(s[a].range, s[a].text), S.isEmpty(s[a].range) && S.getStartPosition(s[a].range).equals(o) && e.getLineContent(o.lineNumber).length + 1 === o.column && (this._deltaColumn = (s[a].text || "").length);
    this._selectionId = t.trackSelection(n);
  }
  _attemptRemoveBlockComment(e, t, i, n) {
    let s = t.startLineNumber, o = t.endLineNumber;
    const a = n.length + Math.max(e.getLineFirstNonWhitespaceColumn(t.startLineNumber), t.startColumn);
    let l = e.getLineContent(s).lastIndexOf(i, a - 1), d = e.getLineContent(o).indexOf(n, t.endColumn - 1 - i.length);
    return l !== -1 && d === -1 && (d = e.getLineContent(s).indexOf(n, l + i.length), o = s), l === -1 && d !== -1 && (l = e.getLineContent(o).lastIndexOf(i, d), s = o), t.isEmpty() && (l === -1 || d === -1) && (l = e.getLineContent(s).indexOf(i), l !== -1 && (d = e.getLineContent(s).indexOf(n, l + i.length))), l !== -1 && e.getLineContent(s).charCodeAt(l + i.length) === 32 && (i += " "), d !== -1 && e.getLineContent(o).charCodeAt(d - 1) === 32 && (n = " " + n, d -= 1), l !== -1 && d !== -1 ? Ki._createRemoveBlockCommentOperations(new S(s, l + i.length + 1, o, d + 1), i, n) : null;
  }
  /**
   * Given an unsuccessful analysis, delegate to the block comment command
   */
  _executeBlockComment(e, t, i) {
    e.tokenization.tokenizeIfCheap(i.startLineNumber);
    const n = e.getLanguageIdAtPosition(i.startLineNumber, 1), s = this.languageConfigurationService.getLanguageConfiguration(n).comments;
    if (!s || !s.blockCommentStartToken || !s.blockCommentEndToken)
      return;
    const o = s.blockCommentStartToken, a = s.blockCommentEndToken;
    let l = this._attemptRemoveBlockComment(e, i, o, a);
    if (!l) {
      if (i.isEmpty()) {
        const d = e.getLineContent(i.startLineNumber);
        let c = nh(d);
        c === -1 && (c = d.length), l = Ki._createAddBlockCommentOperations(new S(i.startLineNumber, c + 1, i.startLineNumber, d.length + 1), o, a, this._insertSpace);
      } else
        l = Ki._createAddBlockCommentOperations(new S(i.startLineNumber, e.getLineFirstNonWhitespaceColumn(i.startLineNumber), i.endLineNumber, e.getLineMaxColumn(i.endLineNumber)), o, a, this._insertSpace);
      l.length === 1 && (this._deltaColumn = o.length + 1);
    }
    this._selectionId = t.trackSelection(i);
    for (const d of l)
      t.addEditOperation(d.range, d.text);
  }
  getEditOperations(e, t) {
    let i = this._selection;
    if (this._moveEndPositionDown = !1, i.startLineNumber === i.endLineNumber && this._ignoreFirstLine) {
      t.addEditOperation(new S(i.startLineNumber, e.getLineMaxColumn(i.startLineNumber), i.startLineNumber + 1, 1), i.startLineNumber === e.getLineCount() ? "" : `
`), this._selectionId = t.trackSelection(i);
      return;
    }
    i.startLineNumber < i.endLineNumber && i.endColumn === 1 && (this._moveEndPositionDown = !0, i = i.setEndPosition(i.endLineNumber - 1, e.getLineMaxColumn(i.endLineNumber - 1)));
    const n = vi._gatherPreflightData(this._type, this._insertSpace, e, i.startLineNumber, i.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
    return n.supported ? this._executeLineComments(e, t, n, i) : this._executeBlockComment(e, t, i);
  }
  computeCursorState(e, t) {
    let i = t.getTrackedSelection(this._selectionId);
    return this._moveEndPositionDown && (i = i.setEndPosition(i.endLineNumber + 1, 1)), new z(i.selectionStartLineNumber, i.selectionStartColumn + this._deltaColumn, i.positionLineNumber, i.positionColumn + this._deltaColumn);
  }
  /**
   * Generate edit operations in the remove line comment case
   */
  static _createRemoveLineCommentsOperations(e, t) {
    const i = [];
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      o.ignore || i.push(ue.delete(new S(t + n, o.commentStrOffset + 1, t + n, o.commentStrOffset + o.commentStrLength + 1)));
    }
    return i;
  }
  /**
   * Generate edit operations in the add line comment case
   */
  _createAddLineCommentsOperations(e, t) {
    const i = [], n = this._insertSpace ? " " : "";
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      a.ignore || i.push(ue.insert(new F(t + s, a.commentStrOffset + 1), a.commentStr + n));
    }
    return i;
  }
  static nextVisibleColumn(e, t, i, n) {
    return i ? e + (t - e % t) : e + n;
  }
  /**
   * Adjust insertion points to have them vertically aligned in the add line comment case
   */
  static _normalizeInsertionPoint(e, t, i, n) {
    let s = 1073741824, o, a;
    for (let l = 0, d = t.length; l < d; l++) {
      if (t[l].ignore)
        continue;
      const c = e.getLineContent(i + l);
      let h = 0;
      for (let u = 0, p = t[l].commentStrOffset; h < s && u < p; u++)
        h = vi.nextVisibleColumn(h, n, c.charCodeAt(u) === 9, 1);
      h < s && (s = h);
    }
    s = Math.floor(s / n) * n;
    for (let l = 0, d = t.length; l < d; l++) {
      if (t[l].ignore)
        continue;
      const c = e.getLineContent(i + l);
      let h = 0;
      for (o = 0, a = t[l].commentStrOffset; h < s && o < a; o++)
        h = vi.nextVisibleColumn(h, n, c.charCodeAt(o) === 9, 1);
      h > s ? t[l].commentStrOffset = o - 1 : t[l].commentStrOffset = o;
    }
  }
}
class Ug extends D {
  constructor(e, t) {
    super(t), this._type = e;
  }
  run(e, t) {
    const i = e.get(fe);
    if (!t.hasModel())
      return;
    const n = t.getModel(), s = [], o = n.getOptions(), a = t.getOption(
      23
      /* EditorOption.comments */
    ), l = t.getSelections().map((c, h) => ({ selection: c, index: h, ignoreFirstLine: !1 }));
    l.sort((c, h) => S.compareRangesUsingStarts(c.selection, h.selection));
    let d = l[0];
    for (let c = 1; c < l.length; c++) {
      const h = l[c];
      d.selection.endLineNumber === h.selection.startLineNumber && (d.index < h.index ? h.ignoreFirstLine = !0 : (d.ignoreFirstLine = !0, d = h));
    }
    for (const c of l)
      s.push(new vi(i, c.selection, o.tabSize, this._type, a.insertSpace, a.ignoreEmptyLines, c.ignoreFirstLine));
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
class NI extends Ug {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: g("comment.line", "Toggle Line Comment"),
      alias: "Toggle Line Comment",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 2138,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarEditMenu,
        group: "5_insert",
        title: g({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
}
class RI extends Ug {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: g("comment.line.add", "Add Line Comment"),
      alias: "Add Line Comment",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2081
          /* KeyCode.KeyC */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class PI extends Ug {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: g("comment.line.remove", "Remove Line Comment"),
      alias: "Remove Line Comment",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2099
          /* KeyCode.KeyU */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class MI extends D {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: g("comment.block", "Toggle Block Comment"),
      alias: "Toggle Block Comment",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 1567,
        linux: {
          primary: 3103
          /* KeyCode.KeyA */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarEditMenu,
        group: "5_insert",
        title: g({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(e, t) {
    const i = e.get(fe);
    if (!t.hasModel())
      return;
    const n = t.getOption(
      23
      /* EditorOption.comments */
    ), s = [], o = t.getSelections();
    for (const a of o)
      s.push(new Ki(a, n.insertSpace, i));
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
x(NI);
x(RI);
x(PI);
x(MI);
var EI = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, xn = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Vh;
let to = Vh = class {
  static get(e) {
    return e.getContribution(Vh.ID);
  }
  constructor(e, t, i, n, s, o, a, l) {
    this._contextMenuService = t, this._contextViewService = i, this._contextKeyService = n, this._keybindingService = s, this._menuService = o, this._configurationService = a, this._workspaceContextService = l, this._toDispose = new M(), this._contextMenuIsBeingShownCount = 0, this._editor = e, this._toDispose.add(this._editor.onContextMenu((d) => this._onContextMenu(d))), this._toDispose.add(this._editor.onMouseWheel((d) => {
      if (this._contextMenuIsBeingShownCount > 0) {
        const c = this._contextViewService.getContextViewElement(), h = d.srcElement;
        h.shadowRoot && US(c) === h.shadowRoot || this._contextViewService.hideContextView();
      }
    })), this._toDispose.add(this._editor.onKeyDown((d) => {
      this._editor.getOption(
        24
        /* EditorOption.contextmenu */
      ) && d.keyCode === 58 && (d.preventDefault(), d.stopPropagation(), this.showContextMenu());
    }));
  }
  _onContextMenu(e) {
    if (!this._editor.hasModel())
      return;
    if (!this._editor.getOption(
      24
      /* EditorOption.contextmenu */
    )) {
      this._editor.focus(), e.target.position && !this._editor.getSelection().containsPosition(e.target.position) && this._editor.setPosition(e.target.position);
      return;
    }
    if (e.target.type === 12 || e.target.type === 6 && e.target.detail.injectedText)
      return;
    if (e.event.preventDefault(), e.event.stopPropagation(), e.target.type === 11)
      return this._showScrollbarContextMenu(e.event);
    if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1)
      return;
    if (this._editor.focus(), e.target.position) {
      let i = !1;
      for (const n of this._editor.getSelections())
        if (n.containsPosition(e.target.position)) {
          i = !0;
          break;
        }
      i || this._editor.setPosition(e.target.position);
    }
    let t = null;
    e.target.type !== 1 && (t = e.event), this.showContextMenu(t);
  }
  showContextMenu(e) {
    if (!this._editor.getOption(
      24
      /* EditorOption.contextmenu */
    ) || !this._editor.hasModel())
      return;
    const t = this._getMenuActions(this._editor.getModel(), this._editor.isSimpleWidget ? E.SimpleEditorContext : E.EditorContext);
    t.length > 0 && this._doShowContextMenu(t, e);
  }
  _getMenuActions(e, t) {
    const i = [], n = this._menuService.createMenu(t, this._contextKeyService), s = n.getActions({ arg: e.uri });
    n.dispose();
    for (const o of s) {
      const [, a] = o;
      let l = 0;
      for (const d of a)
        if (d instanceof zS) {
          const c = this._getMenuActions(e, d.item.submenu);
          c.length > 0 && (i.push(new Rp(d.id, d.label, c)), l++);
        } else
          i.push(d), l++;
      l && i.push(new vr());
    }
    return i.length && i.pop(), i;
  }
  _doShowContextMenu(e, t = null) {
    if (!this._editor.hasModel())
      return;
    const i = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._editor.updateOptions({
      hover: {
        enabled: !1
      }
    });
    let n = t;
    if (!n) {
      this._editor.revealPosition(
        this._editor.getPosition(),
        1
        /* ScrollType.Immediate */
      ), this._editor.render();
      const o = this._editor.getScrolledVisiblePosition(this._editor.getPosition()), a = mt(this._editor.getDomNode()), l = a.left + o.left, d = a.top + o.top + o.height;
      n = { x: l, y: d };
    }
    const s = this._editor.getOption(
      127
      /* EditorOption.useShadowDOM */
    ) && !sh;
    this._contextMenuIsBeingShownCount++, this._contextMenuService.showContextMenu({
      domForShadowRoot: s ? this._editor.getDomNode() : void 0,
      getAnchor: () => n,
      getActions: () => e,
      getActionViewItem: (o) => {
        const a = this._keybindingFor(o);
        if (a)
          return new ih(o, o, { label: !0, keybinding: a.getLabel(), isMenu: !0 });
        const l = o;
        return typeof l.getActionViewItem == "function" ? l.getActionViewItem() : new ih(o, o, { icon: !0, label: !0, isMenu: !0 });
      },
      getKeyBinding: (o) => this._keybindingFor(o),
      onHide: (o) => {
        this._contextMenuIsBeingShownCount--, this._editor.updateOptions({
          hover: i
        });
      }
    });
  }
  _showScrollbarContextMenu(e) {
    if (!this._editor.hasModel() || $S(this._workspaceContextService.getWorkspace()))
      return;
    const t = this._editor.getOption(
      73
      /* EditorOption.minimap */
    );
    let i = 0;
    const n = (d) => ({
      id: `menu-action-${++i}`,
      label: d.label,
      tooltip: "",
      class: void 0,
      enabled: typeof d.enabled > "u" ? !0 : d.enabled,
      checked: d.checked,
      run: d.run
    }), s = (d, c) => new Rp(`menu-action-${++i}`, d, c, void 0), o = (d, c, h, u, p) => {
      if (!c)
        return n({ label: d, enabled: c, run: () => {
        } });
      const f = (_) => () => {
        this._configurationService.updateValue(h, _);
      }, m = [];
      for (const _ of p)
        m.push(n({
          label: _.label,
          checked: u === _.value,
          run: f(_.value)
        }));
      return s(d, m);
    }, a = [];
    a.push(n({
      label: g("context.minimap.minimap", "Minimap"),
      checked: t.enabled,
      run: () => {
        this._configurationService.updateValue("editor.minimap.enabled", !t.enabled);
      }
    })), a.push(new vr()), a.push(n({
      label: g("context.minimap.renderCharacters", "Render Characters"),
      enabled: t.enabled,
      checked: t.renderCharacters,
      run: () => {
        this._configurationService.updateValue("editor.minimap.renderCharacters", !t.renderCharacters);
      }
    })), a.push(o(g("context.minimap.size", "Vertical size"), t.enabled, "editor.minimap.size", t.size, [{
      label: g("context.minimap.size.proportional", "Proportional"),
      value: "proportional"
    }, {
      label: g("context.minimap.size.fill", "Fill"),
      value: "fill"
    }, {
      label: g("context.minimap.size.fit", "Fit"),
      value: "fit"
    }])), a.push(o(g("context.minimap.slider", "Slider"), t.enabled, "editor.minimap.showSlider", t.showSlider, [{
      label: g("context.minimap.slider.mouseover", "Mouse Over"),
      value: "mouseover"
    }, {
      label: g("context.minimap.slider.always", "Always"),
      value: "always"
    }]));
    const l = this._editor.getOption(
      127
      /* EditorOption.useShadowDOM */
    ) && !sh;
    this._contextMenuIsBeingShownCount++, this._contextMenuService.showContextMenu({
      domForShadowRoot: l ? this._editor.getDomNode() : void 0,
      getAnchor: () => e,
      getActions: () => a,
      onHide: (d) => {
        this._contextMenuIsBeingShownCount--, this._editor.focus();
      }
    });
  }
  _keybindingFor(e) {
    return this._keybindingService.lookupKeybinding(e.id);
  }
  dispose() {
    this._contextMenuIsBeingShownCount > 0 && this._contextViewService.hideContextView(), this._toDispose.dispose();
  }
};
to.ID = "editor.contrib.contextmenu";
to = Vh = EI([
  xn(1, co),
  xn(2, sd),
  xn(3, ee),
  xn(4, xe),
  xn(5, is),
  xn(6, he),
  xn(7, Zs)
], to);
class TI extends D {
  constructor() {
    super({
      id: "editor.action.showContextMenu",
      label: g("action.showContextMenu.label", "Show Editor Context Menu"),
      alias: "Show Editor Context Menu",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 1092,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    var i;
    (i = to.get(t)) === null || i === void 0 || i.showContextMenu();
  }
}
Z(
  to.ID,
  to,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
x(TI);
class Tc {
  constructor(e) {
    this.selections = e;
  }
  equals(e) {
    const t = this.selections.length, i = e.selections.length;
    if (t !== i)
      return !1;
    for (let n = 0; n < t; n++)
      if (!this.selections[n].equalsSelection(e.selections[n]))
        return !1;
    return !0;
  }
}
class Ac {
  constructor(e, t, i) {
    this.cursorState = e, this.scrollTop = t, this.scrollLeft = i;
  }
}
class Gn extends P {
  static get(e) {
    return e.getContribution(Gn.ID);
  }
  constructor(e) {
    super(), this._editor = e, this._isCursorUndoRedo = !1, this._undoStack = [], this._redoStack = [], this._register(e.onDidChangeModel((t) => {
      this._undoStack = [], this._redoStack = [];
    })), this._register(e.onDidChangeModelContent((t) => {
      this._undoStack = [], this._redoStack = [];
    })), this._register(e.onDidChangeCursorSelection((t) => {
      if (this._isCursorUndoRedo || !t.oldSelections || t.oldModelVersionId !== t.modelVersionId)
        return;
      const i = new Tc(t.oldSelections);
      this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(i) || (this._undoStack.push(new Ac(i, e.getScrollTop(), e.getScrollLeft())), this._redoStack = [], this._undoStack.length > 50 && this._undoStack.shift());
    }));
  }
  cursorUndo() {
    !this._editor.hasModel() || this._undoStack.length === 0 || (this._redoStack.push(new Ac(new Tc(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft())), this._applyState(this._undoStack.pop()));
  }
  cursorRedo() {
    !this._editor.hasModel() || this._redoStack.length === 0 || (this._undoStack.push(new Ac(new Tc(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft())), this._applyState(this._redoStack.pop()));
  }
  _applyState(e) {
    this._isCursorUndoRedo = !0, this._editor.setSelections(e.cursorState.selections), this._editor.setScrollPosition({
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft
    }), this._isCursorUndoRedo = !1;
  }
}
Gn.ID = "editor.contrib.cursorUndoRedoController";
class AI extends D {
  constructor() {
    super({
      id: "cursorUndo",
      label: g("cursor.undo", "Cursor Undo"),
      alias: "Cursor Undo",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 2099,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    var n;
    (n = Gn.get(t)) === null || n === void 0 || n.cursorUndo();
  }
}
class OI extends D {
  constructor() {
    super({
      id: "cursorRedo",
      label: g("cursor.redo", "Cursor Redo"),
      alias: "Cursor Redo",
      precondition: void 0
    });
  }
  run(e, t, i) {
    var n;
    (n = Gn.get(t)) === null || n === void 0 || n.cursorRedo();
  }
}
Z(
  Gn.ID,
  Gn,
  0
  /* EditorContributionInstantiation.Eager */
);
x(AI);
x(OI);
class FI {
  constructor(e, t, i) {
    this.selection = e, this.targetPosition = t, this.copy = i, this.targetSelection = null;
  }
  getEditOperations(e, t) {
    const i = e.getValueInRange(this.selection);
    if (this.copy || t.addEditOperation(this.selection, null), t.addEditOperation(new S(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), i), this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
      this.targetSelection = this.selection;
      return;
    }
    if (this.copy) {
      this.targetSelection = new z(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
      this.targetSelection = new z(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
      this.targetSelection = new z(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    this.selection.endColumn <= this.targetPosition.column ? this.targetSelection = new z(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn) : this.targetSelection = new z(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
  }
  computeCursorState(e, t) {
    return this.targetSelection;
  }
}
function ps(r) {
  return si ? r.altKey : r.ctrlKey;
}
class yi extends P {
  constructor(e) {
    super(), this._editor = e, this._dndDecorationIds = this._editor.createDecorationsCollection(), this._register(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._register(this._editor.onMouseUp((t) => this._onEditorMouseUp(t))), this._register(this._editor.onMouseDrag((t) => this._onEditorMouseDrag(t))), this._register(this._editor.onMouseDrop((t) => this._onEditorMouseDrop(t))), this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled())), this._register(this._editor.onKeyDown((t) => this.onEditorKeyDown(t))), this._register(this._editor.onKeyUp((t) => this.onEditorKeyUp(t))), this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur())), this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur())), this._mouseDown = !1, this._modifierPressed = !1, this._dragSelection = null;
  }
  onEditorBlur() {
    this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1, this._modifierPressed = !1;
  }
  onEditorKeyDown(e) {
    !this._editor.getOption(
      35
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      22
      /* EditorOption.columnSelection */
    ) || (ps(e) && (this._modifierPressed = !0), this._mouseDown && ps(e) && this._editor.updateOptions({
      mouseStyle: "copy"
    }));
  }
  onEditorKeyUp(e) {
    !this._editor.getOption(
      35
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      22
      /* EditorOption.columnSelection */
    ) || (ps(e) && (this._modifierPressed = !1), this._mouseDown && e.keyCode === yi.TRIGGER_KEY_VALUE && this._editor.updateOptions({
      mouseStyle: "default"
    }));
  }
  _onEditorMouseDown(e) {
    this._mouseDown = !0;
  }
  _onEditorMouseUp(e) {
    this._mouseDown = !1, this._editor.updateOptions({
      mouseStyle: "text"
    });
  }
  _onEditorMouseDrag(e) {
    const t = e.target;
    if (this._dragSelection === null) {
      const n = (this._editor.getSelections() || []).filter((s) => t.position && s.containsPosition(t.position));
      if (n.length === 1)
        this._dragSelection = n[0];
      else
        return;
    }
    ps(e.event) ? this._editor.updateOptions({
      mouseStyle: "copy"
    }) : this._editor.updateOptions({
      mouseStyle: "default"
    }), t.position && (this._dragSelection.containsPosition(t.position) ? this._removeDecoration() : this.showAt(t.position));
  }
  _onEditorMouseDropCanceled() {
    this._editor.updateOptions({
      mouseStyle: "text"
    }), this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1;
  }
  _onEditorMouseDrop(e) {
    if (e.target && (this._hitContent(e.target) || this._hitMargin(e.target)) && e.target.position) {
      const t = new F(e.target.position.lineNumber, e.target.position.column);
      if (this._dragSelection === null) {
        let i = null;
        if (e.event.shiftKey) {
          const n = this._editor.getSelection();
          if (n) {
            const { selectionStartLineNumber: s, selectionStartColumn: o } = n;
            i = [new z(s, o, t.lineNumber, t.column)];
          }
        } else
          i = (this._editor.getSelections() || []).map((n) => n.containsPosition(t) ? new z(t.lineNumber, t.column, t.lineNumber, t.column) : n);
        this._editor.setSelections(
          i || [],
          "mouse",
          3
          /* CursorChangeReason.Explicit */
        );
      } else
        (!this._dragSelection.containsPosition(t) || (ps(e.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(t) || this._dragSelection.getStartPosition().equals(t))) && (this._editor.pushUndoStop(), this._editor.executeCommand(yi.ID, new FI(this._dragSelection, t, ps(e.event) || this._modifierPressed)), this._editor.pushUndoStop());
    }
    this._editor.updateOptions({
      mouseStyle: "text"
    }), this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1;
  }
  showAt(e) {
    this._dndDecorationIds.set([{
      range: new S(e.lineNumber, e.column, e.lineNumber, e.column),
      options: yi._DECORATION_OPTIONS
    }]), this._editor.revealPosition(
      e,
      1
      /* ScrollType.Immediate */
    );
  }
  _removeDecoration() {
    this._dndDecorationIds.clear();
  }
  _hitContent(e) {
    return e.type === 6 || e.type === 7;
  }
  _hitMargin(e) {
    return e.type === 2 || e.type === 3 || e.type === 4;
  }
  dispose() {
    this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1, this._modifierPressed = !1, super.dispose();
  }
}
yi.ID = "editor.contrib.dragAndDrop";
yi.TRIGGER_KEY_VALUE = si ? 6 : 5;
yi._DECORATION_OPTIONS = Y.register({
  description: "dnd-target",
  className: "dnd-target"
});
Z(
  yi.ID,
  yi,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
var zg = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, kr = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Td = g("builtIn", "Built-in");
class $g {
  async provideDocumentPasteEdits(e, t, i, n, s) {
    const o = await this.getEdit(i, s);
    return o ? { insertText: o.insertText, label: o.label, detail: o.detail, handledMimeType: o.handledMimeType, yieldTo: o.yieldTo } : void 0;
  }
  async provideDocumentOnDropEdits(e, t, i, n) {
    const s = await this.getEdit(i, n);
    return s ? { insertText: s.insertText, label: s.label, handledMimeType: s.handledMimeType, yieldTo: s.yieldTo } : void 0;
  }
}
class yb extends $g {
  constructor() {
    super(...arguments), this.id = "text", this.dropMimeTypes = [Te.text], this.pasteMimeTypes = [Te.text];
  }
  async getEdit(e, t) {
    const i = e.get(Te.text);
    if (!i || e.has(Te.uriList))
      return;
    const n = await i.asString();
    return {
      handledMimeType: Te.text,
      label: g("text.label", "Insert Plain Text"),
      detail: Td,
      insertText: n
    };
  }
}
class xb extends $g {
  constructor() {
    super(...arguments), this.id = "uri", this.dropMimeTypes = [Te.uriList], this.pasteMimeTypes = [Te.uriList];
  }
  async getEdit(e, t) {
    const i = await Lb(e);
    if (!i.length || t.isCancellationRequested)
      return;
    let n = 0;
    const s = i.map(({ uri: a, originalText: l }) => a.scheme === wt.file ? a.fsPath : (n++, l)).join(" ");
    let o;
    return n > 0 ? o = i.length > 1 ? g("defaultDropProvider.uriList.uris", "Insert Uris") : g("defaultDropProvider.uriList.uri", "Insert Uri") : o = i.length > 1 ? g("defaultDropProvider.uriList.paths", "Insert Paths") : g("defaultDropProvider.uriList.path", "Insert Path"), {
      handledMimeType: Te.uriList,
      insertText: s,
      label: o,
      detail: Td
    };
  }
}
let Bl = class extends $g {
  constructor(e) {
    super(), this._workspaceContextService = e, this.id = "relativePath", this.dropMimeTypes = [Te.uriList], this.pasteMimeTypes = [Te.uriList];
  }
  async getEdit(e, t) {
    const i = await Lb(e);
    if (!i.length || t.isCancellationRequested)
      return;
    const n = Ii(i.map(({ uri: s }) => {
      const o = this._workspaceContextService.getWorkspaceFolder(s);
      return o ? jS(o.uri, s) : void 0;
    }));
    if (n.length)
      return {
        handledMimeType: Te.uriList,
        insertText: n.join(" "),
        label: i.length > 1 ? g("defaultDropProvider.uriList.relativePaths", "Insert Relative Paths") : g("defaultDropProvider.uriList.relativePath", "Insert Relative Path"),
        detail: Td
      };
  }
};
Bl = zg([
  kr(0, Zs)
], Bl);
class WI {
  constructor() {
    this.id = "html", this.pasteMimeTypes = ["text/html"], this._yieldTo = [{ mimeType: Te.text }];
  }
  async provideDocumentPasteEdits(e, t, i, n, s) {
    if (n.trigger !== "explicit" && n.only !== this.id)
      return;
    const o = i.get("text/html"), a = await (o == null ? void 0 : o.asString());
    if (!(!a || s.isCancellationRequested))
      return {
        insertText: a,
        yieldTo: this._yieldTo,
        label: g("pasteHtmlLabel", "Insert HTML"),
        detail: Td
      };
  }
}
async function Lb(r) {
  const e = r.get(Te.uriList);
  if (!e)
    return [];
  const t = await e.asString(), i = [];
  for (const n of yd.parse(t))
    try {
      i.push({ uri: ce.parse(n), originalText: n });
    } catch {
    }
  return i;
}
let Uh = class extends P {
  constructor(e, t) {
    super(), this._register(e.documentOnDropEditProvider.register("*", new yb())), this._register(e.documentOnDropEditProvider.register("*", new xb())), this._register(e.documentOnDropEditProvider.register("*", new Bl(t)));
  }
};
Uh = zg([
  kr(0, V),
  kr(1, Zs)
], Uh);
let zh = class extends P {
  constructor(e, t) {
    super(), this._register(e.documentPasteEditProvider.register("*", new yb())), this._register(e.documentPasteEditProvider.register("*", new xb())), this._register(e.documentPasteEditProvider.register("*", new Bl(t))), this._register(e.documentPasteEditProvider.register("*", new WI()));
  }
};
zh = zg([
  kr(0, V),
  kr(1, Zs)
], zh);
Z(
  Ri.ID,
  Ri,
  0
  /* EditorContributionInstantiation.Eager */
);
Jr(zh);
B(new class extends bt {
  constructor() {
    super({
      id: Iv,
      precondition: Dv,
      kbOpts: {
        weight: 100,
        primary: 2137
      }
    });
  }
  runEditorCommand(r, e, t) {
    var i;
    return (i = Ri.get(e)) === null || i === void 0 ? void 0 : i.changePasteType();
  }
}());
x(class extends D {
  constructor() {
    super({
      id: "editor.action.pasteAs",
      label: g("pasteAs", "Paste As..."),
      alias: "Paste As...",
      precondition: b.writable,
      metadata: {
        description: "Paste as",
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              id: {
                type: "string",
                description: g("pasteAs.id", "The id of the paste edit to try applying. If not provided, the editor will show a picker.")
              }
            }
          }
        }]
      }
    });
  }
  run(r, e, t) {
    var i;
    const n = typeof (t == null ? void 0 : t.id) == "string" ? t.id : void 0;
    return (i = Ri.get(e)) === null || i === void 0 ? void 0 : i.pasteAs(n);
  }
});
x(class extends D {
  constructor() {
    super({
      id: "editor.action.pasteAsText",
      label: g("pasteAsText", "Paste as Text"),
      alias: "Paste as Text",
      precondition: b.writable
    });
  }
  run(r, e, t) {
    var i;
    return (i = Ri.get(e)) === null || i === void 0 ? void 0 : i.pasteAs("text");
  }
});
class HI {
  constructor() {
    this._dragOperations = /* @__PURE__ */ new Map();
  }
  removeDragOperationTransfer(e) {
    if (e && this._dragOperations.has(e)) {
      const t = this._dragOperations.get(e);
      return this._dragOperations.delete(e), t;
    }
  }
}
class Nf {
  constructor(e) {
    this.identifier = e;
  }
}
const Ib = Ti("treeViewsDndService");
Ai(
  Ib,
  HI,
  1
  /* InstantiationType.Delayed */
);
var BI = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ba = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, $h;
const Db = "editor.experimental.dropIntoEditor.defaultProvider", kb = "editor.changeDropType", Nb = new Q("dropWidgetVisible", !1, g("dropWidgetVisible", "Whether the drop widget is showing"));
let io = $h = class extends P {
  static get(e) {
    return e.getContribution($h.ID);
  }
  constructor(e, t, i, n, s) {
    super(), this._configService = i, this._languageFeaturesService = n, this._treeViewsDragAndDropService = s, this.treeItemsTransfer = Sr.getInstance(), this._dropProgressManager = this._register(t.createInstance(kl, "dropIntoEditor", e)), this._postDropWidgetManager = this._register(t.createInstance(Rl, "dropIntoEditor", e, Nb, { id: kb, label: g("postDropWidgetTitle", "Show drop options...") })), this._register(e.onDropIntoEditor((o) => this.onDropIntoEditor(e, o.position, o.event)));
  }
  changeDropType() {
    this._postDropWidgetManager.tryShowSelector();
  }
  async onDropIntoEditor(e, t, i) {
    var n;
    if (!i.dataTransfer || !e.hasModel())
      return;
    (n = this._currentOperation) === null || n === void 0 || n.cancel(), e.focus(), e.setPosition(t);
    const s = Pe(async (o) => {
      const a = new Vs(e, 1, void 0, o);
      try {
        const l = await this.extractDataTransferData(i);
        if (l.size === 0 || a.token.isCancellationRequested)
          return;
        const d = e.getModel();
        if (!d)
          return;
        const c = this._languageFeaturesService.documentOnDropEditProvider.ordered(d).filter((u) => u.dropMimeTypes ? u.dropMimeTypes.some((p) => l.matches(p)) : !0), h = await this.getDropEdits(c, d, t, l, a);
        if (a.token.isCancellationRequested)
          return;
        if (h.length) {
          const u = this.getInitialActiveEditIndex(d, h), p = e.getOption(
            36
            /* EditorOption.dropIntoEditor */
          ).showDropSelector === "afterDrop";
          await this._postDropWidgetManager.applyEditAndShowIfNeeded([S.fromPositions(t)], { activeEditIndex: u, allEdits: h }, p, o);
        }
      } finally {
        a.dispose(), this._currentOperation === s && (this._currentOperation = void 0);
      }
    });
    this._dropProgressManager.showWhile(t, g("dropIntoEditorProgress", "Running drop handlers. Click to cancel"), s), this._currentOperation = s;
  }
  async getDropEdits(e, t, i, n, s) {
    const o = await Zr(Promise.all(e.map(async (l) => {
      try {
        const d = await l.provideDocumentOnDropEdits(t, i, n, s.token);
        if (d)
          return { ...d, providerId: l.id };
      } catch (d) {
        console.error(d);
      }
    })), s.token), a = Ii(o ?? []);
    return xv(a);
  }
  getInitialActiveEditIndex(e, t) {
    const i = this._configService.getValue(Db, { resource: e.uri });
    for (const [n, s] of Object.entries(i)) {
      const o = t.findIndex((a) => s === a.providerId && a.handledMimeType && vv(n, [a.handledMimeType]));
      if (o >= 0)
        return o;
    }
    return 0;
  }
  async extractDataTransferData(e) {
    if (!e.dataTransfer)
      return new _v();
    const t = Sv(e.dataTransfer);
    if (this.treeItemsTransfer.hasData(Nf.prototype)) {
      const i = this.treeItemsTransfer.getData(Nf.prototype);
      if (Array.isArray(i))
        for (const n of i) {
          const s = await this._treeViewsDragAndDropService.removeDragOperationTransfer(n.identifier);
          if (s)
            for (const [o, a] of s)
              t.replace(o, a);
        }
    }
    return t;
  }
};
io.ID = "editor.contrib.dropIntoEditorController";
io = $h = BI([
  Ba(1, q),
  Ba(2, he),
  Ba(3, V),
  Ba(4, Ib)
], io);
Z(
  io.ID,
  io,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
B(new class extends bt {
  constructor() {
    super({
      id: kb,
      precondition: Nb,
      kbOpts: {
        weight: 100,
        primary: 2137
      }
    });
  }
  runEditorCommand(r, e, t) {
    var i;
    (i = io.get(e)) === null || i === void 0 || i.changeDropType();
  }
}());
Jr(Uh);
hi.as(rd.Configuration).registerConfiguration({
  ...ng,
  properties: {
    [Db]: {
      type: "object",
      scope: 5,
      description: g("defaultProviderDescription", "Configures the default drop provider to use for content of a given mime type."),
      default: {},
      additionalProperties: {
        type: "string"
      }
    }
  }
});
class He {
  constructor(e) {
    this._editor = e, this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null, this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.removeDecorations(this._allDecorations()), this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  /** @deprecated use getFindScopes to support multiple selections */
  getFindScope() {
    return this._findScopeDecorationIds[0] ? this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]) : null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const e = this._findScopeDecorationIds.map((t) => this._editor.getModel().getDecorationRange(t)).filter((t) => !!t);
      if (e.length)
        return e;
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(e) {
    this._startPosition = e, this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(e) {
    const t = this._decorations.indexOf(e);
    return t >= 0 ? t + 1 : 1;
  }
  getDecorationRangeAt(e) {
    const t = e < this._decorations.length ? this._decorations[e] : null;
    return t ? this._editor.getModel().getDecorationRange(t) : null;
  }
  getCurrentMatchesPosition(e) {
    const t = this._editor.getModel().getDecorationsInRange(e);
    for (const i of t) {
      const n = i.options;
      if (n === He._FIND_MATCH_DECORATION || n === He._CURRENT_FIND_MATCH_DECORATION)
        return this._getDecorationIndex(i.id);
    }
    return 0;
  }
  setCurrentFindMatch(e) {
    let t = null, i = 0;
    if (e)
      for (let n = 0, s = this._decorations.length; n < s; n++) {
        const o = this._editor.getModel().getDecorationRange(this._decorations[n]);
        if (e.equalsRange(o)) {
          t = this._decorations[n], i = n + 1;
          break;
        }
      }
    return (this._highlightedDecorationId !== null || t !== null) && this._editor.changeDecorations((n) => {
      if (this._highlightedDecorationId !== null && (n.changeDecorationOptions(this._highlightedDecorationId, He._FIND_MATCH_DECORATION), this._highlightedDecorationId = null), t !== null && (this._highlightedDecorationId = t, n.changeDecorationOptions(this._highlightedDecorationId, He._CURRENT_FIND_MATCH_DECORATION)), this._rangeHighlightDecorationId !== null && (n.removeDecoration(this._rangeHighlightDecorationId), this._rangeHighlightDecorationId = null), t !== null) {
        let s = this._editor.getModel().getDecorationRange(t);
        if (s.startLineNumber !== s.endLineNumber && s.endColumn === 1) {
          const o = s.endLineNumber - 1, a = this._editor.getModel().getLineMaxColumn(o);
          s = new S(s.startLineNumber, s.startColumn, o, a);
        }
        this._rangeHighlightDecorationId = n.addDecoration(s, He._RANGE_HIGHLIGHT_DECORATION);
      }
    }), i;
  }
  set(e, t) {
    this._editor.changeDecorations((i) => {
      let n = He._FIND_MATCH_DECORATION;
      const s = [];
      if (e.length > 1e3) {
        n = He._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const a = this._editor.getModel().getLineCount(), d = this._editor.getLayoutInfo().height / a, c = Math.max(2, Math.ceil(3 / d));
        let h = e[0].range.startLineNumber, u = e[0].range.endLineNumber;
        for (let p = 1, f = e.length; p < f; p++) {
          const m = e[p].range;
          u + c >= m.startLineNumber ? m.endLineNumber > u && (u = m.endLineNumber) : (s.push({
            range: new S(h, 1, u, 1),
            options: He._FIND_MATCH_ONLY_OVERVIEW_DECORATION
          }), h = m.startLineNumber, u = m.endLineNumber);
        }
        s.push({
          range: new S(h, 1, u, 1),
          options: He._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      const o = new Array(e.length);
      for (let a = 0, l = e.length; a < l; a++)
        o[a] = {
          range: e[a].range,
          options: n
        };
      this._decorations = i.deltaDecorations(this._decorations, o), this._overviewRulerApproximateDecorations = i.deltaDecorations(this._overviewRulerApproximateDecorations, s), this._rangeHighlightDecorationId && (i.removeDecoration(this._rangeHighlightDecorationId), this._rangeHighlightDecorationId = null), this._findScopeDecorationIds.length && (this._findScopeDecorationIds.forEach((a) => i.removeDecoration(a)), this._findScopeDecorationIds = []), t != null && t.length && (this._findScopeDecorationIds = t.map((a) => i.addDecoration(a, He._FIND_SCOPE_DECORATION)));
    });
  }
  matchBeforePosition(e) {
    if (this._decorations.length === 0)
      return null;
    for (let t = this._decorations.length - 1; t >= 0; t--) {
      const i = this._decorations[t], n = this._editor.getModel().getDecorationRange(i);
      if (!(!n || n.endLineNumber > e.lineNumber)) {
        if (n.endLineNumber < e.lineNumber)
          return n;
        if (!(n.endColumn > e.column))
          return n;
      }
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(e) {
    if (this._decorations.length === 0)
      return null;
    for (let t = 0, i = this._decorations.length; t < i; t++) {
      const n = this._decorations[t], s = this._editor.getModel().getDecorationRange(n);
      if (!(!s || s.startLineNumber < e.lineNumber)) {
        if (s.startLineNumber > e.lineNumber)
          return s;
        if (!(s.startColumn < e.column))
          return s;
      }
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let e = [];
    return e = e.concat(this._decorations), e = e.concat(this._overviewRulerApproximateDecorations), this._findScopeDecorationIds.length && e.push(...this._findScopeDecorationIds), this._rangeHighlightDecorationId && e.push(this._rangeHighlightDecorationId), e;
  }
}
He._CURRENT_FIND_MATCH_DECORATION = Y.register({
  description: "current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  showIfCollapsed: !0,
  overviewRuler: {
    color: Se(pg),
    position: ci.Center
  },
  minimap: {
    color: Se(s_),
    position: ns.Inline
  }
});
He._FIND_MATCH_DECORATION = Y.register({
  description: "find-match",
  stickiness: 1,
  zIndex: 10,
  className: "findMatch",
  showIfCollapsed: !0,
  overviewRuler: {
    color: Se(pg),
    position: ci.Center
  },
  minimap: {
    color: Se(s_),
    position: ns.Inline
  }
});
He._FIND_MATCH_NO_OVERVIEW_DECORATION = Y.register({
  description: "find-match-no-overview",
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: !0
});
He._FIND_MATCH_ONLY_OVERVIEW_DECORATION = Y.register({
  description: "find-match-only-overview",
  stickiness: 1,
  overviewRuler: {
    color: Se(pg),
    position: ci.Center
  }
});
He._RANGE_HIGHLIGHT_DECORATION = Y.register({
  description: "find-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: !0
});
He._FIND_SCOPE_DECORATION = Y.register({
  description: "find-scope",
  className: "findScope",
  isWholeLine: !0
});
class VI {
  constructor(e, t, i) {
    this._editorSelection = e, this._ranges = t, this._replaceStrings = i, this._trackedEditorSelectionId = null;
  }
  getEditOperations(e, t) {
    if (this._ranges.length > 0) {
      const i = [];
      for (let o = 0; o < this._ranges.length; o++)
        i.push({
          range: this._ranges[o],
          text: this._replaceStrings[o]
        });
      i.sort((o, a) => S.compareRangesUsingStarts(o.range, a.range));
      const n = [];
      let s = i[0];
      for (let o = 1; o < i.length; o++)
        s.range.endLineNumber === i[o].range.startLineNumber && s.range.endColumn === i[o].range.startColumn ? (s.range = s.range.plusRange(i[o].range), s.text = s.text + i[o].text) : (n.push(s), s = i[o]);
      n.push(s);
      for (const o of n)
        t.addEditOperation(o.range, o.text);
    }
    this._trackedEditorSelectionId = t.trackSelection(this._editorSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._trackedEditorSelectionId);
  }
}
function Rb(r, e) {
  if (r && r[0] !== "") {
    const t = Rf(r, e, "-"), i = Rf(r, e, "_");
    return t && !i ? Pf(r, e, "-") : !t && i ? Pf(r, e, "_") : r[0].toUpperCase() === r[0] ? e.toUpperCase() : r[0].toLowerCase() === r[0] ? e.toLowerCase() : qS(r[0][0]) && e.length > 0 ? e[0].toUpperCase() + e.substr(1) : r[0][0].toUpperCase() !== r[0][0] && e.length > 0 ? e[0].toLowerCase() + e.substr(1) : e;
  } else
    return e;
}
function Rf(r, e, t) {
  return r[0].indexOf(t) !== -1 && e.indexOf(t) !== -1 && r[0].split(t).length === e.split(t).length;
}
function Pf(r, e, t) {
  const i = e.split(t), n = r[0].split(t);
  let s = "";
  return i.forEach((o, a) => {
    s += Rb([n[a]], o) + t;
  }), s.slice(0, -1);
}
class Mf {
  constructor(e) {
    this.staticValue = e, this.kind = 0;
  }
}
class UI {
  constructor(e) {
    this.pieces = e, this.kind = 1;
  }
}
class no {
  static fromStaticValue(e) {
    return new no([Fn.staticValue(e)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  constructor(e) {
    !e || e.length === 0 ? this._state = new Mf("") : e.length === 1 && e[0].staticValue !== null ? this._state = new Mf(e[0].staticValue) : this._state = new UI(e);
  }
  buildReplaceString(e, t) {
    if (this._state.kind === 0)
      return t ? Rb(e, this._state.staticValue) : this._state.staticValue;
    let i = "";
    for (let n = 0, s = this._state.pieces.length; n < s; n++) {
      const o = this._state.pieces[n];
      if (o.staticValue !== null) {
        i += o.staticValue;
        continue;
      }
      let a = no._substitute(o.matchIndex, e);
      if (o.caseOps !== null && o.caseOps.length > 0) {
        const l = [], d = o.caseOps.length;
        let c = 0;
        for (let h = 0, u = a.length; h < u; h++) {
          if (c >= d) {
            l.push(a.slice(h));
            break;
          }
          switch (o.caseOps[c]) {
            case "U":
              l.push(a[h].toUpperCase());
              break;
            case "u":
              l.push(a[h].toUpperCase()), c++;
              break;
            case "L":
              l.push(a[h].toLowerCase());
              break;
            case "l":
              l.push(a[h].toLowerCase()), c++;
              break;
            default:
              l.push(a[h]);
          }
        }
        a = l.join("");
      }
      i += a;
    }
    return i;
  }
  static _substitute(e, t) {
    if (t === null)
      return "";
    if (e === 0)
      return t[0];
    let i = "";
    for (; e > 0; ) {
      if (e < t.length)
        return (t[e] || "") + i;
      i = String(e % 10) + i, e = Math.floor(e / 10);
    }
    return "$" + i;
  }
}
class Fn {
  static staticValue(e) {
    return new Fn(e, -1, null);
  }
  static caseOps(e, t) {
    return new Fn(null, e, t);
  }
  constructor(e, t, i) {
    this.staticValue = e, this.matchIndex = t, !i || i.length === 0 ? this.caseOps = null : this.caseOps = i.slice(0);
  }
}
class zI {
  constructor(e) {
    this._source = e, this._lastCharIndex = 0, this._result = [], this._resultLen = 0, this._currentStaticPiece = "";
  }
  emitUnchanged(e) {
    this._emitStatic(this._source.substring(this._lastCharIndex, e)), this._lastCharIndex = e;
  }
  emitStatic(e, t) {
    this._emitStatic(e), this._lastCharIndex = t;
  }
  _emitStatic(e) {
    e.length !== 0 && (this._currentStaticPiece += e);
  }
  emitMatchIndex(e, t, i) {
    this._currentStaticPiece.length !== 0 && (this._result[this._resultLen++] = Fn.staticValue(this._currentStaticPiece), this._currentStaticPiece = ""), this._result[this._resultLen++] = Fn.caseOps(e, i), this._lastCharIndex = t;
  }
  finalize() {
    return this.emitUnchanged(this._source.length), this._currentStaticPiece.length !== 0 && (this._result[this._resultLen++] = Fn.staticValue(this._currentStaticPiece), this._currentStaticPiece = ""), new no(this._result);
  }
}
function $I(r) {
  if (!r || r.length === 0)
    return new no(null);
  const e = [], t = new zI(r);
  for (let i = 0, n = r.length; i < n; i++) {
    const s = r.charCodeAt(i);
    if (s === 92) {
      if (i++, i >= n)
        break;
      const o = r.charCodeAt(i);
      switch (o) {
        case 92:
          t.emitUnchanged(i - 1), t.emitStatic("\\", i + 1);
          break;
        case 110:
          t.emitUnchanged(i - 1), t.emitStatic(`
`, i + 1);
          break;
        case 116:
          t.emitUnchanged(i - 1), t.emitStatic("	", i + 1);
          break;
        case 117:
        case 85:
        case 108:
        case 76:
          t.emitUnchanged(i - 1), t.emitStatic("", i + 1), e.push(String.fromCharCode(o));
          break;
      }
      continue;
    }
    if (s === 36) {
      if (i++, i >= n)
        break;
      const o = r.charCodeAt(i);
      if (o === 36) {
        t.emitUnchanged(i - 1), t.emitStatic("$", i + 1);
        continue;
      }
      if (o === 48 || o === 38) {
        t.emitUnchanged(i - 1), t.emitMatchIndex(0, i + 1, e), e.length = 0;
        continue;
      }
      if (49 <= o && o <= 57) {
        let a = o - 48;
        if (i + 1 < n) {
          const l = r.charCodeAt(i + 1);
          if (48 <= l && l <= 57) {
            i++, a = a * 10 + (l - 48), t.emitUnchanged(i - 2), t.emitMatchIndex(a, i + 1, e), e.length = 0;
            continue;
          }
        }
        t.emitUnchanged(i - 1), t.emitMatchIndex(a, i + 1, e), e.length = 0;
        continue;
      }
    }
  }
  return t.finalize();
}
const Oi = new Q("findWidgetVisible", !1);
Oi.toNegated();
const Ad = new Q("findInputFocussed", !1), jg = new Q("replaceInputFocussed", !1), Va = {
  primary: 545,
  mac: {
    primary: 2593
    /* KeyCode.KeyC */
  }
}, Ua = {
  primary: 565,
  mac: {
    primary: 2613
    /* KeyCode.KeyW */
  }
}, za = {
  primary: 560,
  mac: {
    primary: 2608
    /* KeyCode.KeyR */
  }
}, $a = {
  primary: 554,
  mac: {
    primary: 2602
    /* KeyCode.KeyL */
  }
}, ja = {
  primary: 558,
  mac: {
    primary: 2606
    /* KeyCode.KeyP */
  }
}, se = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  StartFindWithArgs: "editor.actions.findWithArgs",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  GoToMatchFindAction: "editor.action.goToMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
}, Gi = 19999, jI = 240;
class sr {
  constructor(e, t) {
    this._toDispose = new M(), this._editor = e, this._state = t, this._isDisposed = !1, this._startSearchingTimer = new Xr(), this._decorations = new He(e), this._toDispose.add(this._decorations), this._updateDecorationsScheduler = new Re(() => this.research(!1), 100), this._toDispose.add(this._updateDecorationsScheduler), this._toDispose.add(this._editor.onDidChangeCursorPosition((i) => {
      (i.reason === 3 || i.reason === 5 || i.reason === 6) && this._decorations.setStartPosition(this._editor.getPosition());
    })), this._ignoreModelContentChanged = !1, this._toDispose.add(this._editor.onDidChangeModelContent((i) => {
      this._ignoreModelContentChanged || (i.isFlush && this._decorations.reset(), this._decorations.setStartPosition(this._editor.getPosition()), this._updateDecorationsScheduler.schedule());
    })), this._toDispose.add(this._state.onFindReplaceStateChange((i) => this._onStateChanged(i))), this.research(!1, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = !0, $e(this._startSearchingTimer), this._toDispose.dispose();
  }
  _onStateChanged(e) {
    this._isDisposed || this._editor.hasModel() && (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) && (this._editor.getModel().isTooLargeForSyncing() ? (this._startSearchingTimer.cancel(), this._startSearchingTimer.setIfNotSet(() => {
      e.searchScope ? this.research(e.moveCursor, this._state.searchScope) : this.research(e.moveCursor);
    }, jI)) : e.searchScope ? this.research(e.moveCursor, this._state.searchScope) : this.research(e.moveCursor));
  }
  static _getSearchRange(e, t) {
    return t || e.getFullModelRange();
  }
  research(e, t) {
    let i = null;
    typeof t < "u" ? t !== null && (Array.isArray(t) ? i = t : i = [t]) : i = this._decorations.getFindScopes(), i !== null && (i = i.map((a) => {
      if (a.startLineNumber !== a.endLineNumber) {
        let l = a.endLineNumber;
        return a.endColumn === 1 && (l = l - 1), new S(a.startLineNumber, 1, l, this._editor.getModel().getLineMaxColumn(l));
      }
      return a;
    }));
    const n = this._findMatches(i, !1, Gi);
    this._decorations.set(n, i);
    const s = this._editor.getSelection();
    let o = this._decorations.getCurrentMatchesPosition(s);
    if (o === 0 && n.length > 0) {
      const a = o_(n.map((l) => l.range), (l) => S.compareRangesUsingStarts(l, s) >= 0);
      o = a > 0 ? a - 1 + 1 : o;
    }
    this._state.changeMatchInfo(o, this._decorations.getCount(), void 0), e && this._editor.getOption(
      41
      /* EditorOption.find */
    ).cursorMoveOnType && this._moveToNextMatch(this._decorations.getStartPosition());
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      const e = this._decorations.getFindScope();
      return e && this._editor.revealRangeInCenterIfOutsideViewport(
        e,
        0
        /* ScrollType.Smooth */
      ), !0;
    }
    return !1;
  }
  _setCurrentFindMatch(e) {
    const t = this._decorations.setCurrentFindMatch(e);
    this._state.changeMatchInfo(t, this._decorations.getCount(), e), this._editor.setSelection(e), this._editor.revealRangeInCenterIfOutsideViewport(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  _prevSearchPosition(e) {
    const t = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber: i, column: n } = e;
    const s = this._editor.getModel();
    return t || n === 1 ? (i === 1 ? i = s.getLineCount() : i--, n = s.getLineMaxColumn(i)) : n--, new F(i, n);
  }
  _moveToPrevMatch(e, t = !1) {
    if (!this._state.canNavigateBack()) {
      const c = this._decorations.matchAfterPosition(e);
      c && this._setCurrentFindMatch(c);
      return;
    }
    if (this._decorations.getCount() < Gi) {
      let c = this._decorations.matchBeforePosition(e);
      c && c.isEmpty() && c.getStartPosition().equals(e) && (e = this._prevSearchPosition(e), c = this._decorations.matchBeforePosition(e)), c && this._setCurrentFindMatch(c);
      return;
    }
    if (this._cannotFind())
      return;
    const i = this._decorations.getFindScope(), n = sr._getSearchRange(this._editor.getModel(), i);
    n.getEndPosition().isBefore(e) && (e = n.getEndPosition()), e.isBefore(n.getStartPosition()) && (e = n.getEndPosition());
    const { lineNumber: s, column: o } = e, a = this._editor.getModel();
    let l = new F(s, o), d = a.findPreviousMatch(this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null, !1);
    if (d && d.range.isEmpty() && d.range.getStartPosition().equals(l) && (l = this._prevSearchPosition(l), d = a.findPreviousMatch(this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null, !1)), !!d) {
      if (!t && !n.containsRange(d.range))
        return this._moveToPrevMatch(d.range.getStartPosition(), !0);
      this._setCurrentFindMatch(d.range);
    }
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(e) {
    const t = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber: i, column: n } = e;
    const s = this._editor.getModel();
    return t || n === s.getLineMaxColumn(i) ? (i === s.getLineCount() ? i = 1 : i++, n = 1) : n++, new F(i, n);
  }
  _moveToNextMatch(e) {
    if (!this._state.canNavigateForward()) {
      const i = this._decorations.matchBeforePosition(e);
      i && this._setCurrentFindMatch(i);
      return;
    }
    if (this._decorations.getCount() < Gi) {
      let i = this._decorations.matchAfterPosition(e);
      i && i.isEmpty() && i.getStartPosition().equals(e) && (e = this._nextSearchPosition(e), i = this._decorations.matchAfterPosition(e)), i && this._setCurrentFindMatch(i);
      return;
    }
    const t = this._getNextMatch(e, !1, !0);
    t && this._setCurrentFindMatch(t.range);
  }
  _getNextMatch(e, t, i, n = !1) {
    if (this._cannotFind())
      return null;
    const s = this._decorations.getFindScope(), o = sr._getSearchRange(this._editor.getModel(), s);
    o.getEndPosition().isBefore(e) && (e = o.getStartPosition()), e.isBefore(o.getStartPosition()) && (e = o.getStartPosition());
    const { lineNumber: a, column: l } = e, d = this._editor.getModel();
    let c = new F(a, l), h = d.findNextMatch(this._state.searchString, c, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null, t);
    return i && h && h.range.isEmpty() && h.range.getStartPosition().equals(c) && (c = this._nextSearchPosition(c), h = d.findNextMatch(this._state.searchString, c, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null, t)), h ? !n && !o.containsRange(h.range) ? this._getNextMatch(h.range.getEndPosition(), t, i, !0) : h : null;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _moveToMatch(e) {
    const t = this._decorations.getDecorationRangeAt(e);
    t && this._setCurrentFindMatch(t);
  }
  moveToMatch(e) {
    this._moveToMatch(e);
  }
  _getReplacePattern() {
    return this._state.isRegex ? $I(this._state.replaceString) : no.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches())
      return;
    const e = this._getReplacePattern(), t = this._editor.getSelection(), i = this._getNextMatch(t.getStartPosition(), !0, !1);
    if (i)
      if (t.equalsRange(i.range)) {
        const n = e.buildReplaceString(i.matches, this._state.preserveCase), s = new Gr(t, n);
        this._executeEditorCommand("replace", s), this._decorations.setStartPosition(new F(t.startLineNumber, t.startColumn + n.length)), this.research(!0);
      } else
        this._decorations.setStartPosition(this._editor.getPosition()), this._setCurrentFindMatch(i.range);
  }
  _findMatches(e, t, i) {
    const n = (e || [null]).map((s) => sr._getSearchRange(this._editor.getModel(), s));
    return this._editor.getModel().findMatches(this._state.searchString, n, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null, t, i);
  }
  replaceAll() {
    if (!this._hasMatches())
      return;
    const e = this._decorations.getFindScopes();
    e === null && this._state.matchesCount >= Gi ? this._largeReplaceAll() : this._regularReplaceAll(e), this.research(!1);
  }
  _largeReplaceAll() {
    const t = new KS(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null).parseSearchRequest();
    if (!t)
      return;
    let i = t.regex;
    if (!i.multiline) {
      let h = "mu";
      i.ignoreCase && (h += "i"), i.global && (h += "g"), i = new RegExp(i.source, h);
    }
    const n = this._editor.getModel(), s = n.getValue(
      1
      /* EndOfLinePreference.LF */
    ), o = n.getFullModelRange(), a = this._getReplacePattern();
    let l;
    const d = this._state.preserveCase;
    a.hasReplacementPatterns || d ? l = s.replace(i, function() {
      return a.buildReplaceString(arguments, d);
    }) : l = s.replace(i, a.buildReplaceString(null, d));
    const c = new r_(o, l, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", c);
  }
  _regularReplaceAll(e) {
    const t = this._getReplacePattern(), i = this._findMatches(
      e,
      t.hasReplacementPatterns || this._state.preserveCase,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ), n = [];
    for (let o = 0, a = i.length; o < a; o++)
      n[o] = t.buildReplaceString(i[o].matches, this._state.preserveCase);
    const s = new VI(this._editor.getSelection(), i.map((o) => o.range), n);
    this._executeEditorCommand("replaceAll", s);
  }
  selectAllMatches() {
    if (!this._hasMatches())
      return;
    const e = this._decorations.getFindScopes();
    let i = this._findMatches(
      e,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ).map((s) => new z(s.range.startLineNumber, s.range.startColumn, s.range.endLineNumber, s.range.endColumn));
    const n = this._editor.getSelection();
    for (let s = 0, o = i.length; s < o; s++)
      if (i[s].equalsRange(n)) {
        i = [n].concat(i.slice(0, s)).concat(i.slice(s + 1));
        break;
      }
    this._editor.setSelections(i);
  }
  _executeEditorCommand(e, t) {
    try {
      this._ignoreModelContentChanged = !0, this._editor.pushUndoStop(), this._editor.executeCommand(e, t), this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = !1;
    }
  }
}
class Od extends ea {
  constructor(e, t, i) {
    super(), this._hideSoon = this._register(new Re(() => this._hide(), 2e3)), this._isVisible = !1, this._editor = e, this._state = t, this._keybindingService = i, this._domNode = document.createElement("div"), this._domNode.className = "findOptionsWidget", this._domNode.style.display = "none", this._domNode.style.top = "10px", this._domNode.style.zIndex = "12", this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
    const n = {
      inputActiveOptionBorder: Mn(a_),
      inputActiveOptionForeground: Mn(l_),
      inputActiveOptionBackground: Mn(Is)
    };
    this.caseSensitive = this._register(new GS({
      appendTitle: this._keybindingLabelFor(se.ToggleCaseSensitiveCommand),
      isChecked: this._state.matchCase,
      ...n
    })), this._domNode.appendChild(this.caseSensitive.domNode), this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, !1);
    })), this.wholeWords = this._register(new ZS({
      appendTitle: this._keybindingLabelFor(se.ToggleWholeWordCommand),
      isChecked: this._state.wholeWord,
      ...n
    })), this._domNode.appendChild(this.wholeWords.domNode), this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, !1);
    })), this.regex = this._register(new XS({
      appendTitle: this._keybindingLabelFor(se.ToggleRegexCommand),
      isChecked: this._state.isRegex,
      ...n
    })), this._domNode.appendChild(this.regex.domNode), this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, !1);
    })), this._editor.addOverlayWidget(this), this._register(this._state.onFindReplaceStateChange((s) => {
      let o = !1;
      s.isRegex && (this.regex.checked = this._state.isRegex, o = !0), s.wholeWord && (this.wholeWords.checked = this._state.wholeWord, o = !0), s.matchCase && (this.caseSensitive.checked = this._state.matchCase, o = !0), !this._state.isRevealed && o && this._revealTemporarily();
    })), this._register(le(this._domNode, Le.MOUSE_LEAVE, (s) => this._onMouseLeave())), this._register(le(this._domNode, "mouseover", (s) => this._onMouseOver()));
  }
  _keybindingLabelFor(e) {
    const t = this._keybindingService.lookupKeybinding(e);
    return t ? ` (${t.getLabel()})` : "";
  }
  dispose() {
    this._editor.removeOverlayWidget(this), super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return Od.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show(), this._hideSoon.schedule();
  }
  _onMouseLeave() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    this._isVisible || (this._isVisible = !0, this._domNode.style.display = "block");
  }
  _hide() {
    this._isVisible && (this._isVisible = !1, this._domNode.style.display = "none");
  }
}
Od.ID = "editor.contrib.findOptionsWidget";
function qa(r, e) {
  return r === 1 ? !0 : r === 2 ? !1 : e;
}
class qI extends P {
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return qa(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return qa(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return qa(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return qa(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  constructor() {
    super(), this._onFindReplaceStateChange = this._register(new G()), this.onFindReplaceStateChange = this._onFindReplaceStateChange.event, this._searchString = "", this._replaceString = "", this._isRevealed = !1, this._isReplaceRevealed = !1, this._isRegex = !1, this._isRegexOverride = 0, this._wholeWord = !1, this._wholeWordOverride = 0, this._matchCase = !1, this._matchCaseOverride = 0, this._preserveCase = !1, this._preserveCaseOverride = 0, this._searchScope = null, this._matchesPosition = 0, this._matchesCount = 0, this._currentMatch = null, this._loop = !0, this._isSearching = !1, this._filters = null;
  }
  changeMatchInfo(e, t, i) {
    const n = {
      moveCursor: !1,
      updateHistory: !1,
      searchString: !1,
      replaceString: !1,
      isRevealed: !1,
      isReplaceRevealed: !1,
      isRegex: !1,
      wholeWord: !1,
      matchCase: !1,
      preserveCase: !1,
      searchScope: !1,
      matchesPosition: !1,
      matchesCount: !1,
      currentMatch: !1,
      loop: !1,
      isSearching: !1,
      filters: !1
    };
    let s = !1;
    t === 0 && (e = 0), e > t && (e = t), this._matchesPosition !== e && (this._matchesPosition = e, n.matchesPosition = !0, s = !0), this._matchesCount !== t && (this._matchesCount = t, n.matchesCount = !0, s = !0), typeof i < "u" && (S.equalsRange(this._currentMatch, i) || (this._currentMatch = i, n.currentMatch = !0, s = !0)), s && this._onFindReplaceStateChange.fire(n);
  }
  change(e, t, i = !0) {
    var n;
    const s = {
      moveCursor: t,
      updateHistory: i,
      searchString: !1,
      replaceString: !1,
      isRevealed: !1,
      isReplaceRevealed: !1,
      isRegex: !1,
      wholeWord: !1,
      matchCase: !1,
      preserveCase: !1,
      searchScope: !1,
      matchesPosition: !1,
      matchesCount: !1,
      currentMatch: !1,
      loop: !1,
      isSearching: !1,
      filters: !1
    };
    let o = !1;
    const a = this.isRegex, l = this.wholeWord, d = this.matchCase, c = this.preserveCase;
    typeof e.searchString < "u" && this._searchString !== e.searchString && (this._searchString = e.searchString, s.searchString = !0, o = !0), typeof e.replaceString < "u" && this._replaceString !== e.replaceString && (this._replaceString = e.replaceString, s.replaceString = !0, o = !0), typeof e.isRevealed < "u" && this._isRevealed !== e.isRevealed && (this._isRevealed = e.isRevealed, s.isRevealed = !0, o = !0), typeof e.isReplaceRevealed < "u" && this._isReplaceRevealed !== e.isReplaceRevealed && (this._isReplaceRevealed = e.isReplaceRevealed, s.isReplaceRevealed = !0, o = !0), typeof e.isRegex < "u" && (this._isRegex = e.isRegex), typeof e.wholeWord < "u" && (this._wholeWord = e.wholeWord), typeof e.matchCase < "u" && (this._matchCase = e.matchCase), typeof e.preserveCase < "u" && (this._preserveCase = e.preserveCase), typeof e.searchScope < "u" && (!((n = e.searchScope) === null || n === void 0) && n.every((h) => {
      var u;
      return (u = this._searchScope) === null || u === void 0 ? void 0 : u.some((p) => !S.equalsRange(p, h));
    }) || (this._searchScope = e.searchScope, s.searchScope = !0, o = !0)), typeof e.loop < "u" && this._loop !== e.loop && (this._loop = e.loop, s.loop = !0, o = !0), typeof e.isSearching < "u" && this._isSearching !== e.isSearching && (this._isSearching = e.isSearching, s.isSearching = !0, o = !0), typeof e.filters < "u" && (this._filters ? this._filters.update(e.filters) : this._filters = e.filters, s.filters = !0, o = !0), this._isRegexOverride = typeof e.isRegexOverride < "u" ? e.isRegexOverride : 0, this._wholeWordOverride = typeof e.wholeWordOverride < "u" ? e.wholeWordOverride : 0, this._matchCaseOverride = typeof e.matchCaseOverride < "u" ? e.matchCaseOverride : 0, this._preserveCaseOverride = typeof e.preserveCaseOverride < "u" ? e.preserveCaseOverride : 0, a !== this.isRegex && (o = !0, s.isRegex = !0), l !== this.wholeWord && (o = !0, s.wholeWord = !0), d !== this.matchCase && (o = !0, s.matchCase = !0), c !== this.preserveCase && (o = !0, s.preserveCase = !0), o && this._onFindReplaceStateChange.fire(s);
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= Gi;
  }
}
const KI = g("defaultLabel", "input"), GI = g("label.preserveCaseToggle", "Preserve Case");
class ZI extends d_ {
  constructor(e) {
    super({
      // TODO: does this need its own icon?
      icon: j.preserveCase,
      title: GI + e.appendTitle,
      isChecked: e.isChecked,
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class XI extends ea {
  constructor(e, t, i, n) {
    super(), this._showOptionButtons = i, this.fixFocusOnOptionClickEnabled = !0, this.cachedOptionsWidth = 0, this._onDidOptionChange = this._register(new G()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new G()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new G()), this._onInput = this._register(new G()), this._onKeyUp = this._register(new G()), this._onPreserveCaseKeyDown = this._register(new G()), this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event, this.contextViewProvider = t, this.placeholder = n.placeholder || "", this.validation = n.validation, this.label = n.label || KI;
    const s = n.appendPreserveCaseLabel || "", o = n.history || [], a = !!n.flexibleHeight, l = !!n.flexibleWidth, d = n.flexibleMaxHeight;
    this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new QS(this.domNode, this.contextViewProvider, {
      ariaLabel: this.label || "",
      placeholder: this.placeholder || "",
      validationOptions: {
        validation: this.validation
      },
      history: o,
      showHistoryHint: n.showHistoryHint,
      flexibleHeight: a,
      flexibleWidth: l,
      flexibleMaxHeight: d,
      inputBoxStyles: n.inputBoxStyles
    })), this.preserveCase = this._register(new ZI({
      appendTitle: s,
      isChecked: !1,
      ...n.toggleStyles
    })), this._register(this.preserveCase.onChange((u) => {
      this._onDidOptionChange.fire(u), !u && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
    })), this._register(this.preserveCase.onKeyDown((u) => {
      this._onPreserveCaseKeyDown.fire(u);
    })), this._showOptionButtons ? this.cachedOptionsWidth = this.preserveCase.width() : this.cachedOptionsWidth = 0;
    const c = [this.preserveCase.domNode];
    this.onkeydown(this.domNode, (u) => {
      if (u.equals(
        15
        /* KeyCode.LeftArrow */
      ) || u.equals(
        17
        /* KeyCode.RightArrow */
      ) || u.equals(
        9
        /* KeyCode.Escape */
      )) {
        const p = c.indexOf(this.domNode.ownerDocument.activeElement);
        if (p >= 0) {
          let f = -1;
          u.equals(
            17
            /* KeyCode.RightArrow */
          ) ? f = (p + 1) % c.length : u.equals(
            15
            /* KeyCode.LeftArrow */
          ) && (p === 0 ? f = c.length - 1 : f = p - 1), u.equals(
            9
            /* KeyCode.Escape */
          ) ? (c[p].blur(), this.inputBox.focus()) : f >= 0 && c[f].focus(), wl.stop(u, !0);
        }
      }
    });
    const h = document.createElement("div");
    h.className = "controls", h.style.display = this._showOptionButtons ? "block" : "none", h.appendChild(this.preserveCase.domNode), this.domNode.appendChild(h), e == null || e.appendChild(this.domNode), this.onkeydown(this.inputBox.inputElement, (u) => this._onKeyDown.fire(u)), this.onkeyup(this.inputBox.inputElement, (u) => this._onKeyUp.fire(u)), this.oninput(this.inputBox.inputElement, (u) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (u) => this._onMouseDown.fire(u));
  }
  enable() {
    this.domNode.classList.remove("disabled"), this.inputBox.enable(), this.preserveCase.enable();
  }
  disable() {
    this.domNode.classList.add("disabled"), this.inputBox.disable(), this.preserveCase.disable();
  }
  setEnabled(e) {
    e ? this.enable() : this.disable();
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getPreserveCase() {
    return this.preserveCase.checked;
  }
  setPreserveCase(e) {
    this.preserveCase.checked = e;
  }
  focusOnPreserve() {
    this.preserveCase.focus();
  }
  validate() {
    var e;
    (e = this.inputBox) === null || e === void 0 || e.validate();
  }
  set width(e) {
    this.inputBox.paddingRight = this.cachedOptionsWidth, this.domNode.style.width = e + "px";
  }
  dispose() {
    super.dispose();
  }
}
var Pb = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Mb = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const qg = new Q("suggestWidgetVisible", !1, g("suggestWidgetVisible", "Whether suggestion are visible")), Kg = "historyNavigationWidgetFocus", Eb = "historyNavigationForwardsEnabled", Tb = "historyNavigationBackwardsEnabled";
let xi;
const Ka = [];
function Ab(r, e) {
  if (Ka.includes(e))
    throw new Error("Cannot register the same widget multiple times");
  Ka.push(e);
  const t = new M(), i = new Q(Kg, !1).bindTo(r), n = new Q(Eb, !0).bindTo(r), s = new Q(Tb, !0).bindTo(r), o = () => {
    i.set(!0), xi = e;
  }, a = () => {
    i.set(!1), xi === e && (xi = void 0);
  };
  return JS(e.element) && o(), t.add(e.onDidFocus(() => o())), t.add(e.onDidBlur(() => a())), t.add(pe(() => {
    Ka.splice(Ka.indexOf(e), 1), a();
  })), {
    historyNavigationForwardsEnablement: n,
    historyNavigationBackwardsEnablement: s,
    dispose() {
      t.dispose();
    }
  };
}
let jh = class extends YS {
  constructor(e, t, i, n) {
    super(e, t, i);
    const s = this._register(n.createScoped(this.inputBox.element));
    this._register(Ab(s, this.inputBox));
  }
};
jh = Pb([
  Mb(3, ee)
], jh);
let qh = class extends XI {
  constructor(e, t, i, n, s = !1) {
    super(e, t, s, i);
    const o = this._register(n.createScoped(this.inputBox.element));
    this._register(Ab(o, this.inputBox));
  }
};
qh = Pb([
  Mb(3, ee)
], qh);
gi.registerCommandAndKeybindingRule({
  id: "history.showPrevious",
  weight: 200,
  when: L.and(L.has(Kg), L.equals(Tb, !0), L.not("isComposing"), qg.isEqualTo(!1)),
  primary: 16,
  secondary: [
    528
    /* KeyCode.UpArrow */
  ],
  handler: (r) => {
    xi == null || xi.showPreviousValue();
  }
});
gi.registerCommandAndKeybindingRule({
  id: "history.showNext",
  weight: 200,
  when: L.and(L.has(Kg), L.equals(Eb, !0), L.not("isComposing"), qg.isEqualTo(!1)),
  primary: 18,
  secondary: [
    530
    /* KeyCode.DownArrow */
  ],
  handler: (r) => {
    xi == null || xi.showNextValue();
  }
});
function Ef(r) {
  var e, t;
  return ((e = r.lookupKeybinding("history.showPrevious")) === null || e === void 0 ? void 0 : e.getElectronAccelerator()) === "Up" && ((t = r.lookupKeybinding("history.showNext")) === null || t === void 0 ? void 0 : t.getElectronAccelerator()) === "Down";
}
const QI = Ae("find-selection", j.selection, g("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget.")), Tf = Ae("find-collapsed", j.chevronRight, g("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed.")), Af = Ae("find-expanded", j.chevronDown, g("findExpandedIcon", "Icon to indicate that the editor find widget is expanded.")), YI = Ae("find-replace", j.replace, g("findReplaceIcon", "Icon for 'Replace' in the editor find widget.")), JI = Ae("find-replace-all", j.replaceAll, g("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget.")), eD = Ae("find-previous-match", j.arrowUp, g("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget.")), tD = Ae("find-next-match", j.arrowDown, g("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget.")), iD = g("label.findDialog", "Find / Replace"), nD = g("label.find", "Find"), sD = g("placeholder.find", "Find"), oD = g("label.previousMatchButton", "Previous Match"), rD = g("label.nextMatchButton", "Next Match"), aD = g("label.toggleSelectionFind", "Find in Selection"), lD = g("label.closeButton", "Close"), dD = g("label.replace", "Replace"), cD = g("placeholder.replace", "Replace"), hD = g("label.replaceButton", "Replace"), uD = g("label.replaceAllButton", "Replace All"), gD = g("label.toggleReplaceButton", "Toggle Replace"), pD = g("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", Gi), fD = g("label.matchesLocation", "{0} of {1}"), Of = g("label.noResults", "No results"), Qt = 419, mD = 275, _D = mD - 54;
let Oo = 69;
const vD = 33, Ff = "ctrlEnterReplaceAll.windows.donotask", Wf = si ? 256 : 2048;
class Oc {
  constructor(e) {
    this.afterLineNumber = e, this.heightInPx = vD, this.suppressMouseDown = !1, this.domNode = document.createElement("div"), this.domNode.className = "dock-find-viewzone";
  }
}
function Hf(r, e, t) {
  const i = !!e.match(/\n/);
  if (t && i && t.selectionStart > 0) {
    r.stopPropagation();
    return;
  }
}
function Bf(r, e, t) {
  const i = !!e.match(/\n/);
  if (t && i && t.selectionEnd < t.value.length) {
    r.stopPropagation();
    return;
  }
}
class Fd extends ea {
  constructor(e, t, i, n, s, o, a, l, d) {
    super(), this._cachedHeight = null, this._revealTimeouts = [], this._codeEditor = e, this._controller = t, this._state = i, this._contextViewProvider = n, this._keybindingService = s, this._contextKeyService = o, this._storageService = l, this._notificationService = d, this._ctrlEnterReplaceAllWarningPrompted = !!l.getBoolean(
      Ff,
      0
      /* StorageScope.PROFILE */
    ), this._isVisible = !1, this._isReplaceVisible = !1, this._ignoreChangeEvent = !1, this._updateHistoryDelayer = new Vn(500), this._register(pe(() => this._updateHistoryDelayer.cancel())), this._register(this._state.onFindReplaceStateChange((c) => this._onStateChanged(c))), this._buildDomNode(), this._updateButtons(), this._tryUpdateWidgetWidth(), this._findInput.inputBox.layout(), this._register(this._codeEditor.onDidChangeConfiguration((c) => {
      if (c.hasChanged(
        91
        /* EditorOption.readOnly */
      ) && (this._codeEditor.getOption(
        91
        /* EditorOption.readOnly */
      ) && this._state.change({ isReplaceRevealed: !1 }, !1), this._updateButtons()), c.hasChanged(
        144
        /* EditorOption.layoutInfo */
      ) && this._tryUpdateWidgetWidth(), c.hasChanged(
        2
        /* EditorOption.accessibilitySupport */
      ) && this.updateAccessibilitySupport(), c.hasChanged(
        41
        /* EditorOption.find */
      )) {
        const h = this._codeEditor.getOption(
          41
          /* EditorOption.find */
        ).loop;
        this._state.change({ loop: h }, !1);
        const u = this._codeEditor.getOption(
          41
          /* EditorOption.find */
        ).addExtraSpaceOnTop;
        u && !this._viewZone && (this._viewZone = new Oc(0), this._showViewZone()), !u && this._viewZone && this._removeViewZone();
      }
    })), this.updateAccessibilitySupport(), this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      this._isVisible && this._updateToggleSelectionFindButton();
    })), this._register(this._codeEditor.onDidFocusEditorWidget(async () => {
      if (this._isVisible) {
        const c = await this._controller.getGlobalBufferTerm();
        c && c !== this._state.searchString && (this._state.change({ searchString: c }, !1), this._findInput.select());
      }
    })), this._findInputFocused = Ad.bindTo(o), this._findFocusTracker = this._register(Us(this._findInput.inputBox.inputElement)), this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(!0), this._updateSearchScope();
    })), this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(!1);
    })), this._replaceInputFocused = jg.bindTo(o), this._replaceFocusTracker = this._register(Us(this._replaceInput.inputBox.inputElement)), this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(!0), this._updateSearchScope();
    })), this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(!1);
    })), this._codeEditor.addOverlayWidget(this), this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop && (this._viewZone = new Oc(0)), this._register(this._codeEditor.onDidChangeModel(() => {
      this._isVisible && (this._viewZoneId = void 0);
    })), this._register(this._codeEditor.onDidScrollChange((c) => {
      if (c.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  // ----- IOverlayWidget API
  getId() {
    return Fd.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._isVisible ? {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    } : null;
  }
  // ----- React to state changes
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = !0, this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = !1;
      }
      this._updateButtons();
    }
    if (e.replaceString && (this._replaceInput.inputBox.value = this._state.replaceString), e.isRevealed && (this._state.isRevealed ? this._reveal() : this._hide(!0)), e.isReplaceRevealed && (this._state.isReplaceRevealed ? !this._codeEditor.getOption(
      91
      /* EditorOption.readOnly */
    ) && !this._isReplaceVisible && (this._isReplaceVisible = !0, this._replaceInput.width = lt(this._findInput.domNode), this._updateButtons(), this._replaceInput.inputBox.layout()) : this._isReplaceVisible && (this._isReplaceVisible = !1, this._updateButtons())), (e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed) && this._tryUpdateHeight() && this._showViewZone(), e.isRegex && this._findInput.setRegex(this._state.isRegex), e.wholeWord && this._findInput.setWholeWords(this._state.wholeWord), e.matchCase && this._findInput.setCaseSensitive(this._state.matchCase), e.preserveCase && this._replaceInput.setPreserveCase(this._state.preserveCase), e.searchScope && (this._state.searchScope ? this._toggleSelectionFind.checked = !0 : this._toggleSelectionFind.checked = !1, this._updateToggleSelectionFindButton()), e.searchString || e.matchesCount || e.matchesPosition) {
      const t = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      this._domNode.classList.toggle("no-results", t), this._updateMatchesCount(), this._updateButtons();
    }
    (e.searchString || e.currentMatch) && this._layoutViewZone(), e.updateHistory && this._delayedUpdateHistory(), e.loop && this._updateButtons();
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, re);
  }
  _updateHistory() {
    this._state.searchString && this._findInput.inputBox.addToHistory(), this._state.replaceString && this._replaceInput.inputBox.addToHistory();
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = Oo + "px", this._state.matchesCount >= Gi ? this._matchesCount.title = pD : this._matchesCount.title = "", this._matchesCount.firstChild && this._matchesCount.removeChild(this._matchesCount.firstChild);
    let e;
    if (this._state.matchesCount > 0) {
      let t = String(this._state.matchesCount);
      this._state.matchesCount >= Gi && (t += "+");
      let i = String(this._state.matchesPosition);
      i === "0" && (i = "?"), e = fg(fD, i, t);
    } else
      e = Of;
    this._matchesCount.appendChild(document.createTextNode(e)), xt(this._getAriaLabel(e, this._state.currentMatch, this._state.searchString)), Oo = Math.max(Oo, this._matchesCount.clientWidth);
  }
  // ----- actions
  _getAriaLabel(e, t, i) {
    if (e === Of)
      return i === "" ? g("ariaSearchNoResultEmpty", "{0} found", e) : g("ariaSearchNoResult", "{0} found for '{1}'", e, i);
    if (t) {
      const n = g("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", e, i, t.startLineNumber + ":" + t.startColumn), s = this._codeEditor.getModel();
      return s && t.startLineNumber <= s.getLineCount() && t.startLineNumber >= 1 ? `${s.getLineContent(t.startLineNumber)}, ${n}` : n;
    }
    return g("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", e, i);
  }
  /**
   * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
   * If 'selection find' is OFF we enable the button only if there is a selection.
   */
  _updateToggleSelectionFindButton() {
    const e = this._codeEditor.getSelection(), t = e ? e.startLineNumber !== e.endLineNumber || e.startColumn !== e.endColumn : !1, i = this._toggleSelectionFind.checked;
    this._isVisible && (i || t) ? this._toggleSelectionFind.enable() : this._toggleSelectionFind.disable();
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible), this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible), this._updateToggleSelectionFindButton(), this._closeBtn.setEnabled(this._isVisible);
    const e = this._state.searchString.length > 0, t = !!this._state.matchesCount;
    this._prevBtn.setEnabled(this._isVisible && e && t && this._state.canNavigateBack()), this._nextBtn.setEnabled(this._isVisible && e && t && this._state.canNavigateForward()), this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && e), this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && e), this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible), this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    const i = !this._codeEditor.getOption(
      91
      /* EditorOption.readOnly */
    );
    this._toggleReplaceBtn.setEnabled(this._isVisible && i);
  }
  _reveal() {
    if (this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    }), this._revealTimeouts = [], !this._isVisible) {
      this._isVisible = !0;
      const e = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(
        41
        /* EditorOption.find */
      ).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = !0;
          break;
        case "never":
          this._toggleSelectionFind.checked = !1;
          break;
        case "multiline": {
          const i = !!e && e.startLineNumber !== e.endLineNumber;
          this._toggleSelectionFind.checked = i;
          break;
        }
      }
      this._tryUpdateWidgetWidth(), this._updateButtons(), this._revealTimeouts.push(setTimeout(() => {
        this._domNode.classList.add("visible"), this._domNode.setAttribute("aria-hidden", "false");
      }, 0)), this._revealTimeouts.push(setTimeout(() => {
        this._findInput.validate();
      }, 200)), this._codeEditor.layoutOverlayWidget(this);
      let t = !0;
      if (this._codeEditor.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection && e) {
        const i = this._codeEditor.getDomNode();
        if (i) {
          const n = mt(i), s = this._codeEditor.getScrolledVisiblePosition(e.getStartPosition()), o = n.left + (s ? s.left : 0), a = s ? s.top : 0;
          if (this._viewZone && a < this._viewZone.heightInPx) {
            e.endLineNumber > e.startLineNumber && (t = !1);
            const l = ew(this._domNode).left;
            o > l && (t = !1);
            const d = this._codeEditor.getScrolledVisiblePosition(e.getEndPosition());
            n.left + (d ? d.left : 0) > l && (t = !1);
          }
        }
      }
      this._showViewZone(t);
    }
  }
  _hide(e) {
    this._revealTimeouts.forEach((t) => {
      clearTimeout(t);
    }), this._revealTimeouts = [], this._isVisible && (this._isVisible = !1, this._updateButtons(), this._domNode.classList.remove("visible"), this._domNode.setAttribute("aria-hidden", "true"), this._findInput.clearMessage(), e && this._codeEditor.focus(), this._codeEditor.layoutOverlayWidget(this), this._removeViewZone());
  }
  _layoutViewZone(e) {
    if (!this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible)
      return;
    const i = this._viewZone;
    this._viewZoneId !== void 0 || !i || this._codeEditor.changeViewZones((n) => {
      i.heightInPx = this._getHeight(), this._viewZoneId = n.addZone(i), this._codeEditor.setScrollTop(e || this._codeEditor.getScrollTop() + i.heightInPx);
    });
  }
  _showViewZone(e = !0) {
    if (!this._isVisible || !this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop)
      return;
    this._viewZone === void 0 && (this._viewZone = new Oc(0));
    const i = this._viewZone;
    this._codeEditor.changeViewZones((n) => {
      if (this._viewZoneId !== void 0) {
        const s = this._getHeight();
        if (s === i.heightInPx)
          return;
        const o = s - i.heightInPx;
        i.heightInPx = s, n.layoutZone(this._viewZoneId), e && this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + o);
        return;
      } else {
        let s = this._getHeight();
        if (s -= this._codeEditor.getOption(
          84
          /* EditorOption.padding */
        ).top, s <= 0)
          return;
        i.heightInPx = s, this._viewZoneId = n.addZone(i), e && this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + s);
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((e) => {
      this._viewZoneId !== void 0 && (e.removeZone(this._viewZoneId), this._viewZoneId = void 0, this._viewZone && (this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx), this._viewZone = void 0));
    });
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible || !this._domNode.isConnected)
      return;
    const e = this._codeEditor.getLayoutInfo();
    if (e.contentWidth <= 0) {
      this._domNode.classList.add("hiddenEditor");
      return;
    } else
      this._domNode.classList.contains("hiddenEditor") && this._domNode.classList.remove("hiddenEditor");
    const i = e.width, n = e.minimap.minimapWidth;
    let s = !1, o = !1, a = !1;
    if (this._resized && lt(this._domNode) > Qt) {
      this._domNode.style.maxWidth = `${i - 28 - n - 15}px`, this._replaceInput.width = lt(this._findInput.domNode);
      return;
    }
    if (Qt + 28 + n >= i && (o = !0), Qt + 28 + n - Oo >= i && (a = !0), Qt + 28 + n - Oo >= i + 50 && (s = !0), this._domNode.classList.toggle("collapsed-find-widget", s), this._domNode.classList.toggle("narrow-find-widget", a), this._domNode.classList.toggle("reduced-find-widget", o), !a && !s && (this._domNode.style.maxWidth = `${i - 28 - n - 15}px`), this._findInput.layout({ collapsedFindWidget: s, narrowFindWidget: a, reducedFindWidget: o }), this._resized) {
      const l = this._findInput.inputBox.element.clientWidth;
      l > 0 && (this._replaceInput.width = l);
    } else
      this._isReplaceVisible && (this._replaceInput.width = lt(this._findInput.domNode));
  }
  _getHeight() {
    let e = 0;
    return e += 4, e += this._findInput.inputBox.height + 2, this._isReplaceVisible && (e += 4, e += this._replaceInput.inputBox.height + 2), e += 4, e;
  }
  _tryUpdateHeight() {
    const e = this._getHeight();
    return this._cachedHeight !== null && this._cachedHeight === e ? !1 : (this._cachedHeight = e, this._domNode.style.height = `${e}px`, !0);
  }
  // ----- Public
  focusFindInput() {
    this._findInput.select(), this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select(), this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (this._codeEditor.hasModel() && this._toggleSelectionFind.checked) {
      const e = this._codeEditor.getSelections();
      e.map((t) => {
        t.endColumn === 1 && t.endLineNumber > t.startLineNumber && (t = t.setEndPosition(t.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(t.endLineNumber - 1)));
        const i = this._state.currentMatch;
        return t.startLineNumber !== t.endLineNumber && !S.equalsRange(t, i) ? t : null;
      }).filter((t) => !!t), e.length && this._state.change({ searchScope: e }, !0);
    }
  }
  _onFindInputMouseDown(e) {
    e.middleButton && e.stopPropagation();
  }
  _onFindInputKeyDown(e) {
    if (e.equals(
      Wf | 3
      /* KeyCode.Enter */
    ))
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._findInput.inputBox.insertAtCursor(`
`), e.preventDefault();
        return;
      }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._isReplaceVisible ? this._replaceInput.focus() : this._findInput.focusOnCaseSensitive(), e.preventDefault();
      return;
    }
    if (e.equals(
      2066
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    ))
      return Hf(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    ))
      return Bf(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(
      Wf | 3
      /* KeyCode.Enter */
    ))
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        nd && uo && !this._ctrlEnterReplaceAllWarningPrompted && (this._notificationService.info(g("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior.")), this._ctrlEnterReplaceAllWarningPrompted = !0, this._storageService.store(
          Ff,
          !0,
          0,
          0
          /* StorageTarget.USER */
        )), this._replaceInput.inputBox.insertAtCursor(`
`), e.preventDefault();
        return;
      }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._findInput.focusOnCaseSensitive(), e.preventDefault();
      return;
    }
    if (e.equals(
      1026
      /* KeyCode.Tab */
    )) {
      this._findInput.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      2066
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    ))
      return Hf(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    ))
      return Bf(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
  }
  // ----- sash
  getVerticalSashLeft(e) {
    return 0;
  }
  // ----- initialization
  _keybindingLabelFor(e) {
    const t = this._keybindingService.lookupKeybinding(e);
    return t ? ` (${t.getLabel()})` : "";
  }
  _buildDomNode() {
    this._findInput = this._register(new jh(null, this._contextViewProvider, {
      width: _D,
      label: nD,
      placeholder: sD,
      appendCaseSensitiveLabel: this._keybindingLabelFor(se.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(se.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(se.ToggleRegexCommand),
      validation: (l) => {
        if (l.length === 0 || !this._findInput.getRegex())
          return null;
        try {
          return new RegExp(l, "gu"), null;
        } catch (d) {
          return { content: d.message };
        }
      },
      flexibleHeight: !0,
      flexibleWidth: !0,
      flexibleMaxHeight: 118,
      showCommonFindToggles: !0,
      showHistoryHint: () => Ef(this._keybindingService),
      inputBoxStyles: Pp,
      toggleStyles: Mp
    }, this._contextKeyService)), this._findInput.setRegex(!!this._state.isRegex), this._findInput.setCaseSensitive(!!this._state.matchCase), this._findInput.setWholeWords(!!this._state.wholeWord), this._register(this._findInput.onKeyDown((l) => this._onFindInputKeyDown(l))), this._register(this._findInput.inputBox.onDidChange(() => {
      this._ignoreChangeEvent || this._state.change({ searchString: this._findInput.getValue() }, !0);
    })), this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, !0);
    })), this._register(this._findInput.onCaseSensitiveKeyDown((l) => {
      l.equals(
        1026
        /* KeyCode.Tab */
      ) && this._isReplaceVisible && (this._replaceInput.focus(), l.preventDefault());
    })), this._register(this._findInput.onRegexKeyDown((l) => {
      l.equals(
        2
        /* KeyCode.Tab */
      ) && this._isReplaceVisible && (this._replaceInput.focusOnPreserve(), l.preventDefault());
    })), this._register(this._findInput.inputBox.onDidHeightChange((l) => {
      this._tryUpdateHeight() && this._showViewZone();
    })), tw && this._register(this._findInput.onMouseDown((l) => this._onFindInputMouseDown(l))), this._matchesCount = document.createElement("div"), this._matchesCount.className = "matchesCount", this._updateMatchesCount(), this._prevBtn = this._register(new fs({
      label: oD + this._keybindingLabelFor(se.PreviousMatchFindAction),
      icon: eD,
      onTrigger: () => {
        Ns(this._codeEditor.getAction(se.PreviousMatchFindAction)).run().then(void 0, re);
      }
    })), this._nextBtn = this._register(new fs({
      label: rD + this._keybindingLabelFor(se.NextMatchFindAction),
      icon: tD,
      onTrigger: () => {
        Ns(this._codeEditor.getAction(se.NextMatchFindAction)).run().then(void 0, re);
      }
    }));
    const i = document.createElement("div");
    i.className = "find-part", i.appendChild(this._findInput.domNode);
    const n = document.createElement("div");
    n.className = "find-actions", i.appendChild(n), n.appendChild(this._matchesCount), n.appendChild(this._prevBtn.domNode), n.appendChild(this._nextBtn.domNode), this._toggleSelectionFind = this._register(new d_({
      icon: QI,
      title: aD + this._keybindingLabelFor(se.ToggleSearchScopeCommand),
      isChecked: !1,
      inputActiveOptionBackground: Mn(Is),
      inputActiveOptionBorder: Mn(a_),
      inputActiveOptionForeground: Mn(l_)
    })), this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          let l = this._codeEditor.getSelections();
          l = l.map((d) => (d.endColumn === 1 && d.endLineNumber > d.startLineNumber && (d = d.setEndPosition(d.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(d.endLineNumber - 1))), d.isEmpty() ? null : d)).filter((d) => !!d), l.length && this._state.change({ searchScope: l }, !0);
        }
      } else
        this._state.change({ searchScope: null }, !0);
    })), n.appendChild(this._toggleSelectionFind.domNode), this._closeBtn = this._register(new fs({
      label: lD + this._keybindingLabelFor(se.CloseFindWidgetCommand),
      icon: c_,
      onTrigger: () => {
        this._state.change({ isRevealed: !1, searchScope: null }, !1);
      },
      onKeyDown: (l) => {
        l.equals(
          2
          /* KeyCode.Tab */
        ) && this._isReplaceVisible && (this._replaceBtn.isEnabled() ? this._replaceBtn.focus() : this._codeEditor.focus(), l.preventDefault());
      }
    })), this._replaceInput = this._register(new qh(null, void 0, {
      label: dD,
      placeholder: cD,
      appendPreserveCaseLabel: this._keybindingLabelFor(se.TogglePreserveCaseCommand),
      history: [],
      flexibleHeight: !0,
      flexibleWidth: !0,
      flexibleMaxHeight: 118,
      showHistoryHint: () => Ef(this._keybindingService),
      inputBoxStyles: Pp,
      toggleStyles: Mp
    }, this._contextKeyService, !0)), this._replaceInput.setPreserveCase(!!this._state.preserveCase), this._register(this._replaceInput.onKeyDown((l) => this._onReplaceInputKeyDown(l))), this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({ replaceString: this._replaceInput.inputBox.value }, !1);
    })), this._register(this._replaceInput.inputBox.onDidHeightChange((l) => {
      this._isReplaceVisible && this._tryUpdateHeight() && this._showViewZone();
    })), this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, !0);
    })), this._register(this._replaceInput.onPreserveCaseKeyDown((l) => {
      l.equals(
        2
        /* KeyCode.Tab */
      ) && (this._prevBtn.isEnabled() ? this._prevBtn.focus() : this._nextBtn.isEnabled() ? this._nextBtn.focus() : this._toggleSelectionFind.enabled ? this._toggleSelectionFind.focus() : this._closeBtn.isEnabled() && this._closeBtn.focus(), l.preventDefault());
    })), this._replaceBtn = this._register(new fs({
      label: hD + this._keybindingLabelFor(se.ReplaceOneAction),
      icon: YI,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (l) => {
        l.equals(
          1026
          /* KeyCode.Tab */
        ) && (this._closeBtn.focus(), l.preventDefault());
      }
    })), this._replaceAllBtn = this._register(new fs({
      label: uD + this._keybindingLabelFor(se.ReplaceAllAction),
      icon: JI,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }));
    const s = document.createElement("div");
    s.className = "replace-part", s.appendChild(this._replaceInput.domNode);
    const o = document.createElement("div");
    o.className = "replace-actions", s.appendChild(o), o.appendChild(this._replaceBtn.domNode), o.appendChild(this._replaceAllBtn.domNode), this._toggleReplaceBtn = this._register(new fs({
      label: gD,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, !1), this._isReplaceVisible && (this._replaceInput.width = lt(this._findInput.domNode), this._replaceInput.inputBox.layout()), this._showViewZone();
      }
    })), this._toggleReplaceBtn.setExpanded(this._isReplaceVisible), this._domNode = document.createElement("div"), this._domNode.className = "editor-widget find-widget", this._domNode.setAttribute("aria-hidden", "true"), this._domNode.ariaLabel = iD, this._domNode.role = "dialog", this._domNode.style.width = `${Qt}px`, this._domNode.appendChild(this._toggleReplaceBtn.domNode), this._domNode.appendChild(i), this._domNode.appendChild(this._closeBtn.domNode), this._domNode.appendChild(s), this._resizeSash = this._register(new Ds(this._domNode, this, { orientation: 0, size: 2 })), this._resized = !1;
    let a = Qt;
    this._register(this._resizeSash.onDidStart(() => {
      a = lt(this._domNode);
    })), this._register(this._resizeSash.onDidChange((l) => {
      this._resized = !0;
      const d = a + l.startX - l.currentX;
      if (d < Qt)
        return;
      const c = parseFloat(iw(this._domNode).maxWidth) || 0;
      d > c || (this._domNode.style.width = `${d}px`, this._isReplaceVisible && (this._replaceInput.width = lt(this._findInput.domNode)), this._findInput.inputBox.layout(), this._tryUpdateHeight());
    })), this._register(this._resizeSash.onDidReset(() => {
      const l = lt(this._domNode);
      if (l < Qt)
        return;
      let d = Qt;
      if (!this._resized || l === Qt) {
        const c = this._codeEditor.getLayoutInfo();
        d = c.width - 28 - c.minimap.minimapWidth - 15, this._resized = !0;
      }
      this._domNode.style.width = `${d}px`, this._isReplaceVisible && (this._replaceInput.width = lt(this._findInput.domNode)), this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const e = this._codeEditor.getOption(
      2
      /* EditorOption.accessibilitySupport */
    );
    this._findInput.setFocusInputOnOptionClick(
      e !== 2
      /* AccessibilitySupport.Enabled */
    );
  }
}
Fd.ID = "editor.contrib.findWidget";
class fs extends ea {
  constructor(e) {
    super(), this._opts = e;
    let t = "button";
    this._opts.className && (t = t + " " + this._opts.className), this._opts.icon && (t = t + " " + oe.asClassName(this._opts.icon)), this._domNode = document.createElement("div"), this._domNode.title = this._opts.label, this._domNode.tabIndex = 0, this._domNode.className = t, this._domNode.setAttribute("role", "button"), this._domNode.setAttribute("aria-label", this._opts.label), this.onclick(this._domNode, (i) => {
      this._opts.onTrigger(), i.preventDefault();
    }), this.onkeydown(this._domNode, (i) => {
      var n, s;
      if (i.equals(
        10
        /* KeyCode.Space */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) {
        this._opts.onTrigger(), i.preventDefault();
        return;
      }
      (s = (n = this._opts).onKeyDown) === null || s === void 0 || s.call(n, i);
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(e) {
    this._domNode.classList.toggle("disabled", !e), this._domNode.setAttribute("aria-disabled", String(!e)), this._domNode.tabIndex = e ? 0 : -1;
  }
  setExpanded(e) {
    this._domNode.setAttribute("aria-expanded", String(!!e)), e ? (this._domNode.classList.remove(...oe.asClassNameArray(Tf)), this._domNode.classList.add(...oe.asClassNameArray(Af))) : (this._domNode.classList.remove(...oe.asClassNameArray(Af)), this._domNode.classList.add(...oe.asClassNameArray(Tf)));
  }
}
od((r, e) => {
  const t = r.getColor(Bm);
  t && e.addRule(`.monaco-editor .findMatch { border: 1px ${gr(r.type) ? "dotted" : "solid"} ${t}; box-sizing: border-box; }`);
  const i = r.getColor(nw);
  i && e.addRule(`.monaco-editor .findScope { border: 1px ${gr(r.type) ? "dashed" : "solid"} ${i}; }`);
  const n = r.getColor(Di);
  n && e.addRule(`.monaco-editor .find-widget { border: 1px solid ${n}; }`);
});
var Ob = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ft = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Kh;
const bD = 524288;
function Gh(r, e = "single", t = !1) {
  if (!r.hasModel())
    return null;
  const i = r.getSelection();
  if (e === "single" && i.startLineNumber === i.endLineNumber || e === "multiple") {
    if (i.isEmpty()) {
      const n = r.getConfiguredWordAtPosition(i.getStartPosition());
      if (n && t === !1)
        return n.word;
    } else if (r.getModel().getValueLengthInRange(i) < bD)
      return r.getModel().getValueInRange(i);
  }
  return null;
}
let Ke = Kh = class extends P {
  get editor() {
    return this._editor;
  }
  static get(e) {
    return e.getContribution(Kh.ID);
  }
  constructor(e, t, i, n, s) {
    super(), this._editor = e, this._findWidgetVisible = Oi.bindTo(t), this._contextKeyService = t, this._storageService = i, this._clipboardService = n, this._notificationService = s, this._updateHistoryDelayer = new Vn(500), this._state = this._register(new qI()), this.loadQueryState(), this._register(this._state.onFindReplaceStateChange((o) => this._onStateChanged(o))), this._model = null, this._register(this._editor.onDidChangeModel(() => {
      const o = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel(), this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, !1),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, !1),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, !1),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, !1)
      }, !1), o && this._start({
        forceRevealReplace: !1,
        seedSearchStringFromSelection: "none",
        seedSearchStringFromNonEmptySelection: !1,
        seedSearchStringFromGlobalClipboard: !1,
        shouldFocus: 0,
        shouldAnimate: !1,
        updateSearchScope: !1,
        loop: this._editor.getOption(
          41
          /* EditorOption.find */
        ).loop
      });
    }));
  }
  dispose() {
    this.disposeModel(), super.dispose();
  }
  disposeModel() {
    this._model && (this._model.dispose(), this._model = null);
  }
  _onStateChanged(e) {
    this.saveQueryState(e), e.isRevealed && (this._state.isRevealed ? this._findWidgetVisible.set(!0) : (this._findWidgetVisible.reset(), this.disposeModel())), e.searchString && this.setGlobalBufferTerm(this._state.searchString);
  }
  saveQueryState(e) {
    e.isRegex && this._storageService.store(
      "editor.isRegex",
      this._state.actualIsRegex,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.wholeWord && this._storageService.store(
      "editor.wholeWord",
      this._state.actualWholeWord,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.matchCase && this._storageService.store(
      "editor.matchCase",
      this._state.actualMatchCase,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.preserveCase && this._storageService.store(
      "editor.preserveCase",
      this._state.actualPreserveCase,
      1,
      1
      /* StorageTarget.MACHINE */
    );
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, !1);
  }
  isFindInputFocused() {
    return !!Ad.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: !1,
      searchScope: null
    }, !1), this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({ matchCase: !this._state.matchCase }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleWholeWords() {
    this._state.change({ wholeWord: !this._state.wholeWord }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleRegex() {
    this._state.change({ isRegex: !this._state.isRegex }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  togglePreserveCase() {
    this._state.change({ preserveCase: !this._state.preserveCase }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleSearchScope() {
    if (this._state.searchScope)
      this._state.change({ searchScope: null }, !0);
    else if (this._editor.hasModel()) {
      let e = this._editor.getSelections();
      e = e.map((t) => (t.endColumn === 1 && t.endLineNumber > t.startLineNumber && (t = t.setEndPosition(t.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(t.endLineNumber - 1))), t.isEmpty() ? null : t)).filter((t) => !!t), e.length && this._state.change({ searchScope: e }, !0);
    }
  }
  setSearchString(e) {
    this._state.isRegex && (e = pr(e)), this._state.change({ searchString: e }, !1);
  }
  highlightFindOptions(e = !1) {
  }
  async _start(e, t) {
    if (this.disposeModel(), !this._editor.hasModel())
      return;
    const i = {
      ...t,
      isRevealed: !0
    };
    if (e.seedSearchStringFromSelection === "single") {
      const n = Gh(this._editor, e.seedSearchStringFromSelection, e.seedSearchStringFromNonEmptySelection);
      n && (this._state.isRegex ? i.searchString = pr(n) : i.searchString = n);
    } else if (e.seedSearchStringFromSelection === "multiple" && !e.updateSearchScope) {
      const n = Gh(this._editor, e.seedSearchStringFromSelection);
      n && (i.searchString = n);
    }
    if (!i.searchString && e.seedSearchStringFromGlobalClipboard) {
      const n = await this.getGlobalBufferTerm();
      if (!this._editor.hasModel())
        return;
      n && (i.searchString = n);
    }
    if (e.forceRevealReplace || i.isReplaceRevealed ? i.isReplaceRevealed = !0 : this._findWidgetVisible.get() || (i.isReplaceRevealed = !1), e.updateSearchScope) {
      const n = this._editor.getSelections();
      n.some((s) => !s.isEmpty()) && (i.searchScope = n);
    }
    i.loop = e.loop, this._state.change(i, !1), this._model || (this._model = new sr(this._editor, this._state));
  }
  start(e, t) {
    return this._start(e, t);
  }
  moveToNextMatch() {
    return this._model ? (this._model.moveToNextMatch(), !0) : !1;
  }
  moveToPrevMatch() {
    return this._model ? (this._model.moveToPrevMatch(), !0) : !1;
  }
  goToMatch(e) {
    return this._model ? (this._model.moveToMatch(e), !0) : !1;
  }
  replace() {
    return this._model ? (this._model.replace(), !0) : !1;
  }
  replaceAll() {
    var e;
    return this._model ? !((e = this._editor.getModel()) === null || e === void 0) && e.isTooLargeForHeapOperation() ? (this._notificationService.warn(g("too.large.for.replaceall", "The file is too large to perform a replace all operation.")), !1) : (this._model.replaceAll(), !0) : !1;
  }
  selectAllMatches() {
    return this._model ? (this._model.selectAllMatches(), this._editor.focus(), !0) : !1;
  }
  async getGlobalBufferTerm() {
    return this._editor.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing() ? this._clipboardService.readFindText() : "";
  }
  setGlobalBufferTerm(e) {
    this._editor.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing() && this._clipboardService.writeFindText(e);
  }
};
Ke.ID = "editor.contrib.findController";
Ke = Kh = Ob([
  Ft(1, ee),
  Ft(2, vn),
  Ft(3, ho),
  Ft(4, Je)
], Ke);
let Zh = class extends Ke {
  constructor(e, t, i, n, s, o, a, l) {
    super(e, i, a, l, o), this._contextViewService = t, this._keybindingService = n, this._themeService = s, this._widget = null, this._findOptionsWidget = null;
  }
  async _start(e, t) {
    this._widget || this._createFindWidget();
    const i = this._editor.getSelection();
    let n = !1;
    switch (this._editor.getOption(
      41
      /* EditorOption.find */
    ).autoFindInSelection) {
      case "always":
        n = !0;
        break;
      case "never":
        n = !1;
        break;
      case "multiline": {
        n = !!i && i.startLineNumber !== i.endLineNumber;
        break;
      }
    }
    e.updateSearchScope = e.updateSearchScope || n, await super._start(e, t), this._widget && (e.shouldFocus === 2 ? this._widget.focusReplaceInput() : e.shouldFocus === 1 && this._widget.focusFindInput());
  }
  highlightFindOptions(e = !1) {
    this._widget || this._createFindWidget(), this._state.isRevealed && !e ? this._widget.highlightFindOptions() : this._findOptionsWidget.highlightFindOptions();
  }
  _createFindWidget() {
    this._widget = this._register(new Fd(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService)), this._findOptionsWidget = this._register(new Od(this._editor, this._state, this._keybindingService));
  }
};
Zh = Ob([
  Ft(1, sd),
  Ft(2, ee),
  Ft(3, xe),
  Ft(4, Mt),
  Ft(5, Je),
  Ft(6, vn),
  Ft(7, ho)
], Zh);
const CD = h_(new u_({
  id: se.StartFindAction,
  label: g("startFindAction", "Find"),
  alias: "Find",
  precondition: L.or(b.focus, L.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2084,
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: E.MenubarEditMenu,
    group: "3_find",
    title: g({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
    order: 1
  }
}));
CD.addImplementation(0, (r, e, t) => {
  const i = Ke.get(e);
  return i ? i.start({
    forceRevealReplace: !1,
    seedSearchStringFromSelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never" ? "single" : "none",
    seedSearchStringFromNonEmptySelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: e.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard,
    shouldFocus: 1,
    shouldAnimate: !0,
    updateSearchScope: !1,
    loop: e.getOption(
      41
      /* EditorOption.find */
    ).loop
  }) : !1;
});
const SD = {
  description: "Open a new In-Editor Find Widget.",
  args: [{
    name: "Open a new In-Editor Find Widget args",
    schema: {
      properties: {
        searchString: { type: "string" },
        replaceString: { type: "string" },
        isRegex: { type: "boolean" },
        matchWholeWord: { type: "boolean" },
        isCaseSensitive: { type: "boolean" },
        preserveCase: { type: "boolean" },
        findInSelection: { type: "boolean" }
      }
    }
  }]
};
class wD extends D {
  constructor() {
    super({
      id: se.StartFindWithArgs,
      label: g("startFindWithArgsAction", "Find With Arguments"),
      alias: "Find With Arguments",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: SD
    });
  }
  async run(e, t, i) {
    const n = Ke.get(t);
    if (n) {
      const s = i ? {
        searchString: i.searchString,
        replaceString: i.replaceString,
        isReplaceRevealed: i.replaceString !== void 0,
        isRegex: i.isRegex,
        // isRegexOverride: args.regexOverride,
        wholeWord: i.matchWholeWord,
        // wholeWordOverride: args.wholeWordOverride,
        matchCase: i.isCaseSensitive,
        // matchCaseOverride: args.matchCaseOverride,
        preserveCase: i.preserveCase
        // preserveCaseOverride: args.preserveCaseOverride,
      } : {};
      await n.start({
        forceRevealReplace: !1,
        seedSearchStringFromSelection: n.getState().searchString.length === 0 && t.getOption(
          41
          /* EditorOption.find */
        ).seedSearchStringFromSelection !== "never" ? "single" : "none",
        seedSearchStringFromNonEmptySelection: t.getOption(
          41
          /* EditorOption.find */
        ).seedSearchStringFromSelection === "selection",
        seedSearchStringFromGlobalClipboard: !0,
        shouldFocus: 1,
        shouldAnimate: !0,
        updateSearchScope: (i == null ? void 0 : i.findInSelection) || !1,
        loop: t.getOption(
          41
          /* EditorOption.find */
        ).loop
      }, s), n.setGlobalBufferTerm(n.getState().searchString);
    }
  }
}
class yD extends D {
  constructor() {
    super({
      id: se.StartFindWithSelection,
      label: g("startFindWithSelectionAction", "Find With Selection"),
      alias: "Find With Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2083
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    const i = Ke.get(t);
    i && (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: "multiple",
      seedSearchStringFromNonEmptySelection: !1,
      seedSearchStringFromGlobalClipboard: !1,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), i.setGlobalBufferTerm(i.getState().searchString));
  }
}
class Fb extends D {
  async run(e, t) {
    const i = Ke.get(t);
    i && !this._run(i) && (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: i.getState().searchString.length === 0 && t.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection !== "never" ? "single" : "none",
      seedSearchStringFromNonEmptySelection: t.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection === "selection",
      seedSearchStringFromGlobalClipboard: !0,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), this._run(i));
  }
}
class xD extends Fb {
  constructor() {
    super({
      id: se.NextMatchFindAction,
      label: g("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: [{
        kbExpr: b.focus,
        primary: 61,
        mac: { primary: 2085, secondary: [
          61
          /* KeyCode.F3 */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        kbExpr: L.and(b.focus, Ad),
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    });
  }
  _run(e) {
    return e.moveToNextMatch() ? (e.editor.pushUndoStop(), !0) : !1;
  }
}
class LD extends Fb {
  constructor() {
    super({
      id: se.PreviousMatchFindAction,
      label: g("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: [
        {
          kbExpr: b.focus,
          primary: 1085,
          mac: { primary: 3109, secondary: [
            1085
            /* KeyCode.F3 */
          ] },
          weight: 100
          /* KeybindingWeight.EditorContrib */
        },
        {
          kbExpr: L.and(b.focus, Ad),
          primary: 1027,
          weight: 100
          /* KeybindingWeight.EditorContrib */
        }
      ]
    });
  }
  _run(e) {
    return e.moveToPrevMatch();
  }
}
class ID extends D {
  constructor() {
    super({
      id: se.GoToMatchFindAction,
      label: g("findMatchAction.goToMatch", "Go to Match..."),
      alias: "Go to Match...",
      precondition: Oi
    }), this._highlightDecorations = [];
  }
  run(e, t, i) {
    const n = Ke.get(t);
    if (!n)
      return;
    const s = n.getState().matchesCount;
    if (s < 1) {
      e.get(Je).notify({
        severity: mg.Warning,
        message: g("findMatchAction.noResults", "No matches. Try searching for something else.")
      });
      return;
    }
    const a = e.get(Ei).createInputBox();
    a.placeholder = g("findMatchAction.inputPlaceHolder", "Type a number to go to a specific match (between 1 and {0})", s);
    const l = (c) => {
      const h = parseInt(c);
      if (isNaN(h))
        return;
      const u = n.getState().matchesCount;
      if (h > 0 && h <= u)
        return h - 1;
      if (h < 0 && h >= -u)
        return u + h;
    }, d = (c) => {
      const h = l(c);
      if (typeof h == "number") {
        a.validationMessage = void 0, n.goToMatch(h);
        const u = n.getState().currentMatch;
        u && this.addDecorations(t, u);
      } else
        a.validationMessage = g("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", n.getState().matchesCount), this.clearDecorations(t);
    };
    a.onDidChangeValue((c) => {
      d(c);
    }), a.onDidAccept(() => {
      const c = l(a.value);
      typeof c == "number" ? (n.goToMatch(c), a.hide()) : a.validationMessage = g("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", n.getState().matchesCount);
    }), a.onDidHide(() => {
      this.clearDecorations(t), a.dispose();
    }), a.show();
  }
  clearDecorations(e) {
    e.changeDecorations((t) => {
      this._highlightDecorations = t.deltaDecorations(this._highlightDecorations, []);
    });
  }
  addDecorations(e, t) {
    e.changeDecorations((i) => {
      this._highlightDecorations = i.deltaDecorations(this._highlightDecorations, [
        {
          range: t,
          options: {
            description: "find-match-quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: !0
          }
        },
        {
          range: t,
          options: {
            description: "find-match-quick-access-range-highlight-overview",
            overviewRuler: {
              color: Se(g_),
              position: ci.Full
            }
          }
        }
      ]);
    });
  }
}
class Wb extends D {
  async run(e, t) {
    const i = Ke.get(t);
    if (!i)
      return;
    const n = Gh(t, "single", !1);
    n && i.setSearchString(n), this._run(i) || (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: "none",
      seedSearchStringFromNonEmptySelection: !1,
      seedSearchStringFromGlobalClipboard: !1,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), this._run(i));
  }
}
class DD extends Wb {
  constructor() {
    super({
      id: se.NextSelectionMatchFindAction,
      label: g("nextSelectionMatchFindAction", "Find Next Selection"),
      alias: "Find Next Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 2109,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(e) {
    return e.moveToNextMatch();
  }
}
class kD extends Wb {
  constructor() {
    super({
      id: se.PreviousSelectionMatchFindAction,
      label: g("previousSelectionMatchFindAction", "Find Previous Selection"),
      alias: "Find Previous Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 3133,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(e) {
    return e.moveToPrevMatch();
  }
}
const ND = h_(new u_({
  id: se.StartFindReplaceAction,
  label: g("startReplace", "Replace"),
  alias: "Replace",
  precondition: L.or(b.focus, L.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2086,
    mac: {
      primary: 2596
      /* KeyCode.KeyF */
    },
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: E.MenubarEditMenu,
    group: "3_find",
    title: g({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
    order: 2
  }
}));
ND.addImplementation(0, (r, e, t) => {
  if (!e.hasModel() || e.getOption(
    91
    /* EditorOption.readOnly */
  ))
    return !1;
  const i = Ke.get(e);
  if (!i)
    return !1;
  const n = e.getSelection(), s = i.isFindInputFocused(), o = !n.isEmpty() && n.startLineNumber === n.endLineNumber && e.getOption(
    41
    /* EditorOption.find */
  ).seedSearchStringFromSelection !== "never" && !s, a = s || o ? 2 : 1;
  return i.start({
    forceRevealReplace: !0,
    seedSearchStringFromSelection: o ? "single" : "none",
    seedSearchStringFromNonEmptySelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never",
    shouldFocus: a,
    shouldAnimate: !0,
    updateSearchScope: !1,
    loop: e.getOption(
      41
      /* EditorOption.find */
    ).loop
  });
});
Z(
  Ke.ID,
  Zh,
  0
  /* EditorContributionInstantiation.Eager */
);
x(wD);
x(yD);
x(xD);
x(LD);
x(ID);
x(DD);
x(kD);
const Xt = bt.bindToContribution(Ke.get);
B(new Xt({
  id: se.CloseFindWidgetCommand,
  precondition: Oi,
  handler: (r) => r.closeFindWidget(),
  kbOpts: {
    weight: 105,
    kbExpr: L.and(b.focus, L.not("isComposing")),
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
B(new Xt({
  id: se.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (r) => r.toggleCaseSensitive(),
  kbOpts: {
    weight: 105,
    kbExpr: b.focus,
    primary: Va.primary,
    mac: Va.mac,
    win: Va.win,
    linux: Va.linux
  }
}));
B(new Xt({
  id: se.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (r) => r.toggleWholeWords(),
  kbOpts: {
    weight: 105,
    kbExpr: b.focus,
    primary: Ua.primary,
    mac: Ua.mac,
    win: Ua.win,
    linux: Ua.linux
  }
}));
B(new Xt({
  id: se.ToggleRegexCommand,
  precondition: void 0,
  handler: (r) => r.toggleRegex(),
  kbOpts: {
    weight: 105,
    kbExpr: b.focus,
    primary: za.primary,
    mac: za.mac,
    win: za.win,
    linux: za.linux
  }
}));
B(new Xt({
  id: se.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (r) => r.toggleSearchScope(),
  kbOpts: {
    weight: 105,
    kbExpr: b.focus,
    primary: $a.primary,
    mac: $a.mac,
    win: $a.win,
    linux: $a.linux
  }
}));
B(new Xt({
  id: se.TogglePreserveCaseCommand,
  precondition: void 0,
  handler: (r) => r.togglePreserveCase(),
  kbOpts: {
    weight: 105,
    kbExpr: b.focus,
    primary: ja.primary,
    mac: ja.mac,
    win: ja.win,
    linux: ja.linux
  }
}));
B(new Xt({
  id: se.ReplaceOneAction,
  precondition: Oi,
  handler: (r) => r.replace(),
  kbOpts: {
    weight: 105,
    kbExpr: b.focus,
    primary: 3094
    /* KeyCode.Digit1 */
  }
}));
B(new Xt({
  id: se.ReplaceOneAction,
  precondition: Oi,
  handler: (r) => r.replace(),
  kbOpts: {
    weight: 105,
    kbExpr: L.and(b.focus, jg),
    primary: 3
    /* KeyCode.Enter */
  }
}));
B(new Xt({
  id: se.ReplaceAllAction,
  precondition: Oi,
  handler: (r) => r.replaceAll(),
  kbOpts: {
    weight: 105,
    kbExpr: b.focus,
    primary: 2563
    /* KeyCode.Enter */
  }
}));
B(new Xt({
  id: se.ReplaceAllAction,
  precondition: Oi,
  handler: (r) => r.replaceAll(),
  kbOpts: {
    weight: 105,
    kbExpr: L.and(b.focus, jg),
    primary: void 0,
    mac: {
      primary: 2051
    }
  }
}));
B(new Xt({
  id: se.SelectAllMatchesAction,
  precondition: Oi,
  handler: (r) => r.selectAllMatches(),
  kbOpts: {
    weight: 105,
    kbExpr: b.focus,
    primary: 515
    /* KeyCode.Enter */
  }
}));
const RD = {
  0: " ",
  1: "u",
  2: "r"
}, Vf = 65535, Wt = 16777215, Uf = 4278190080;
class Fc {
  constructor(e) {
    const t = Math.ceil(e / 32);
    this._states = new Uint32Array(t);
  }
  get(e) {
    const t = e / 32 | 0, i = e % 32;
    return (this._states[t] & 1 << i) !== 0;
  }
  set(e, t) {
    const i = e / 32 | 0, n = e % 32, s = this._states[i];
    t ? this._states[i] = s | 1 << n : this._states[i] = s & ~(1 << n);
  }
}
class gt {
  constructor(e, t, i) {
    if (e.length !== t.length || e.length > Vf)
      throw new Error("invalid startIndexes or endIndexes size");
    this._startIndexes = e, this._endIndexes = t, this._collapseStates = new Fc(e.length), this._userDefinedStates = new Fc(e.length), this._recoveredStates = new Fc(e.length), this._types = i, this._parentsComputed = !1;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = !0;
      const e = [], t = (i, n) => {
        const s = e[e.length - 1];
        return this.getStartLineNumber(s) <= i && this.getEndLineNumber(s) >= n;
      };
      for (let i = 0, n = this._startIndexes.length; i < n; i++) {
        const s = this._startIndexes[i], o = this._endIndexes[i];
        if (s > Wt || o > Wt)
          throw new Error("startLineNumber or endLineNumber must not exceed " + Wt);
        for (; e.length > 0 && !t(s, o); )
          e.pop();
        const a = e.length > 0 ? e[e.length - 1] : -1;
        e.push(i), this._startIndexes[i] = s + ((a & 255) << 24), this._endIndexes[i] = o + ((a & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(e) {
    return this._startIndexes[e] & Wt;
  }
  getEndLineNumber(e) {
    return this._endIndexes[e] & Wt;
  }
  getType(e) {
    return this._types ? this._types[e] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(e) {
    return this._collapseStates.get(e);
  }
  setCollapsed(e, t) {
    this._collapseStates.set(e, t);
  }
  isUserDefined(e) {
    return this._userDefinedStates.get(e);
  }
  setUserDefined(e, t) {
    return this._userDefinedStates.set(e, t);
  }
  isRecovered(e) {
    return this._recoveredStates.get(e);
  }
  setRecovered(e, t) {
    return this._recoveredStates.set(e, t);
  }
  getSource(e) {
    return this.isUserDefined(e) ? 1 : this.isRecovered(e) ? 2 : 0;
  }
  setSource(e, t) {
    t === 1 ? (this.setUserDefined(e, !0), this.setRecovered(e, !1)) : t === 2 ? (this.setUserDefined(e, !1), this.setRecovered(e, !0)) : (this.setUserDefined(e, !1), this.setRecovered(e, !1));
  }
  setCollapsedAllOfType(e, t) {
    let i = !1;
    if (this._types)
      for (let n = 0; n < this._types.length; n++)
        this._types[n] === e && (this.setCollapsed(n, t), i = !0);
    return i;
  }
  toRegion(e) {
    return new PD(this, e);
  }
  getParentIndex(e) {
    this.ensureParentIndices();
    const t = ((this._startIndexes[e] & Uf) >>> 24) + ((this._endIndexes[e] & Uf) >>> 16);
    return t === Vf ? -1 : t;
  }
  contains(e, t) {
    return this.getStartLineNumber(e) <= t && this.getEndLineNumber(e) >= t;
  }
  findIndex(e) {
    let t = 0, i = this._startIndexes.length;
    if (i === 0)
      return -1;
    for (; t < i; ) {
      const n = Math.floor((t + i) / 2);
      e < this.getStartLineNumber(n) ? i = n : t = n + 1;
    }
    return t - 1;
  }
  findRange(e) {
    let t = this.findIndex(e);
    if (t >= 0) {
      if (this.getEndLineNumber(t) >= e)
        return t;
      for (t = this.getParentIndex(t); t !== -1; ) {
        if (this.contains(t, e))
          return t;
        t = this.getParentIndex(t);
      }
    }
    return -1;
  }
  toString() {
    const e = [];
    for (let t = 0; t < this.length; t++)
      e[t] = `[${RD[this.getSource(t)]}${this.isCollapsed(t) ? "+" : "-"}] ${this.getStartLineNumber(t)}/${this.getEndLineNumber(t)}`;
    return e.join(", ");
  }
  toFoldRange(e) {
    return {
      startLineNumber: this._startIndexes[e] & Wt,
      endLineNumber: this._endIndexes[e] & Wt,
      type: this._types ? this._types[e] : void 0,
      isCollapsed: this.isCollapsed(e),
      source: this.getSource(e)
    };
  }
  static fromFoldRanges(e) {
    const t = e.length, i = new Uint32Array(t), n = new Uint32Array(t);
    let s = [], o = !1;
    for (let l = 0; l < t; l++) {
      const d = e[l];
      i[l] = d.startLineNumber, n[l] = d.endLineNumber, s.push(d.type), d.type && (o = !0);
    }
    o || (s = void 0);
    const a = new gt(i, n, s);
    for (let l = 0; l < t; l++)
      e[l].isCollapsed && a.setCollapsed(l, !0), a.setSource(l, e[l].source);
    return a;
  }
  /**
   * Two inputs, each a FoldingRegions or a FoldRange[], are merged.
   * Each input must be pre-sorted on startLineNumber.
   * The first list is assumed to always include all regions currently defined by range providers.
   * The second list only contains the previously collapsed and all manual ranges.
   * If the line position matches, the range of the new range is taken, and the range is no longer manual
   * When an entry in one list overlaps an entry in the other, the second list's entry "wins" and
   * overlapping entries in the first list are discarded.
   * Invalid entries are discarded. An entry is invalid if:
   * 		the start and end line numbers aren't a valid range of line numbers,
   * 		it is out of sequence or has the same start line as a preceding entry,
   * 		it overlaps a preceding entry and is not fully contained by that entry.
   */
  static sanitizeAndMerge(e, t, i) {
    i = i ?? Number.MAX_VALUE;
    const n = (m, _) => Array.isArray(m) ? (v) => v < _ ? m[v] : void 0 : (v) => v < _ ? m.toFoldRange(v) : void 0, s = n(e, e.length), o = n(t, t.length);
    let a = 0, l = 0, d = s(0), c = o(0);
    const h = [];
    let u, p = 0;
    const f = [];
    for (; d || c; ) {
      let m;
      if (c && (!d || d.startLineNumber >= c.startLineNumber))
        d && d.startLineNumber === c.startLineNumber ? (c.source === 1 ? m = c : (m = d, m.isCollapsed = c.isCollapsed && d.endLineNumber === c.endLineNumber, m.source = 0), d = s(++a)) : (m = c, c.isCollapsed && c.source === 0 && (m.source = 2)), c = o(++l);
      else {
        let _ = l, v = c;
        for (; ; ) {
          if (!v || v.startLineNumber > d.endLineNumber) {
            m = d;
            break;
          }
          if (v.source === 1 && v.endLineNumber > d.endLineNumber)
            break;
          v = o(++_);
        }
        d = s(++a);
      }
      if (m) {
        for (; u && u.endLineNumber < m.startLineNumber; )
          u = h.pop();
        m.endLineNumber > m.startLineNumber && m.startLineNumber > p && m.endLineNumber <= i && (!u || u.endLineNumber >= m.endLineNumber) && (f.push(m), p = m.startLineNumber, u && h.push(u), u = m);
      }
    }
    return f;
  }
}
class PD {
  constructor(e, t) {
    this.ranges = e, this.index = t;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(e) {
    return e.startLineNumber <= this.startLineNumber && e.endLineNumber >= this.endLineNumber;
  }
  containsLine(e) {
    return this.startLineNumber <= e && e <= this.endLineNumber;
  }
}
class MD {
  get regions() {
    return this._regions;
  }
  get textModel() {
    return this._textModel;
  }
  constructor(e, t) {
    this._updateEventEmitter = new G(), this.onDidChange = this._updateEventEmitter.event, this._textModel = e, this._decorationProvider = t, this._regions = new gt(new Uint32Array(0), new Uint32Array(0)), this._editorDecorationIds = [];
  }
  toggleCollapseState(e) {
    if (!e.length)
      return;
    e = e.sort((i, n) => i.regionIndex - n.regionIndex);
    const t = {};
    this._decorationProvider.changeDecorations((i) => {
      let n = 0, s = -1, o = -1;
      const a = (l) => {
        for (; n < l; ) {
          const d = this._regions.getEndLineNumber(n), c = this._regions.isCollapsed(n);
          if (d <= s) {
            const h = this.regions.getSource(n) !== 0;
            i.changeDecorationOptions(this._editorDecorationIds[n], this._decorationProvider.getDecorationOption(c, d <= o, h));
          }
          c && d > o && (o = d), n++;
        }
      };
      for (const l of e) {
        const d = l.regionIndex, c = this._editorDecorationIds[d];
        if (c && !t[c]) {
          t[c] = !0, a(d);
          const h = !this._regions.isCollapsed(d);
          this._regions.setCollapsed(d, h), s = Math.max(s, this._regions.getEndLineNumber(d));
        }
      }
      a(this._regions.length);
    }), this._updateEventEmitter.fire({ model: this, collapseStateChanged: e });
  }
  removeManualRanges(e) {
    const t = new Array(), i = (n) => {
      for (const s of e)
        if (!(s.startLineNumber > n.endLineNumber || n.startLineNumber > s.endLineNumber))
          return !0;
      return !1;
    };
    for (let n = 0; n < this._regions.length; n++) {
      const s = this._regions.toFoldRange(n);
      (s.source === 0 || !i(s)) && t.push(s);
    }
    this.updatePost(gt.fromFoldRanges(t));
  }
  update(e, t = []) {
    const i = this._currentFoldedOrManualRanges(t), n = gt.sanitizeAndMerge(e, i, this._textModel.getLineCount());
    this.updatePost(gt.fromFoldRanges(n));
  }
  updatePost(e) {
    const t = [];
    let i = -1;
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e.getStartLineNumber(n), a = e.getEndLineNumber(n), l = e.isCollapsed(n), d = e.getSource(n) !== 0, c = {
        startLineNumber: o,
        startColumn: this._textModel.getLineMaxColumn(o),
        endLineNumber: a,
        endColumn: this._textModel.getLineMaxColumn(a) + 1
      };
      t.push({ range: c, options: this._decorationProvider.getDecorationOption(l, a <= i, d) }), l && a > i && (i = a);
    }
    this._decorationProvider.changeDecorations((n) => this._editorDecorationIds = n.deltaDecorations(this._editorDecorationIds, t)), this._regions = e, this._updateEventEmitter.fire({ model: this });
  }
  _currentFoldedOrManualRanges(e = []) {
    const t = (n, s) => {
      for (const o of e)
        if (n < o && o <= s)
          return !0;
      return !1;
    }, i = [];
    for (let n = 0, s = this._regions.length; n < s; n++) {
      let o = this.regions.isCollapsed(n);
      const a = this.regions.getSource(n);
      if (o || a !== 0) {
        const l = this._regions.toFoldRange(n), d = this._textModel.getDecorationRange(this._editorDecorationIds[n]);
        d && (o && t(d.startLineNumber, d.endLineNumber) && (o = !1), i.push({
          startLineNumber: d.startLineNumber,
          endLineNumber: d.endLineNumber,
          type: l.type,
          isCollapsed: o,
          source: a
        }));
      }
    }
    return i;
  }
  /**
   * Collapse state memento, for persistence only
   */
  getMemento() {
    const e = this._currentFoldedOrManualRanges(), t = [], i = this._textModel.getLineCount();
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      if (o.startLineNumber >= o.endLineNumber || o.startLineNumber < 1 || o.endLineNumber > i)
        continue;
      const a = this._getLinesChecksum(o.startLineNumber + 1, o.endLineNumber);
      t.push({
        startLineNumber: o.startLineNumber,
        endLineNumber: o.endLineNumber,
        isCollapsed: o.isCollapsed,
        source: o.source,
        checksum: a
      });
    }
    return t.length > 0 ? t : void 0;
  }
  /**
   * Apply persisted state, for persistence only
   */
  applyMemento(e) {
    var t, i;
    if (!Array.isArray(e))
      return;
    const n = [], s = this._textModel.getLineCount();
    for (const a of e) {
      if (a.startLineNumber >= a.endLineNumber || a.startLineNumber < 1 || a.endLineNumber > s)
        continue;
      const l = this._getLinesChecksum(a.startLineNumber + 1, a.endLineNumber);
      (!a.checksum || l === a.checksum) && n.push({
        startLineNumber: a.startLineNumber,
        endLineNumber: a.endLineNumber,
        type: void 0,
        isCollapsed: (t = a.isCollapsed) !== null && t !== void 0 ? t : !0,
        source: (i = a.source) !== null && i !== void 0 ? i : 0
        /* FoldSource.provider */
      });
    }
    const o = gt.sanitizeAndMerge(this._regions, n, s);
    this.updatePost(gt.fromFoldRanges(o));
  }
  _getLinesChecksum(e, t) {
    return p_(this._textModel.getLineContent(e) + this._textModel.getLineContent(t)) % 1e6;
  }
  dispose() {
    this._decorationProvider.removeDecorations(this._editorDecorationIds);
  }
  getAllRegionsAtLine(e, t) {
    const i = [];
    if (this._regions) {
      let n = this._regions.findRange(e), s = 1;
      for (; n >= 0; ) {
        const o = this._regions.toRegion(n);
        (!t || t(o, s)) && i.push(o), s++, n = o.parentIndex;
      }
    }
    return i;
  }
  getRegionAtLine(e) {
    if (this._regions) {
      const t = this._regions.findRange(e);
      if (t >= 0)
        return this._regions.toRegion(t);
    }
    return null;
  }
  getRegionsInside(e, t) {
    const i = [], n = e ? e.regionIndex + 1 : 0, s = e ? e.endLineNumber : Number.MAX_VALUE;
    if (t && t.length === 2) {
      const o = [];
      for (let a = n, l = this._regions.length; a < l; a++) {
        const d = this._regions.toRegion(a);
        if (this._regions.getStartLineNumber(a) < s) {
          for (; o.length > 0 && !d.containedBy(o[o.length - 1]); )
            o.pop();
          o.push(d), t(d, o.length) && i.push(d);
        } else
          break;
      }
    } else
      for (let o = n, a = this._regions.length; o < a; o++) {
        const l = this._regions.toRegion(o);
        if (this._regions.getStartLineNumber(o) < s)
          (!t || t(l)) && i.push(l);
        else
          break;
      }
    return i;
  }
}
function Hb(r, e, t) {
  const i = [];
  for (const n of t) {
    const s = r.getRegionAtLine(n);
    if (s) {
      const o = !s.isCollapsed;
      if (i.push(s), e > 1) {
        const a = r.getRegionsInside(s, (l, d) => l.isCollapsed !== o && d < e);
        i.push(...a);
      }
    }
  }
  r.toggleCollapseState(i);
}
function So(r, e, t = Number.MAX_VALUE, i) {
  const n = [];
  if (i && i.length > 0)
    for (const s of i) {
      const o = r.getRegionAtLine(s);
      if (o && (o.isCollapsed !== e && n.push(o), t > 1)) {
        const a = r.getRegionsInside(o, (l, d) => l.isCollapsed !== e && d < t);
        n.push(...a);
      }
    }
  else {
    const s = r.getRegionsInside(null, (o, a) => o.isCollapsed !== e && a < t);
    n.push(...s);
  }
  r.toggleCollapseState(n);
}
function Bb(r, e, t, i) {
  const n = [];
  for (const s of i) {
    const o = r.getAllRegionsAtLine(s, (a, l) => a.isCollapsed !== e && l <= t);
    n.push(...o);
  }
  r.toggleCollapseState(n);
}
function ED(r, e, t) {
  const i = [];
  for (const n of t) {
    const s = r.getAllRegionsAtLine(n, (o) => o.isCollapsed !== e);
    s.length > 0 && i.push(s[0]);
  }
  r.toggleCollapseState(i);
}
function TD(r, e, t, i) {
  const n = (o, a) => a === e && o.isCollapsed !== t && !i.some((l) => o.containsLine(l)), s = r.getRegionsInside(null, n);
  r.toggleCollapseState(s);
}
function Vb(r, e, t) {
  const i = [];
  for (const o of t) {
    const a = r.getAllRegionsAtLine(o, void 0);
    a.length > 0 && i.push(a[0]);
  }
  const n = (o) => i.every((a) => !a.containedBy(o) && !o.containedBy(a)) && o.isCollapsed !== e, s = r.getRegionsInside(null, n);
  r.toggleCollapseState(s);
}
function Gg(r, e, t) {
  const i = r.textModel, n = r.regions, s = [];
  for (let o = n.length - 1; o >= 0; o--)
    if (t !== n.isCollapsed(o)) {
      const a = n.getStartLineNumber(o);
      e.test(i.getLineContent(a)) && s.push(n.toRegion(o));
    }
  r.toggleCollapseState(s);
}
function Zg(r, e, t) {
  const i = r.regions, n = [];
  for (let s = i.length - 1; s >= 0; s--)
    t !== i.isCollapsed(s) && e === i.getType(s) && n.push(i.toRegion(s));
  r.toggleCollapseState(n);
}
function AD(r, e) {
  let t = null;
  const i = e.getRegionAtLine(r);
  if (i !== null && (t = i.startLineNumber, r === t)) {
    const n = i.parentIndex;
    n !== -1 ? t = e.regions.getStartLineNumber(n) : t = null;
  }
  return t;
}
function OD(r, e) {
  let t = e.getRegionAtLine(r);
  if (t !== null && t.startLineNumber === r) {
    if (r !== t.startLineNumber)
      return t.startLineNumber;
    {
      const i = t.parentIndex;
      let n = 0;
      for (i !== -1 && (n = e.regions.getStartLineNumber(t.parentIndex)); t !== null; )
        if (t.regionIndex > 0) {
          if (t = e.regions.toRegion(t.regionIndex - 1), t.startLineNumber <= n)
            return null;
          if (t.parentIndex === i)
            return t.startLineNumber;
        } else
          return null;
    }
  } else if (e.regions.length > 0)
    for (t = e.regions.toRegion(e.regions.length - 1); t !== null; ) {
      if (t.startLineNumber < r)
        return t.startLineNumber;
      t.regionIndex > 0 ? t = e.regions.toRegion(t.regionIndex - 1) : t = null;
    }
  return null;
}
function FD(r, e) {
  let t = e.getRegionAtLine(r);
  if (t !== null && t.startLineNumber === r) {
    const i = t.parentIndex;
    let n = 0;
    if (i !== -1)
      n = e.regions.getEndLineNumber(t.parentIndex);
    else {
      if (e.regions.length === 0)
        return null;
      n = e.regions.getEndLineNumber(e.regions.length - 1);
    }
    for (; t !== null; )
      if (t.regionIndex < e.regions.length) {
        if (t = e.regions.toRegion(t.regionIndex + 1), t.startLineNumber >= n)
          return null;
        if (t.parentIndex === i)
          return t.startLineNumber;
      } else
        return null;
  } else if (e.regions.length > 0)
    for (t = e.regions.toRegion(0); t !== null; ) {
      if (t.startLineNumber > r)
        return t.startLineNumber;
      t.regionIndex < e.regions.length ? t = e.regions.toRegion(t.regionIndex + 1) : t = null;
    }
  return null;
}
class WD {
  get onDidChange() {
    return this._updateEventEmitter.event;
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  constructor(e) {
    this._updateEventEmitter = new G(), this._hasLineChanges = !1, this._foldingModel = e, this._foldingModelListener = e.onDidChange((t) => this.updateHiddenRanges()), this._hiddenRanges = [], e.regions.length && this.updateHiddenRanges();
  }
  notifyChangeModelContent(e) {
    this._hiddenRanges.length && !this._hasLineChanges && (this._hasLineChanges = e.changes.some((t) => t.range.endLineNumber !== t.range.startLineNumber || sw(t.text)[0] !== 0));
  }
  updateHiddenRanges() {
    let e = !1;
    const t = [];
    let i = 0, n = 0, s = Number.MAX_VALUE, o = -1;
    const a = this._foldingModel.regions;
    for (; i < a.length; i++) {
      if (!a.isCollapsed(i))
        continue;
      const l = a.getStartLineNumber(i) + 1, d = a.getEndLineNumber(i);
      s <= l && d <= o || (!e && n < this._hiddenRanges.length && this._hiddenRanges[n].startLineNumber === l && this._hiddenRanges[n].endLineNumber === d ? (t.push(this._hiddenRanges[n]), n++) : (e = !0, t.push(new S(l, 1, d, 1))), s = l, o = d);
    }
    (this._hasLineChanges || e || n < this._hiddenRanges.length) && this.applyHiddenRanges(t);
  }
  applyHiddenRanges(e) {
    this._hiddenRanges = e, this._hasLineChanges = !1, this._updateEventEmitter.fire(e);
  }
  hasRanges() {
    return this._hiddenRanges.length > 0;
  }
  isHidden(e) {
    return zf(this._hiddenRanges, e) !== null;
  }
  adjustSelections(e) {
    let t = !1;
    const i = this._foldingModel.textModel;
    let n = null;
    const s = (o) => ((!n || !HD(o, n)) && (n = zf(this._hiddenRanges, o)), n ? n.startLineNumber - 1 : null);
    for (let o = 0, a = e.length; o < a; o++) {
      let l = e[o];
      const d = s(l.startLineNumber);
      d && (l = l.setStartPosition(d, i.getLineMaxColumn(d)), t = !0);
      const c = s(l.endLineNumber);
      c && (l = l.setEndPosition(c, i.getLineMaxColumn(c)), t = !0), e[o] = l;
    }
    return t;
  }
  dispose() {
    this.hiddenRanges.length > 0 && (this._hiddenRanges = [], this._updateEventEmitter.fire(this._hiddenRanges)), this._foldingModelListener && (this._foldingModelListener.dispose(), this._foldingModelListener = null);
  }
}
function HD(r, e) {
  return r >= e.startLineNumber && r <= e.endLineNumber;
}
function zf(r, e) {
  const t = o_(r, (i) => e < i.startLineNumber) - 1;
  return t >= 0 && r[t].endLineNumber >= e ? r[t] : null;
}
const BD = 5e3, VD = "indent";
class Xg {
  constructor(e, t, i) {
    this.editorModel = e, this.languageConfigurationService = t, this.foldingRangesLimit = i, this.id = VD;
  }
  dispose() {
  }
  compute(e) {
    const t = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules, i = t && !!t.offSide, n = t && t.markers;
    return Promise.resolve($D(this.editorModel, i, n, this.foldingRangesLimit));
  }
}
let UD = class {
  constructor(e) {
    this._startIndexes = [], this._endIndexes = [], this._indentOccurrences = [], this._length = 0, this._foldingRangesLimit = e;
  }
  insertFirst(e, t, i) {
    if (e > Wt || t > Wt)
      return;
    const n = this._length;
    this._startIndexes[n] = e, this._endIndexes[n] = t, this._length++, i < 1e3 && (this._indentOccurrences[i] = (this._indentOccurrences[i] || 0) + 1);
  }
  toIndentRanges(e) {
    const t = this._foldingRangesLimit.limit;
    if (this._length <= t) {
      this._foldingRangesLimit.update(this._length, !1);
      const i = new Uint32Array(this._length), n = new Uint32Array(this._length);
      for (let s = this._length - 1, o = 0; s >= 0; s--, o++)
        i[o] = this._startIndexes[s], n[o] = this._endIndexes[s];
      return new gt(i, n);
    } else {
      this._foldingRangesLimit.update(this._length, t);
      let i = 0, n = this._indentOccurrences.length;
      for (let l = 0; l < this._indentOccurrences.length; l++) {
        const d = this._indentOccurrences[l];
        if (d) {
          if (d + i > t) {
            n = l;
            break;
          }
          i += d;
        }
      }
      const s = e.getOptions().tabSize, o = new Uint32Array(t), a = new Uint32Array(t);
      for (let l = this._length - 1, d = 0; l >= 0; l--) {
        const c = this._startIndexes[l], h = e.getLineContent(c), u = Yu(h, s);
        (u < n || u === n && i++ < t) && (o[d] = c, a[d] = this._endIndexes[l], d++);
      }
      return new gt(o, a);
    }
  }
};
const zD = {
  limit: BD,
  update: () => {
  }
};
function $D(r, e, t, i = zD) {
  const n = r.getOptions().tabSize, s = new UD(i);
  let o;
  t && (o = new RegExp(`(${t.start.source})|(?:${t.end.source})`));
  const a = [], l = r.getLineCount() + 1;
  a.push({ indent: -1, endAbove: l, line: l });
  for (let d = r.getLineCount(); d > 0; d--) {
    const c = r.getLineContent(d), h = Yu(c, n);
    let u = a[a.length - 1];
    if (h === -1) {
      e && (u.endAbove = d);
      continue;
    }
    let p;
    if (o && (p = c.match(o)))
      if (p[1]) {
        let f = a.length - 1;
        for (; f > 0 && a[f].indent !== -2; )
          f--;
        if (f > 0) {
          a.length = f + 1, u = a[f], s.insertFirst(d, u.line, h), u.line = d, u.indent = h, u.endAbove = d;
          continue;
        }
      } else {
        a.push({ indent: -2, endAbove: d, line: d });
        continue;
      }
    if (u.indent > h) {
      do
        a.pop(), u = a[a.length - 1];
      while (u.indent > h);
      const f = u.endAbove - 1;
      f - d >= 1 && s.insertFirst(d, f, h);
    }
    u.indent === h ? u.endAbove = d : a.push({ indent: h, endAbove: d, line: d });
  }
  return s.toIndentRanges(r);
}
const jD = W("editor.foldBackground", { light: yt(Ep, 0.3), dark: yt(Ep, 0.3), hcDark: null, hcLight: null }, g("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), !0);
W("editorGutter.foldingControlForeground", { dark: ya, light: ya, hcDark: ya, hcLight: ya }, g("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
const Wd = Ae("folding-expanded", j.chevronDown, g("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin.")), Hd = Ae("folding-collapsed", j.chevronRight, g("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin.")), Ub = Ae("folding-manual-collapsed", Hd, g("foldingManualCollapedIcon", "Icon for manually collapsed ranges in the editor glyph margin.")), zb = Ae("folding-manual-expanded", Wd, g("foldingManualExpandedIcon", "Icon for manually expanded ranges in the editor glyph margin.")), Qg = { color: Se(jD), position: ns.Inline }, wo = g("linesCollapsed", "Click to expand the range."), Bd = g("linesExpanded", "Click to collapse the range.");
class ge {
  constructor(e) {
    this.editor = e, this.showFoldingControls = "mouseover", this.showFoldingHighlights = !0;
  }
  getDecorationOption(e, t, i) {
    return t ? ge.HIDDEN_RANGE_DECORATION : this.showFoldingControls === "never" ? e ? this.showFoldingHighlights ? ge.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION : ge.NO_CONTROLS_COLLAPSED_RANGE_DECORATION : ge.NO_CONTROLS_EXPANDED_RANGE_DECORATION : e ? i ? this.showFoldingHighlights ? ge.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : ge.MANUALLY_COLLAPSED_VISUAL_DECORATION : this.showFoldingHighlights ? ge.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : ge.COLLAPSED_VISUAL_DECORATION : this.showFoldingControls === "mouseover" ? i ? ge.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION : ge.EXPANDED_AUTO_HIDE_VISUAL_DECORATION : i ? ge.MANUALLY_EXPANDED_VISUAL_DECORATION : ge.EXPANDED_VISUAL_DECORATION;
  }
  changeDecorations(e) {
    return this.editor.changeDecorations(e);
  }
  removeDecorations(e) {
    this.editor.removeDecorations(e);
  }
}
ge.COLLAPSED_VISUAL_DECORATION = Y.register({
  description: "folding-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: wo,
  firstLineDecorationClassName: oe.asClassName(Hd)
});
ge.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = Y.register({
  description: "folding-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: Qg,
  isWholeLine: !0,
  linesDecorationsTooltip: wo,
  firstLineDecorationClassName: oe.asClassName(Hd)
});
ge.MANUALLY_COLLAPSED_VISUAL_DECORATION = Y.register({
  description: "folding-manually-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: wo,
  firstLineDecorationClassName: oe.asClassName(Ub)
});
ge.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = Y.register({
  description: "folding-manually-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: Qg,
  isWholeLine: !0,
  linesDecorationsTooltip: wo,
  firstLineDecorationClassName: oe.asClassName(Ub)
});
ge.NO_CONTROLS_COLLAPSED_RANGE_DECORATION = Y.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: wo
});
ge.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION = Y.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: Qg,
  isWholeLine: !0,
  linesDecorationsTooltip: wo
});
ge.EXPANDED_VISUAL_DECORATION = Y.register({
  description: "folding-expanded-visual-decoration",
  stickiness: 1,
  isWholeLine: !0,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + oe.asClassName(Wd),
  linesDecorationsTooltip: Bd
});
ge.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = Y.register({
  description: "folding-expanded-auto-hide-visual-decoration",
  stickiness: 1,
  isWholeLine: !0,
  firstLineDecorationClassName: oe.asClassName(Wd),
  linesDecorationsTooltip: Bd
});
ge.MANUALLY_EXPANDED_VISUAL_DECORATION = Y.register({
  description: "folding-manually-expanded-visual-decoration",
  stickiness: 0,
  isWholeLine: !0,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + oe.asClassName(zb),
  linesDecorationsTooltip: Bd
});
ge.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION = Y.register({
  description: "folding-manually-expanded-auto-hide-visual-decoration",
  stickiness: 0,
  isWholeLine: !0,
  firstLineDecorationClassName: oe.asClassName(zb),
  linesDecorationsTooltip: Bd
});
ge.NO_CONTROLS_EXPANDED_RANGE_DECORATION = Y.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  isWholeLine: !0
});
ge.HIDDEN_RANGE_DECORATION = Y.register({
  description: "folding-hidden-range-decoration",
  stickiness: 1
  /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
});
const qD = {}, KD = "syntax";
class Yg {
  constructor(e, t, i, n, s) {
    this.editorModel = e, this.providers = t, this.handleFoldingRangesChange = i, this.foldingRangesLimit = n, this.fallbackRangeProvider = s, this.id = KD, this.disposables = new M(), s && this.disposables.add(s);
    for (const o of t)
      typeof o.onDidChange == "function" && this.disposables.add(o.onDidChange(i));
  }
  compute(e) {
    return GD(this.providers, this.editorModel, e).then((t) => {
      var i, n;
      return t ? XD(t, this.foldingRangesLimit) : (n = (i = this.fallbackRangeProvider) === null || i === void 0 ? void 0 : i.compute(e)) !== null && n !== void 0 ? n : null;
    });
  }
  dispose() {
    this.disposables.dispose();
  }
}
function GD(r, e, t) {
  let i = null;
  const n = r.map((s, o) => Promise.resolve(s.provideFoldingRanges(e, qD, t)).then((a) => {
    if (!t.isCancellationRequested && Array.isArray(a)) {
      Array.isArray(i) || (i = []);
      const l = e.getLineCount();
      for (const d of a)
        d.start > 0 && d.end > d.start && d.end <= l && i.push({ start: d.start, end: d.end, rank: o, kind: d.kind });
    }
  }, Ie));
  return Promise.all(n).then((s) => i);
}
class ZD {
  constructor(e) {
    this._startIndexes = [], this._endIndexes = [], this._nestingLevels = [], this._nestingLevelCounts = [], this._types = [], this._length = 0, this._foldingRangesLimit = e;
  }
  add(e, t, i, n) {
    if (e > Wt || t > Wt)
      return;
    const s = this._length;
    this._startIndexes[s] = e, this._endIndexes[s] = t, this._nestingLevels[s] = n, this._types[s] = i, this._length++, n < 30 && (this._nestingLevelCounts[n] = (this._nestingLevelCounts[n] || 0) + 1);
  }
  toIndentRanges() {
    const e = this._foldingRangesLimit.limit;
    if (this._length <= e) {
      this._foldingRangesLimit.update(this._length, !1);
      const t = new Uint32Array(this._length), i = new Uint32Array(this._length);
      for (let n = 0; n < this._length; n++)
        t[n] = this._startIndexes[n], i[n] = this._endIndexes[n];
      return new gt(t, i, this._types);
    } else {
      this._foldingRangesLimit.update(this._length, e);
      let t = 0, i = this._nestingLevelCounts.length;
      for (let a = 0; a < this._nestingLevelCounts.length; a++) {
        const l = this._nestingLevelCounts[a];
        if (l) {
          if (l + t > e) {
            i = a;
            break;
          }
          t += l;
        }
      }
      const n = new Uint32Array(e), s = new Uint32Array(e), o = [];
      for (let a = 0, l = 0; a < this._length; a++) {
        const d = this._nestingLevels[a];
        (d < i || d === i && t++ < e) && (n[l] = this._startIndexes[a], s[l] = this._endIndexes[a], o[l] = this._types[a], l++);
      }
      return new gt(n, s, o);
    }
  }
}
function XD(r, e) {
  const t = r.sort((o, a) => {
    let l = o.start - a.start;
    return l === 0 && (l = o.rank - a.rank), l;
  }), i = new ZD(e);
  let n;
  const s = [];
  for (const o of t)
    if (!n)
      n = o, i.add(o.start, o.end, o.kind && o.kind.value, s.length);
    else if (o.start > n.start)
      if (o.end <= n.end)
        s.push(n), n = o, i.add(o.start, o.end, o.kind && o.kind.value, s.length);
      else {
        if (o.start > n.end) {
          do
            n = s.pop();
          while (n && o.start > n.end);
          n && s.push(n), n = o;
        }
        i.add(o.start, o.end, o.kind && o.kind.value, s.length);
      }
  return i.toIndentRanges();
}
var QD = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Fo = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, ws;
const We = new Q("foldingEnabled", !1);
let li = ws = class extends P {
  static get(e) {
    return e.getContribution(ws.ID);
  }
  static getFoldingRangeProviders(e, t) {
    var i, n;
    const s = e.foldingRangeProvider.ordered(t);
    return (n = (i = ws._foldingRangeSelector) === null || i === void 0 ? void 0 : i.call(ws, s, t)) !== null && n !== void 0 ? n : s;
  }
  constructor(e, t, i, n, s, o) {
    super(), this.contextKeyService = t, this.languageConfigurationService = i, this.languageFeaturesService = o, this.localToDispose = this._register(new M()), this.editor = e, this._foldingLimitReporter = new $b(e);
    const a = this.editor.getOptions();
    this._isEnabled = a.get(
      43
      /* EditorOption.folding */
    ), this._useFoldingProviders = a.get(
      44
      /* EditorOption.foldingStrategy */
    ) !== "indentation", this._unfoldOnClickAfterEndOfLine = a.get(
      48
      /* EditorOption.unfoldOnClickAfterEndOfLine */
    ), this._restoringViewState = !1, this._currentModelHasFoldedImports = !1, this._foldingImportsByDefault = a.get(
      46
      /* EditorOption.foldingImportsByDefault */
    ), this.updateDebounceInfo = s.for(o.foldingRangeProvider, "Folding", { min: 200 }), this.foldingModel = null, this.hiddenRangeModel = null, this.rangeProvider = null, this.foldingRegionPromise = null, this.foldingModelPromise = null, this.updateScheduler = null, this.cursorChangedScheduler = null, this.mouseDownInfo = null, this.foldingDecorationProvider = new ge(e), this.foldingDecorationProvider.showFoldingControls = a.get(
      110
      /* EditorOption.showFoldingControls */
    ), this.foldingDecorationProvider.showFoldingHighlights = a.get(
      45
      /* EditorOption.foldingHighlight */
    ), this.foldingEnabled = We.bindTo(this.contextKeyService), this.foldingEnabled.set(this._isEnabled), this._register(this.editor.onDidChangeModel(() => this.onModelChanged())), this._register(this.editor.onDidChangeConfiguration((l) => {
      if (l.hasChanged(
        43
        /* EditorOption.folding */
      ) && (this._isEnabled = this.editor.getOptions().get(
        43
        /* EditorOption.folding */
      ), this.foldingEnabled.set(this._isEnabled), this.onModelChanged()), l.hasChanged(
        47
        /* EditorOption.foldingMaximumRegions */
      ) && this.onModelChanged(), l.hasChanged(
        110
        /* EditorOption.showFoldingControls */
      ) || l.hasChanged(
        45
        /* EditorOption.foldingHighlight */
      )) {
        const d = this.editor.getOptions();
        this.foldingDecorationProvider.showFoldingControls = d.get(
          110
          /* EditorOption.showFoldingControls */
        ), this.foldingDecorationProvider.showFoldingHighlights = d.get(
          45
          /* EditorOption.foldingHighlight */
        ), this.triggerFoldingModelChanged();
      }
      l.hasChanged(
        44
        /* EditorOption.foldingStrategy */
      ) && (this._useFoldingProviders = this.editor.getOptions().get(
        44
        /* EditorOption.foldingStrategy */
      ) !== "indentation", this.onFoldingStrategyChanged()), l.hasChanged(
        48
        /* EditorOption.unfoldOnClickAfterEndOfLine */
      ) && (this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(
        48
        /* EditorOption.unfoldOnClickAfterEndOfLine */
      )), l.hasChanged(
        46
        /* EditorOption.foldingImportsByDefault */
      ) && (this._foldingImportsByDefault = this.editor.getOptions().get(
        46
        /* EditorOption.foldingImportsByDefault */
      ));
    })), this.onModelChanged();
  }
  /**
   * Store view state.
   */
  saveViewState() {
    const e = this.editor.getModel();
    if (!e || !this._isEnabled || e.isTooLargeForTokenization())
      return {};
    if (this.foldingModel) {
      const t = this.foldingModel.getMemento(), i = this.rangeProvider ? this.rangeProvider.id : void 0;
      return { collapsedRegions: t, lineCount: e.getLineCount(), provider: i, foldedImports: this._currentModelHasFoldedImports };
    }
  }
  /**
   * Restore view state.
   */
  restoreViewState(e) {
    const t = this.editor.getModel();
    if (!(!t || !this._isEnabled || t.isTooLargeForTokenization() || !this.hiddenRangeModel) && e && (this._currentModelHasFoldedImports = !!e.foldedImports, e.collapsedRegions && e.collapsedRegions.length > 0 && this.foldingModel)) {
      this._restoringViewState = !0;
      try {
        this.foldingModel.applyMemento(e.collapsedRegions);
      } finally {
        this._restoringViewState = !1;
      }
    }
  }
  onModelChanged() {
    this.localToDispose.clear();
    const e = this.editor.getModel();
    !this._isEnabled || !e || e.isTooLargeForTokenization() || (this._currentModelHasFoldedImports = !1, this.foldingModel = new MD(e, this.foldingDecorationProvider), this.localToDispose.add(this.foldingModel), this.hiddenRangeModel = new WD(this.foldingModel), this.localToDispose.add(this.hiddenRangeModel), this.localToDispose.add(this.hiddenRangeModel.onDidChange((t) => this.onHiddenRangesChanges(t))), this.updateScheduler = new Vn(this.updateDebounceInfo.get(e)), this.cursorChangedScheduler = new Re(() => this.revealCursor(), 200), this.localToDispose.add(this.cursorChangedScheduler), this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged())), this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())), this.localToDispose.add(this.editor.onDidChangeModelContent((t) => this.onDidChangeModelContent(t))), this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged())), this.localToDispose.add(this.editor.onMouseDown((t) => this.onEditorMouseDown(t))), this.localToDispose.add(this.editor.onMouseUp((t) => this.onEditorMouseUp(t))), this.localToDispose.add({
      dispose: () => {
        var t, i;
        this.foldingRegionPromise && (this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null), (t = this.updateScheduler) === null || t === void 0 || t.cancel(), this.updateScheduler = null, this.foldingModel = null, this.foldingModelPromise = null, this.hiddenRangeModel = null, this.cursorChangedScheduler = null, (i = this.rangeProvider) === null || i === void 0 || i.dispose(), this.rangeProvider = null;
      }
    }), this.triggerFoldingModelChanged());
  }
  onFoldingStrategyChanged() {
    var e;
    (e = this.rangeProvider) === null || e === void 0 || e.dispose(), this.rangeProvider = null, this.triggerFoldingModelChanged();
  }
  getRangeProvider(e) {
    if (this.rangeProvider)
      return this.rangeProvider;
    const t = new Xg(e, this.languageConfigurationService, this._foldingLimitReporter);
    if (this.rangeProvider = t, this._useFoldingProviders && this.foldingModel) {
      const i = ws.getFoldingRangeProviders(this.languageFeaturesService, e);
      i.length > 0 && (this.rangeProvider = new Yg(e, i, () => this.triggerFoldingModelChanged(), this._foldingLimitReporter, t));
    }
    return this.rangeProvider;
  }
  getFoldingModel() {
    return this.foldingModelPromise;
  }
  onDidChangeModelContent(e) {
    var t;
    (t = this.hiddenRangeModel) === null || t === void 0 || t.notifyChangeModelContent(e), this.triggerFoldingModelChanged();
  }
  triggerFoldingModelChanged() {
    this.updateScheduler && (this.foldingRegionPromise && (this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null), this.foldingModelPromise = this.updateScheduler.trigger(() => {
      const e = this.foldingModel;
      if (!e)
        return null;
      const t = new Rt(), i = this.getRangeProvider(e.textModel), n = this.foldingRegionPromise = Pe((s) => i.compute(s));
      return n.then((s) => {
        if (s && n === this.foldingRegionPromise) {
          let o;
          if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
            const c = s.setCollapsedAllOfType(na.Imports.value, !0);
            c && (o = $s.capture(this.editor), this._currentModelHasFoldedImports = c);
          }
          const a = this.editor.getSelections(), l = a ? a.map((c) => c.startLineNumber) : [];
          e.update(s, l), o == null || o.restore(this.editor);
          const d = this.updateDebounceInfo.update(e.textModel, t.elapsed());
          this.updateScheduler && (this.updateScheduler.defaultDelay = d);
        }
        return e;
      });
    }).then(void 0, (e) => (re(e), null)));
  }
  onHiddenRangesChanges(e) {
    if (this.hiddenRangeModel && e.length && !this._restoringViewState) {
      const t = this.editor.getSelections();
      t && this.hiddenRangeModel.adjustSelections(t) && this.editor.setSelections(t);
    }
    this.editor.setHiddenAreas(e, this);
  }
  onCursorPositionChanged() {
    this.hiddenRangeModel && this.hiddenRangeModel.hasRanges() && this.cursorChangedScheduler.schedule();
  }
  revealCursor() {
    const e = this.getFoldingModel();
    e && e.then((t) => {
      if (t) {
        const i = this.editor.getSelections();
        if (i && i.length > 0) {
          const n = [];
          for (const s of i) {
            const o = s.selectionStartLineNumber;
            this.hiddenRangeModel && this.hiddenRangeModel.isHidden(o) && n.push(...t.getAllRegionsAtLine(o, (a) => a.isCollapsed && o > a.startLineNumber));
          }
          n.length && (t.toggleCollapseState(n), this.reveal(i[0].getPosition()));
        }
      }
    }).then(void 0, re);
  }
  onEditorMouseDown(e) {
    if (this.mouseDownInfo = null, !this.hiddenRangeModel || !e.target || !e.target.range || !e.event.leftButton && !e.event.middleButton)
      return;
    const t = e.target.range;
    let i = !1;
    switch (e.target.type) {
      case 4: {
        const n = e.target.detail, s = e.target.element.offsetLeft;
        if (n.offsetX - s < 4)
          return;
        i = !0;
        break;
      }
      case 7: {
        if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges() && !e.target.detail.isAfterLines)
          break;
        return;
      }
      case 6: {
        if (this.hiddenRangeModel.hasRanges()) {
          const n = this.editor.getModel();
          if (n && t.startColumn === n.getLineMaxColumn(t.startLineNumber))
            break;
        }
        return;
      }
      default:
        return;
    }
    this.mouseDownInfo = { lineNumber: t.startLineNumber, iconClicked: i };
  }
  onEditorMouseUp(e) {
    const t = this.foldingModel;
    if (!t || !this.mouseDownInfo || !e.target)
      return;
    const i = this.mouseDownInfo.lineNumber, n = this.mouseDownInfo.iconClicked, s = e.target.range;
    if (!s || s.startLineNumber !== i)
      return;
    if (n) {
      if (e.target.type !== 4)
        return;
    } else {
      const a = this.editor.getModel();
      if (!a || s.startColumn !== a.getLineMaxColumn(i))
        return;
    }
    const o = t.getRegionAtLine(i);
    if (o && o.startLineNumber === i) {
      const a = o.isCollapsed;
      if (n || a) {
        const l = e.event.altKey;
        let d = [];
        if (l) {
          const c = (u) => !u.containedBy(o) && !o.containedBy(u), h = t.getRegionsInside(null, c);
          for (const u of h)
            u.isCollapsed && d.push(u);
          d.length === 0 && (d = h);
        } else {
          const c = e.event.middleButton || e.event.shiftKey;
          if (c)
            for (const h of t.getRegionsInside(o))
              h.isCollapsed === a && d.push(h);
          (a || !c || d.length === 0) && d.push(o);
        }
        t.toggleCollapseState(d), this.reveal({ lineNumber: i, column: 1 });
      }
    }
  }
  reveal(e) {
    this.editor.revealPositionInCenterIfOutsideViewport(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
};
li.ID = "editor.contrib.folding";
li = ws = QD([
  Fo(1, ee),
  Fo(2, fe),
  Fo(3, Je),
  Fo(4, Pt),
  Fo(5, V)
], li);
class $b {
  constructor(e) {
    this.editor = e, this._onDidChange = new G(), this._computed = 0, this._limited = !1;
  }
  get limit() {
    return this.editor.getOptions().get(
      47
      /* EditorOption.foldingMaximumRegions */
    );
  }
  update(e, t) {
    (e !== this._computed || t !== this._limited) && (this._computed = e, this._limited = t, this._onDidChange.fire());
  }
}
class Ve extends D {
  runEditorCommand(e, t, i) {
    const n = e.get(fe), s = li.get(t);
    if (!s)
      return;
    const o = s.getFoldingModel();
    if (o)
      return this.reportTelemetry(e, t), o.then((a) => {
        if (a) {
          this.invoke(s, a, t, i, n);
          const l = t.getSelection();
          l && s.reveal(l.getStartPosition());
        }
      });
  }
  getSelectedLines(e) {
    const t = e.getSelections();
    return t ? t.map((i) => i.startLineNumber) : [];
  }
  getLineNumbers(e, t) {
    return e && e.selectionLines ? e.selectionLines.map((i) => i + 1) : this.getSelectedLines(t);
  }
  run(e, t) {
  }
}
function jb(r) {
  if (!xa(r)) {
    if (!f_(r))
      return !1;
    const e = r;
    if (!xa(e.levels) && !Tp(e.levels) || !xa(e.direction) && !m_(e.direction) || !xa(e.selectionLines) && (!Array.isArray(e.selectionLines) || !e.selectionLines.every(Tp)))
      return !1;
  }
  return !0;
}
class YD extends Ve {
  constructor() {
    super({
      id: "editor.unfold",
      label: g("unfoldAction.label", "Unfold"),
      alias: "Unfold",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 3166,
        mac: {
          primary: 2654
          /* KeyCode.BracketRight */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: "Unfold the content in the editor",
        args: [
          {
            name: "Unfold editor argument",
            description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
            constraint: jb,
            schema: {
              type: "object",
              properties: {
                levels: {
                  type: "number",
                  default: 1
                },
                direction: {
                  type: "string",
                  enum: ["up", "down"],
                  default: "down"
                },
                selectionLines: {
                  type: "array",
                  items: {
                    type: "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(e, t, i, n) {
    const s = n && n.levels || 1, o = this.getLineNumbers(n, i);
    n && n.direction === "up" ? Bb(t, !1, s, o) : So(t, !1, s, o);
  }
}
class JD extends Ve {
  constructor() {
    super({
      id: "editor.unfoldRecursively",
      label: g("unFoldRecursivelyAction.label", "Unfold Recursively"),
      alias: "Unfold Recursively",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2142
          /* KeyCode.BracketRight */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n) {
    So(t, !1, Number.MAX_VALUE, this.getSelectedLines(i));
  }
}
class ek extends Ve {
  constructor() {
    super({
      id: "editor.fold",
      label: g("foldAction.label", "Fold"),
      alias: "Fold",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 3164,
        mac: {
          primary: 2652
          /* KeyCode.BracketLeft */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: "Fold the content in the editor",
        args: [
          {
            name: "Fold editor argument",
            description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
            constraint: jb,
            schema: {
              type: "object",
              properties: {
                levels: {
                  type: "number"
                },
                direction: {
                  type: "string",
                  enum: ["up", "down"]
                },
                selectionLines: {
                  type: "array",
                  items: {
                    type: "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(e, t, i, n) {
    const s = this.getLineNumbers(n, i), o = n && n.levels, a = n && n.direction;
    typeof o != "number" && typeof a != "string" ? ED(t, !0, s) : a === "up" ? Bb(t, !0, o || 1, s) : So(t, !0, o || 1, s);
  }
}
class tk extends Ve {
  constructor() {
    super({
      id: "editor.toggleFold",
      label: g("toggleFoldAction.label", "Toggle Fold"),
      alias: "Toggle Fold",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2090
          /* KeyCode.KeyL */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    Hb(t, 1, n);
  }
}
class ik extends Ve {
  constructor() {
    super({
      id: "editor.foldRecursively",
      label: g("foldRecursivelyAction.label", "Fold Recursively"),
      alias: "Fold Recursively",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2140
          /* KeyCode.BracketLeft */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    So(t, !0, Number.MAX_VALUE, n);
  }
}
class nk extends Ve {
  constructor() {
    super({
      id: "editor.foldAllBlockComments",
      label: g("foldAllBlockComments.label", "Fold All Block Comments"),
      alias: "Fold All Block Comments",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2138
          /* KeyCode.Slash */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, s) {
    if (t.regions.hasTypes())
      Zg(t, na.Comment.value, !0);
    else {
      const o = i.getModel();
      if (!o)
        return;
      const a = s.getLanguageConfiguration(o.getLanguageId()).comments;
      if (a && a.blockCommentStartToken) {
        const l = new RegExp("^\\s*" + pr(a.blockCommentStartToken));
        Gg(t, l, !0);
      }
    }
  }
}
class sk extends Ve {
  constructor() {
    super({
      id: "editor.foldAllMarkerRegions",
      label: g("foldAllMarkerRegions.label", "Fold All Regions"),
      alias: "Fold All Regions",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2077
          /* KeyCode.Digit8 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, s) {
    if (t.regions.hasTypes())
      Zg(t, na.Region.value, !0);
    else {
      const o = i.getModel();
      if (!o)
        return;
      const a = s.getLanguageConfiguration(o.getLanguageId()).foldingRules;
      if (a && a.markers && a.markers.start) {
        const l = new RegExp(a.markers.start);
        Gg(t, l, !0);
      }
    }
  }
}
class ok extends Ve {
  constructor() {
    super({
      id: "editor.unfoldAllMarkerRegions",
      label: g("unfoldAllMarkerRegions.label", "Unfold All Regions"),
      alias: "Unfold All Regions",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2078
          /* KeyCode.Digit9 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, s) {
    if (t.regions.hasTypes())
      Zg(t, na.Region.value, !1);
    else {
      const o = i.getModel();
      if (!o)
        return;
      const a = s.getLanguageConfiguration(o.getLanguageId()).foldingRules;
      if (a && a.markers && a.markers.start) {
        const l = new RegExp(a.markers.start);
        Gg(t, l, !1);
      }
    }
  }
}
class rk extends Ve {
  constructor() {
    super({
      id: "editor.foldAllExcept",
      label: g("foldAllExcept.label", "Fold All Except Selected"),
      alias: "Fold All Except Selected",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2136
          /* KeyCode.Minus */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    Vb(t, !0, n);
  }
}
class ak extends Ve {
  constructor() {
    super({
      id: "editor.unfoldAllExcept",
      label: g("unfoldAllExcept.label", "Unfold All Except Selected"),
      alias: "Unfold All Except Selected",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2134
          /* KeyCode.Equal */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    Vb(t, !1, n);
  }
}
class lk extends Ve {
  constructor() {
    super({
      id: "editor.foldAll",
      label: g("foldAllAction.label", "Fold All"),
      alias: "Fold All",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2069
          /* KeyCode.Digit0 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    So(t, !0);
  }
}
class dk extends Ve {
  constructor() {
    super({
      id: "editor.unfoldAll",
      label: g("unfoldAllAction.label", "Unfold All"),
      alias: "Unfold All",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2088
          /* KeyCode.KeyJ */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    So(t, !1);
  }
}
class Zn extends Ve {
  getFoldingLevel() {
    return parseInt(this.id.substr(Zn.ID_PREFIX.length));
  }
  invoke(e, t, i) {
    TD(t, this.getFoldingLevel(), !0, this.getSelectedLines(i));
  }
}
Zn.ID_PREFIX = "editor.foldLevel";
Zn.ID = (r) => Zn.ID_PREFIX + r;
class ck extends Ve {
  constructor() {
    super({
      id: "editor.gotoParentFold",
      label: g("gotoParentFold.label", "Go to Parent Fold"),
      alias: "Go to Parent Fold",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const s = AD(n[0], t);
      s !== null && i.setSelection({
        startLineNumber: s,
        startColumn: 1,
        endLineNumber: s,
        endColumn: 1
      });
    }
  }
}
class hk extends Ve {
  constructor() {
    super({
      id: "editor.gotoPreviousFold",
      label: g("gotoPreviousFold.label", "Go to Previous Folding Range"),
      alias: "Go to Previous Folding Range",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const s = OD(n[0], t);
      s !== null && i.setSelection({
        startLineNumber: s,
        startColumn: 1,
        endLineNumber: s,
        endColumn: 1
      });
    }
  }
}
class uk extends Ve {
  constructor() {
    super({
      id: "editor.gotoNextFold",
      label: g("gotoNextFold.label", "Go to Next Folding Range"),
      alias: "Go to Next Folding Range",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const s = FD(n[0], t);
      s !== null && i.setSelection({
        startLineNumber: s,
        startColumn: 1,
        endLineNumber: s,
        endColumn: 1
      });
    }
  }
}
class gk extends Ve {
  constructor() {
    super({
      id: "editor.createFoldingRangeFromSelection",
      label: g("createManualFoldRange.label", "Create Folding Range from Selection"),
      alias: "Create Folding Range from Selection",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2135
          /* KeyCode.Comma */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    var n;
    const s = [], o = i.getSelections();
    if (o) {
      for (const a of o) {
        let l = a.endLineNumber;
        a.endColumn === 1 && --l, l > a.startLineNumber && (s.push({
          startLineNumber: a.startLineNumber,
          endLineNumber: l,
          type: void 0,
          isCollapsed: !0,
          source: 1
          /* FoldSource.userDefined */
        }), i.setSelection({
          startLineNumber: a.startLineNumber,
          startColumn: 1,
          endLineNumber: a.startLineNumber,
          endColumn: 1
        }));
      }
      if (s.length > 0) {
        s.sort((l, d) => l.startLineNumber - d.startLineNumber);
        const a = gt.sanitizeAndMerge(t.regions, s, (n = i.getModel()) === null || n === void 0 ? void 0 : n.getLineCount());
        t.updatePost(gt.fromFoldRanges(a));
      }
    }
  }
}
class pk extends Ve {
  constructor() {
    super({
      id: "editor.removeManualFoldingRanges",
      label: g("removeManualFoldingRanges.label", "Remove Manual Folding Ranges"),
      alias: "Remove Manual Folding Ranges",
      precondition: We,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2137
          /* KeyCode.Period */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = i.getSelections();
    if (n) {
      const s = [];
      for (const o of n) {
        const { startLineNumber: a, endLineNumber: l } = o;
        s.push(l >= a ? { startLineNumber: a, endLineNumber: l } : { endLineNumber: l, startLineNumber: a });
      }
      t.removeManualRanges(s), e.triggerFoldingModelChanged();
    }
  }
}
Z(
  li.ID,
  li,
  0
  /* EditorContributionInstantiation.Eager */
);
x(YD);
x(JD);
x(ek);
x(ik);
x(lk);
x(dk);
x(nk);
x(sk);
x(ok);
x(rk);
x(ak);
x(tk);
x(ck);
x(hk);
x(uk);
x(gk);
x(pk);
for (let r = 1; r <= 7; r++)
  ow(new Zn({
    id: Zn.ID(r),
    label: g("foldLevelAction.label", "Fold Level {0}", r),
    alias: `Fold Level ${r}`,
    precondition: We,
    kbOpts: {
      kbExpr: b.editorTextFocus,
      primary: ye(2089, 2048 | 21 + r),
      weight: 100
      /* KeybindingWeight.EditorContrib */
    }
  }));
de.registerCommand("_executeFoldingRangeProvider", async function(r, ...e) {
  const [t] = e;
  if (!(t instanceof ce))
    throw wi();
  const i = r.get(V), n = r.get(Ge).getModel(t);
  if (!n)
    throw wi();
  const s = r.get(he);
  if (!s.getValue("editor.folding", { resource: t }))
    return [];
  const o = r.get(fe), a = s.getValue("editor.foldingStrategy", { resource: t }), l = {
    get limit() {
      return s.getValue("editor.foldingMaximumRegions", { resource: t });
    },
    update: (p, f) => {
    }
  }, d = new Xg(n, o, l);
  let c = d;
  if (a !== "indentation") {
    const p = li.getFoldingRangeProviders(i, n);
    p.length && (c = new Yg(n, p, () => {
    }, l, d));
  }
  const h = await c.compute(X.None), u = [];
  try {
    if (h)
      for (let p = 0; p < h.length; p++) {
        const f = h.getType(p);
        u.push({ start: h.getStartLineNumber(p), end: h.getEndLineNumber(p), kind: f ? na.fromValue(f) : void 0 });
      }
    return u;
  } finally {
    c.dispose();
  }
});
class fk extends D {
  constructor() {
    super({
      id: "editor.action.fontZoomIn",
      label: g("EditorFontZoomIn.label", "Increase Editor Font Size"),
      alias: "Increase Editor Font Size",
      precondition: void 0
    });
  }
  run(e, t) {
    br.setZoomLevel(br.getZoomLevel() + 1);
  }
}
class mk extends D {
  constructor() {
    super({
      id: "editor.action.fontZoomOut",
      label: g("EditorFontZoomOut.label", "Decrease Editor Font Size"),
      alias: "Decrease Editor Font Size",
      precondition: void 0
    });
  }
  run(e, t) {
    br.setZoomLevel(br.getZoomLevel() - 1);
  }
}
class _k extends D {
  constructor() {
    super({
      id: "editor.action.fontZoomReset",
      label: g("EditorFontZoomReset.label", "Reset Editor Font Size"),
      alias: "Reset Editor Font Size",
      precondition: void 0
    });
  }
  run(e, t) {
    br.setZoomLevel(0);
  }
}
x(fk);
x(mk);
x(_k);
var qb = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, or = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Nr = class {
  constructor(e, t, i, n) {
    this._editor = e, this._languageFeaturesService = t, this._workerService = i, this._accessibilitySignalService = n, this._disposables = new M(), this._sessionDisposables = new M(), this._disposables.add(t.onTypeFormattingEditProvider.onDidChange(this._update, this)), this._disposables.add(e.onDidChangeModel(() => this._update())), this._disposables.add(e.onDidChangeModelLanguage(() => this._update())), this._disposables.add(e.onDidChangeConfiguration((s) => {
      s.hasChanged(
        56
        /* EditorOption.formatOnType */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._disposables.dispose(), this._sessionDisposables.dispose();
  }
  _update() {
    if (this._sessionDisposables.clear(), !this._editor.getOption(
      56
      /* EditorOption.formatOnType */
    ) || !this._editor.hasModel())
      return;
    const e = this._editor.getModel(), [t] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(e);
    if (!t || !t.autoFormatTriggerCharacters)
      return;
    const i = new yl();
    for (const n of t.autoFormatTriggerCharacters)
      i.add(n.charCodeAt(0));
    this._sessionDisposables.add(this._editor.onDidType((n) => {
      const s = n.charCodeAt(n.length - 1);
      i.has(s) && this._trigger(String.fromCharCode(s));
    }));
  }
  _trigger(e) {
    if (!this._editor.hasModel() || this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty())
      return;
    const t = this._editor.getModel(), i = this._editor.getPosition(), n = new Oe(), s = this._editor.onDidChangeModelContent((o) => {
      if (o.isFlush) {
        n.cancel(), s.dispose();
        return;
      }
      for (let a = 0, l = o.changes.length; a < l; a++)
        if (o.changes[a].range.endLineNumber <= i.lineNumber) {
          n.cancel(), s.dispose();
          return;
        }
    });
    rw(this._workerService, this._languageFeaturesService, t, i, e, t.getFormattingOptions(), n.token).then((o) => {
      n.token.isCancellationRequested || nt(o) && (this._accessibilitySignalService.playSignal(v_.format, { userGesture: !1 }), aw.execute(this._editor, o, !0));
    }).finally(() => {
      s.dispose();
    });
  }
};
Nr.ID = "editor.contrib.autoFormat";
Nr = qb([
  or(1, V),
  or(2, sa),
  or(3, __)
], Nr);
let Rr = class {
  constructor(e, t, i) {
    this.editor = e, this._languageFeaturesService = t, this._instantiationService = i, this._callOnDispose = new M(), this._callOnModel = new M(), this._callOnDispose.add(e.onDidChangeConfiguration(() => this._update())), this._callOnDispose.add(e.onDidChangeModel(() => this._update())), this._callOnDispose.add(e.onDidChangeModelLanguage(() => this._update())), this._callOnDispose.add(t.documentRangeFormattingEditProvider.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose(), this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear(), this.editor.getOption(
      55
      /* EditorOption.formatOnPaste */
    ) && this.editor.hasModel() && this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel()) && this._callOnModel.add(this.editor.onDidPaste(({ range: e }) => this._trigger(e)));
  }
  _trigger(e) {
    this.editor.hasModel() && (this.editor.getSelections().length > 1 || this._instantiationService.invokeFunction(b_, this.editor, e, 2, Xi.None, X.None, !1).catch(re));
  }
};
Rr.ID = "editor.contrib.formatOnPaste";
Rr = qb([
  or(1, V),
  or(2, q)
], Rr);
class vk extends D {
  constructor() {
    super({
      id: "editor.action.formatDocument",
      label: g("formatDocument.label", "Format Document"),
      alias: "Format Document",
      precondition: L.and(b.notInCompositeEditor, b.writable, b.hasDocumentFormattingProvider),
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 1572,
        linux: {
          primary: 3111
          /* KeyCode.KeyI */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.3
      }
    });
  }
  async run(e, t) {
    if (t.hasModel()) {
      const i = e.get(q);
      await e.get(Qr).showWhile(i.invokeFunction(lw, t, 1, Xi.None, X.None, !0), 250);
    }
  }
}
class bk extends D {
  constructor() {
    super({
      id: "editor.action.formatSelection",
      label: g("formatSelection.label", "Format Selection"),
      alias: "Format Selection",
      precondition: L.and(b.writable, b.hasDocumentSelectionFormattingProvider),
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2084
          /* KeyCode.KeyF */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        when: b.hasNonEmptySelection,
        group: "1_modification",
        order: 1.31
      }
    });
  }
  async run(e, t) {
    if (!t.hasModel())
      return;
    const i = e.get(q), n = t.getModel(), s = t.getSelections().map((a) => a.isEmpty() ? new S(a.startLineNumber, 1, a.startLineNumber, n.getLineMaxColumn(a.startLineNumber)) : a);
    await e.get(Qr).showWhile(i.invokeFunction(b_, t, s, 1, Xi.None, X.None, !0), 250);
  }
}
Z(
  Nr.ID,
  Nr,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Z(
  Rr.ID,
  Rr,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
x(vk);
x(bk);
de.registerCommand("editor.action.format", async (r) => {
  const e = r.get(_e).getFocusedCodeEditor();
  if (!e || !e.hasModel())
    return;
  const t = r.get(Fe);
  e.getSelection().isEmpty() ? await t.executeCommand("editor.action.formatDocument") : await t.executeCommand("editor.action.formatSelection");
});
var Ck = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Wc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class Ms {
  remove() {
    var e;
    (e = this.parent) === null || e === void 0 || e.children.delete(this.id);
  }
  static findId(e, t) {
    let i;
    typeof e == "string" ? i = `${t.id}/${e}` : (i = `${t.id}/${e.name}`, t.children.get(i) !== void 0 && (i = `${t.id}/${e.name}_${e.range.startLineNumber}_${e.range.startColumn}`));
    let n = i;
    for (let s = 0; t.children.get(n) !== void 0; s++)
      n = `${i}_${s}`;
    return n;
  }
  static empty(e) {
    return e.children.size === 0;
  }
}
class Xh extends Ms {
  constructor(e, t, i) {
    super(), this.id = e, this.parent = t, this.symbol = i, this.children = /* @__PURE__ */ new Map();
  }
}
class Kb extends Ms {
  constructor(e, t, i, n) {
    super(), this.id = e, this.parent = t, this.label = i, this.order = n, this.children = /* @__PURE__ */ new Map();
  }
}
class bi extends Ms {
  static create(e, t, i) {
    const n = new Oe(i), s = new bi(t.uri), o = e.ordered(t), a = o.map((d, c) => {
      var h;
      const u = Ms.findId(`provider_${c}`, s), p = new Kb(u, s, (h = d.displayName) !== null && h !== void 0 ? h : "Unknown Outline Provider", c);
      return Promise.resolve(d.provideDocumentSymbols(t, n.token)).then((f) => {
        for (const m of f || [])
          bi._makeOutlineElement(m, p);
        return p;
      }, (f) => (Ie(f), p)).then((f) => {
        Ms.empty(f) ? f.remove() : s._groups.set(u, f);
      });
    }), l = e.onDidChange(() => {
      const d = e.ordered(t);
      jt(d, o) || n.cancel();
    });
    return Promise.all(a).then(() => n.token.isCancellationRequested && !i.isCancellationRequested ? bi.create(e, t, i) : s._compact()).finally(() => {
      n.dispose(), l.dispose(), n.dispose();
    });
  }
  static _makeOutlineElement(e, t) {
    const i = Ms.findId(e, t), n = new Xh(i, t, e);
    if (e.children)
      for (const s of e.children)
        bi._makeOutlineElement(s, n);
    t.children.set(n.id, n);
  }
  constructor(e) {
    super(), this.uri = e, this.id = "root", this.parent = void 0, this._groups = /* @__PURE__ */ new Map(), this.children = /* @__PURE__ */ new Map(), this.id = "root", this.parent = void 0;
  }
  _compact() {
    let e = 0;
    for (const [t, i] of this._groups)
      i.children.size === 0 ? this._groups.delete(t) : e += 1;
    if (e !== 1)
      this.children = this._groups;
    else {
      const t = Si.first(this._groups.values());
      for (const [, i] of t.children)
        i.parent = this, this.children.set(i.id, i);
    }
    return this;
  }
  getTopLevelSymbols() {
    const e = [];
    for (const t of this.children.values())
      t instanceof Xh ? e.push(t.symbol) : e.push(...Si.map(t.children.values(), (i) => i.symbol));
    return e.sort((t, i) => S.compareRangesUsingStarts(t.range, i.range));
  }
  asListOfDocumentSymbols() {
    const e = this.getTopLevelSymbols(), t = [];
    return bi._flattenDocumentSymbols(t, e, ""), t.sort((i, n) => F.compare(S.getStartPosition(i.range), S.getStartPosition(n.range)) || F.compare(S.getEndPosition(n.range), S.getEndPosition(i.range)));
  }
  static _flattenDocumentSymbols(e, t, i) {
    for (const n of t)
      e.push({
        kind: n.kind,
        tags: n.tags,
        name: n.name,
        detail: n.detail,
        containerName: n.containerName || i,
        range: n.range,
        selectionRange: n.selectionRange,
        children: void 0
        // we flatten it...
      }), n.children && bi._flattenDocumentSymbols(e, n.children, n.name);
  }
}
const fa = Ti("IOutlineModelService");
let Qh = class {
  constructor(e, t, i) {
    this._languageFeaturesService = e, this._disposables = new M(), this._cache = new Yr(10, 0.7), this._debounceInformation = t.for(e.documentSymbolProvider, "DocumentSymbols", { min: 350 }), this._disposables.add(i.onModelRemoved((n) => {
      this._cache.delete(n.id);
    }));
  }
  dispose() {
    this._disposables.dispose();
  }
  async getOrCreate(e, t) {
    const i = this._languageFeaturesService.documentSymbolProvider, n = i.ordered(e);
    let s = this._cache.get(e.id);
    if (!s || s.versionId !== e.getVersionId() || !jt(s.provider, n)) {
      const a = new Oe();
      s = {
        versionId: e.getVersionId(),
        provider: n,
        promiseCnt: 0,
        source: a,
        promise: bi.create(i, e, a.token),
        model: void 0
      }, this._cache.set(e.id, s);
      const l = Date.now();
      s.promise.then((d) => {
        s.model = d, this._debounceInformation.update(e, Date.now() - l);
      }).catch((d) => {
        this._cache.delete(e.id);
      });
    }
    if (s.model)
      return s.model;
    s.promiseCnt += 1;
    const o = t.onCancellationRequested(() => {
      --s.promiseCnt === 0 && (s.source.cancel(), this._cache.delete(e.id));
    });
    try {
      return await s.promise;
    } finally {
      o.dispose();
    }
  }
};
Qh = Ck([
  Wc(0, V),
  Wc(1, Pt),
  Wc(2, Ge)
], Qh);
Ai(
  fa,
  Qh,
  1
  /* InstantiationType.Delayed */
);
de.registerCommand("_executeDocumentSymbolProvider", async function(r, ...e) {
  const [t] = e;
  ie(ce.isUri(t));
  const i = r.get(fa), s = await r.get(Zt).createModelReference(t);
  try {
    return (await i.getOrCreate(s.object.textEditorModel, X.None)).getTopLevelSymbols();
  } finally {
    s.dispose();
  }
});
class ke extends P {
  constructor(e, t) {
    super(), this.contextKeyService = e, this.model = t, this.inlineCompletionVisible = ke.inlineSuggestionVisible.bindTo(this.contextKeyService), this.inlineCompletionSuggestsIndentation = ke.inlineSuggestionHasIndentation.bindTo(this.contextKeyService), this.inlineCompletionSuggestsIndentationLessThanTabSize = ke.inlineSuggestionHasIndentationLessThanTabSize.bindTo(this.contextKeyService), this.suppressSuggestions = ke.suppressSuggestions.bindTo(this.contextKeyService), this._register(Ne((i) => {
      const n = this.model.read(i), s = n == null ? void 0 : n.state.read(i), o = !!(s != null && s.inlineCompletion) && (s == null ? void 0 : s.primaryGhostText) !== void 0 && !(s != null && s.primaryGhostText.isEmpty());
      this.inlineCompletionVisible.set(o), s != null && s.primaryGhostText && (s != null && s.inlineCompletion) && this.suppressSuggestions.set(s.inlineCompletion.inlineCompletion.source.inlineCompletions.suppressSuggestions);
    })), this._register(Ne((i) => {
      const n = this.model.read(i);
      let s = !1, o = !0;
      const a = n == null ? void 0 : n.primaryGhostText.read(i);
      if (n != null && n.selectedSuggestItem && a && a.parts.length > 0) {
        const { column: l, lines: d } = a.parts[0], c = d[0], h = n.textModel.getLineIndentColumn(a.lineNumber);
        if (l <= h) {
          let p = nh(c);
          p === -1 && (p = c.length - 1), s = p > 0;
          const f = n.textModel.getOptions().tabSize;
          o = dw.visibleColumnFromColumn(c, p + 1, f) < f;
        }
      }
      this.inlineCompletionSuggestsIndentation.set(s), this.inlineCompletionSuggestsIndentationLessThanTabSize.set(o);
    }));
  }
}
ke.inlineSuggestionVisible = new Q("inlineSuggestionVisible", !1, g("inlineSuggestionVisible", "Whether an inline suggestion is visible"));
ke.inlineSuggestionHasIndentation = new Q("inlineSuggestionHasIndentation", !1, g("inlineSuggestionHasIndentation", "Whether the inline suggestion starts with whitespace"));
ke.inlineSuggestionHasIndentationLessThanTabSize = new Q("inlineSuggestionHasIndentationLessThanTabSize", !0, g("inlineSuggestionHasIndentationLessThanTabSize", "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
ke.suppressSuggestions = new Q("inlineSuggestionSuppressSuggestions", void 0, g("suppressSuggestions", "Whether suggestions should be suppressed for the current suggestion"));
function Sk(r, e) {
  const t = new wk(r), i = e.map((n) => {
    const s = S.lift(n.range);
    return {
      startOffset: t.getOffset(s.getStartPosition()),
      endOffset: t.getOffset(s.getEndPosition()),
      text: n.text
    };
  });
  i.sort((n, s) => s.startOffset - n.startOffset);
  for (const n of i)
    r = r.substring(0, n.startOffset) + n.text + r.substring(n.endOffset);
  return r;
}
class wk {
  constructor(e) {
    this.lineStartOffsetByLineIdx = [], this.lineStartOffsetByLineIdx.push(0);
    for (let t = 0; t < e.length; t++)
      e.charAt(t) === `
` && this.lineStartOffsetByLineIdx.push(t + 1);
  }
  getOffset(e) {
    return this.lineStartOffsetByLineIdx[e.lineNumber - 1] + e.column - 1;
  }
}
const yk = [];
function xk() {
  return yk;
}
class Gb {
  constructor(e, t) {
    if (this.startColumn = e, this.endColumnExclusive = t, e > t)
      throw new xl(`startColumn ${e} cannot be after endColumnExclusive ${t}`);
  }
  toRange(e) {
    return new S(e, this.startColumn, e, this.endColumnExclusive);
  }
  equals(e) {
    return this.startColumn === e.startColumn && this.endColumnExclusive === e.endColumnExclusive;
  }
}
function Zb(r, e) {
  const t = new M(), i = r.createDecorationsCollection();
  return t.add(cw({ debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
    const s = e.read(n);
    i.set(s);
  })), t.add({
    dispose: () => {
      i.clear();
    }
  }), t;
}
function Vd(r, e) {
  return new F(r.lineNumber + e.lineNumber - 1, e.lineNumber === 1 ? r.column + e.column - 1 : e.column);
}
function $f(r, e) {
  return new F(r.lineNumber - e.lineNumber + 1, r.lineNumber - e.lineNumber === 0 ? r.column - e.column + 1 : r.column);
}
function Jg(r) {
  let e = 1, t = 1;
  for (const i of r)
    i === `
` ? (e++, t = 1) : t++;
  return new F(e, t);
}
function Lk(r) {
  var e;
  const t = [];
  let i = 0, n = 0, s = 0;
  for (const o of r) {
    const a = (e = o.text) !== null && e !== void 0 ? e : "", l = Jg(a), d = F.lift({
      lineNumber: o.range.startLineNumber + n,
      column: o.range.startColumn + (o.range.startLineNumber === i ? s : 0)
    }), c = Vd(d, l);
    t.push(S.fromPositions(d, c)), n += l.lineNumber - o.range.endLineNumber + o.range.startLineNumber - 1, s = c.column - o.range.endColumn, i = o.range.endLineNumber;
  }
  return t;
}
class Vl {
  constructor(e) {
    this._indexMap = e;
  }
  static createSortPermutation(e, t) {
    const i = Array.from(e.keys()).sort((n, s) => t(e[n], e[s]));
    return new Vl(i);
  }
  apply(e) {
    return e.map((t, i) => e[this._indexMap[i]]);
  }
  inverse() {
    const e = this._indexMap.slice();
    for (let t = 0; t < this._indexMap.length; t++)
      e[this._indexMap[t]] = t;
    return new Vl(e);
  }
}
class Pr {
  constructor(e, t) {
    this.lineNumber = e, this.parts = t;
  }
  equals(e) {
    return this.lineNumber === e.lineNumber && this.parts.length === e.parts.length && this.parts.every((t, i) => t.equals(e.parts[i]));
  }
  renderForScreenReader(e) {
    if (this.parts.length === 0)
      return "";
    const t = this.parts[this.parts.length - 1], i = e.substr(0, t.column - 1);
    return Sk(i, this.parts.map((s) => ({
      range: { startLineNumber: 1, endLineNumber: 1, startColumn: s.column, endColumn: s.column },
      text: s.lines.join(`
`)
    }))).substring(this.parts[0].column - 1);
  }
  isEmpty() {
    return this.parts.every((e) => e.lines.length === 0);
  }
  get lineCount() {
    return 1 + this.parts.reduce((e, t) => e + t.lines.length - 1, 0);
  }
}
class Ul {
  constructor(e, t, i) {
    this.column = e, this.text = t, this.preview = i, this.lines = dd(this.text);
  }
  equals(e) {
    return this.column === e.column && this.lines.length === e.lines.length && this.lines.every((t, i) => t === e.lines[i]);
  }
}
class Yh {
  constructor(e, t, i, n = 0) {
    this.lineNumber = e, this.columnRange = t, this.text = i, this.additionalReservedLineCount = n, this.parts = [
      new Ul(this.columnRange.endColumnExclusive, this.text, !1)
    ], this.newLines = dd(this.text);
  }
  renderForScreenReader(e) {
    return this.newLines.join(`
`);
  }
  get lineCount() {
    return this.newLines.length;
  }
  isEmpty() {
    return this.parts.every((e) => e.lines.length === 0);
  }
  equals(e) {
    return this.lineNumber === e.lineNumber && this.columnRange.equals(e.columnRange) && this.newLines.length === e.newLines.length && this.newLines.every((t, i) => t === e.newLines[i]) && this.additionalReservedLineCount === e.additionalReservedLineCount;
  }
}
function jf(r, e) {
  return jt(r, e, Xb);
}
function Xb(r, e) {
  return r === e ? !0 : !r || !e ? !1 : r instanceof Pr && e instanceof Pr || r instanceof Yh && e instanceof Yh ? r.equals(e) : !1;
}
var Ik = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Dk = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const qf = "ghost-text";
let Jh = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.languageService = i, this.isDisposed = ai(this, !1), this.currentTextModel = it(this.editor.onDidChangeModel, () => (
      /** @description editor.model */
      this.editor.getModel()
    )), this.uiState = Xe(this, (n) => {
      if (this.isDisposed.read(n))
        return;
      const s = this.currentTextModel.read(n);
      if (s !== this.model.targetTextModel.read(n))
        return;
      const o = this.model.ghostText.read(n);
      if (!o)
        return;
      const a = o instanceof Yh ? o.columnRange : void 0, l = [], d = [];
      function c(m, _) {
        if (d.length > 0) {
          const v = d[d.length - 1];
          _ && v.decorations.push(new Cr(
            v.content.length + 1,
            v.content.length + 1 + m[0].length,
            _,
            0
            /* InlineDecorationType.Regular */
          )), v.content += m[0], m = m.slice(1);
        }
        for (const v of m)
          d.push({
            content: v,
            decorations: _ ? [new Cr(
              1,
              v.length + 1,
              _,
              0
              /* InlineDecorationType.Regular */
            )] : []
          });
      }
      const h = s.getLineContent(o.lineNumber);
      let u, p = 0;
      for (const m of o.parts) {
        let _ = m.lines;
        u === void 0 ? (l.push({
          column: m.column,
          text: _[0],
          preview: m.preview
        }), _ = _.slice(1)) : c([h.substring(p, m.column - 1)], void 0), _.length > 0 && (c(_, qf), u === void 0 && m.column <= h.length && (u = m.column)), p = m.column - 1;
      }
      u !== void 0 && c([h.substring(p)], void 0);
      const f = u !== void 0 ? new Gb(u, h.length + 1) : void 0;
      return {
        replacedRange: a,
        inlineTexts: l,
        additionalLines: d,
        hiddenRange: f,
        lineNumber: o.lineNumber,
        additionalReservedLineCount: this.model.minReservedLineCount.read(n),
        targetTextModel: s
      };
    }), this.decorations = Xe(this, (n) => {
      const s = this.uiState.read(n);
      if (!s)
        return [];
      const o = [];
      s.replacedRange && o.push({
        range: s.replacedRange.toRange(s.lineNumber),
        options: { inlineClassName: "inline-completion-text-to-replace", description: "GhostTextReplacement" }
      }), s.hiddenRange && o.push({
        range: s.hiddenRange.toRange(s.lineNumber),
        options: { inlineClassName: "ghost-text-hidden", description: "ghost-text-hidden" }
      });
      for (const a of s.inlineTexts)
        o.push({
          range: S.fromPositions(new F(s.lineNumber, a.column)),
          options: {
            description: qf,
            after: { content: a.text, inlineClassName: a.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration", cursorStops: Rs.Left },
            showIfCollapsed: !0
          }
        });
      return o;
    }), this.additionalLinesWidget = this._register(new Qb(this.editor, this.languageService.languageIdCodec, Xe((n) => {
      const s = this.uiState.read(n);
      return s ? {
        lineNumber: s.lineNumber,
        additionalLines: s.additionalLines,
        minReservedLineCount: s.additionalReservedLineCount,
        targetTextModel: s.targetTextModel
      } : void 0;
    }))), this._register(pe(() => {
      this.isDisposed.set(!0, void 0);
    })), this._register(Zb(this.editor, this.decorations));
  }
  ownsViewZone(e) {
    return this.additionalLinesWidget.viewZoneId === e;
  }
};
Jh = Ik([
  Dk(2, Et)
], Jh);
class Qb extends P {
  get viewZoneId() {
    return this._viewZoneId;
  }
  constructor(e, t, i) {
    super(), this.editor = e, this.languageIdCodec = t, this.lines = i, this._viewZoneId = void 0, this.editorOptionsChanged = As("editorOptionChanged", De.filter(this.editor.onDidChangeConfiguration, (n) => n.hasChanged(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ) || n.hasChanged(
      117
      /* EditorOption.stopRenderingLineAfter */
    ) || n.hasChanged(
      99
      /* EditorOption.renderWhitespace */
    ) || n.hasChanged(
      94
      /* EditorOption.renderControlCharacters */
    ) || n.hasChanged(
      51
      /* EditorOption.fontLigatures */
    ) || n.hasChanged(
      50
      /* EditorOption.fontInfo */
    ) || n.hasChanged(
      67
      /* EditorOption.lineHeight */
    ))), this._register(Ne((n) => {
      const s = this.lines.read(n);
      this.editorOptionsChanged.read(n), s ? this.updateLines(s.lineNumber, s.additionalLines, s.minReservedLineCount) : this.clear();
    }));
  }
  dispose() {
    super.dispose(), this.clear();
  }
  clear() {
    this.editor.changeViewZones((e) => {
      this._viewZoneId && (e.removeZone(this._viewZoneId), this._viewZoneId = void 0);
    });
  }
  updateLines(e, t, i) {
    const n = this.editor.getModel();
    if (!n)
      return;
    const { tabSize: s } = n.getOptions();
    this.editor.changeViewZones((o) => {
      this._viewZoneId && (o.removeZone(this._viewZoneId), this._viewZoneId = void 0);
      const a = Math.max(t.length, i);
      if (a > 0) {
        const l = document.createElement("div");
        kk(l, s, t, this.editor.getOptions(), this.languageIdCodec), this._viewZoneId = o.addZone({
          afterLineNumber: e,
          heightInLines: a,
          domNode: l,
          afterColumnAffinity: 1
          /* PositionAffinity.Right */
        });
      }
    });
  }
}
function kk(r, e, t, i, n) {
  const s = i.get(
    33
    /* EditorOption.disableMonospaceOptimizations */
  ), o = i.get(
    117
    /* EditorOption.stopRenderingLineAfter */
  ), a = "none", l = i.get(
    94
    /* EditorOption.renderControlCharacters */
  ), d = i.get(
    51
    /* EditorOption.fontLigatures */
  ), c = i.get(
    50
    /* EditorOption.fontInfo */
  ), h = i.get(
    67
    /* EditorOption.lineHeight */
  ), u = new y_(1e4);
  u.appendString('<div class="suggest-preview-text">');
  for (let m = 0, _ = t.length; m < _; m++) {
    const v = t[m], C = v.content;
    u.appendString('<div class="view-line'), u.appendString('" style="top:'), u.appendString(String(m * h)), u.appendString('px;width:1000000px;">');
    const w = x_(C), y = hw(C), I = uw.createEmpty(C, n);
    S_(new w_(c.isMonospace && !s, c.canUseHalfwidthRightwardsArrow, C, !1, w, y, 0, I, v.decorations, e, 0, c.spaceWidth, c.middotWidth, c.wsmiddotWidth, o, a, l, d !== gw.OFF, null), u), u.appendString("</div>");
  }
  u.appendString("</div>"), pw(r, c);
  const p = u.build(), f = Kf ? Kf.createHTML(p) : p;
  r.innerHTML = f;
}
const Kf = C_("editorGhostText", { createHTML: (r) => r });
function Nk(r, e) {
  const t = new bw(), i = new _w(t, (d) => e.getLanguageConfiguration(d)), n = new fw(new Rk([r]), i), s = mw(n, [], void 0, !0);
  let o = "";
  const a = r.getLineContent();
  function l(d, c) {
    if (d.kind === 2)
      if (l(d.openingBracket, c), c = Ro(c, d.openingBracket.length), d.child && (l(d.child, c), c = Ro(c, d.child.length)), d.closingBracket)
        l(d.closingBracket, c), c = Ro(c, d.closingBracket.length);
      else {
        const u = i.getSingleLanguageBracketTokens(d.openingBracket.languageId).findClosingTokenText(d.openingBracket.bracketIds);
        o += u;
      }
    else if (d.kind !== 3) {
      if (d.kind === 0 || d.kind === 1)
        o += a.substring(Ap(c), Ap(Ro(c, d.length)));
      else if (d.kind === 4)
        for (const h of d.children)
          l(h, c), c = Ro(c, h.length);
    }
  }
  return l(s, vw), o;
}
class Rk {
  constructor(e) {
    this.lines = e, this.tokenization = {
      getLineTokens: (t) => this.lines[t - 1]
    };
  }
  getLineCount() {
    return this.lines.length;
  }
  getLineLength(e) {
    return this.lines[e - 1].getLineContent().length;
  }
}
async function Pk(r, e, t, i, n = X.None, s) {
  const o = Tk(e, t), a = r.all(t), l = new Sw();
  for (const v of a)
    v.groupId && l.add(v.groupId, v);
  function d(v) {
    if (!v.yieldsToGroupIds)
      return [];
    const C = [];
    for (const w of v.yieldsToGroupIds || []) {
      const y = l.get(w);
      for (const I of y)
        C.push(I);
    }
    return C;
  }
  const c = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Set();
  function u(v, C) {
    if (C = [...C, v], h.has(v))
      return C;
    h.add(v);
    try {
      const w = d(v);
      for (const y of w) {
        const I = u(y, C);
        if (I)
          return I;
      }
    } finally {
      h.delete(v);
    }
  }
  function p(v) {
    const C = c.get(v);
    if (C)
      return C;
    const w = u(v, []);
    w && Ie(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${w.map((I) => I.toString ? I.toString() : "" + I).join(" -> ")}`));
    const y = new L_();
    return c.set(v, y.p), (async () => {
      if (!w) {
        const I = d(v);
        for (const k of I) {
          const N = await p(k);
          if (N && N.items.length > 0)
            return;
        }
      }
      try {
        return await v.provideInlineCompletions(t, e, i, n);
      } catch (I) {
        Ie(I);
        return;
      }
    })().then((I) => y.complete(I), (I) => y.error(I)), y.p;
  }
  const f = await Promise.all(a.map(async (v) => ({ provider: v, completions: await p(v) }))), m = /* @__PURE__ */ new Map(), _ = [];
  for (const v of f) {
    const C = v.completions;
    if (!C)
      continue;
    const w = new Ek(C, v.provider);
    _.push(w);
    for (const y of C.items) {
      const I = zl.from(y, w, o, t, s);
      m.set(I.hash(), I);
    }
  }
  return new Mk(Array.from(m.values()), new Set(m.keys()), _);
}
class Mk {
  constructor(e, t, i) {
    this.completions = e, this.hashs = t, this.providerResults = i;
  }
  has(e) {
    return this.hashs.has(e.hash());
  }
  dispose() {
    for (const e of this.providerResults)
      e.removeRef();
  }
}
class Ek {
  constructor(e, t) {
    this.inlineCompletions = e, this.provider = t, this.refCount = 1;
  }
  addRef() {
    this.refCount++;
  }
  removeRef() {
    this.refCount--, this.refCount === 0 && this.provider.freeInlineCompletions(this.inlineCompletions);
  }
}
class zl {
  static from(e, t, i, n, s) {
    let o, a, l = e.range ? S.lift(e.range) : i;
    if (typeof e.insertText == "string") {
      if (o = e.insertText, s && e.completeBracketPairs) {
        o = Gf(o, l.getStartPosition(), n, s);
        const d = o.length - e.insertText.length;
        d !== 0 && (l = new S(l.startLineNumber, l.startColumn, l.endLineNumber, l.endColumn + d));
      }
      a = void 0;
    } else if ("snippet" in e.insertText) {
      const d = e.insertText.snippet.length;
      if (s && e.completeBracketPairs) {
        e.insertText.snippet = Gf(e.insertText.snippet, l.getStartPosition(), n, s);
        const h = e.insertText.snippet.length - d;
        h !== 0 && (l = new S(l.startLineNumber, l.startColumn, l.endLineNumber, l.endColumn + h));
      }
      const c = new Un().parse(e.insertText.snippet);
      c.children.length === 1 && c.children[0] instanceof ze ? (o = c.children[0].value, a = void 0) : (o = c.toString(), a = {
        snippet: e.insertText.snippet,
        range: l
      });
    } else
      Cw(e.insertText);
    return new zl(o, e.command, l, o, a, e.additionalTextEdits || xk(), e, t);
  }
  constructor(e, t, i, n, s, o, a, l) {
    this.filterText = e, this.command = t, this.range = i, this.insertText = n, this.snippetInfo = s, this.additionalTextEdits = o, this.sourceInlineCompletion = a, this.source = l, e = e.replace(/\r\n|\r/g, `
`), n = e.replace(/\r\n|\r/g, `
`);
  }
  withRange(e) {
    return new zl(this.filterText, this.command, e, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);
  }
  hash() {
    return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });
  }
}
function Tk(r, e) {
  const t = e.getWordAtPosition(r), i = e.getLineMaxColumn(r.lineNumber);
  return t ? new S(r.lineNumber, t.startColumn, r.lineNumber, i) : S.fromPositions(r, r.with(void 0, i));
}
function Gf(r, e, t, i) {
  const s = t.getLineContent(e.lineNumber).substring(0, e.column - 1) + r, o = t.tokenization.tokenizeLineWithEdit(e, s.length - (e.column - 1), r), a = o == null ? void 0 : o.sliceAndInflate(e.column - 1, s.length, 0);
  return a ? Nk(a, i) : r;
}
class gn {
  constructor(e, t) {
    this.range = e, this.text = t;
  }
  removeCommonPrefix(e, t) {
    const i = t ? this.range.intersectRanges(t) : this.range;
    if (!i)
      return this;
    const n = e.getValueInRange(
      i,
      1
      /* EndOfLinePreference.LF */
    ), s = ta(n, this.text), o = Vd(this.range.getStartPosition(), Jg(n.substring(0, s))), a = this.text.substring(s), l = S.fromPositions(o, this.range.getEndPosition());
    return new gn(l, a);
  }
  augments(e) {
    return this.text.startsWith(e.text) && Ak(this.range, e.range);
  }
  /**
   * @param previewSuffixLength Sets where to split `inlineCompletion.text`.
   * 	If the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.
  */
  computeGhostText(e, t, i, n = 0) {
    let s = this.removeCommonPrefix(e);
    if (s.range.endLineNumber !== s.range.startLineNumber)
      return;
    const o = e.getLineContent(s.range.startLineNumber), a = Ee(o).length;
    if (s.range.startColumn - 1 <= a) {
      const f = Ee(s.text).length, m = o.substring(s.range.startColumn - 1, a), [_, v] = [s.range.getStartPosition(), s.range.getEndPosition()], C = _.column + m.length <= v.column ? _.delta(0, m.length) : v, w = S.fromPositions(C, v), y = s.text.startsWith(m) ? s.text.substring(m.length) : s.text.substring(f);
      s = new gn(w, y);
    }
    const d = e.getValueInRange(s.range), c = Ok(d, s.text);
    if (!c)
      return;
    const h = s.range.startLineNumber, u = new Array();
    if (t === "prefix") {
      const f = c.filter((m) => m.originalLength === 0);
      if (f.length > 1 || f.length === 1 && f[0].originalStart !== d.length)
        return;
    }
    const p = s.text.length - n;
    for (const f of c) {
      const m = s.range.startColumn + f.originalStart + f.originalLength;
      if (t === "subwordSmart" && i && i.lineNumber === s.range.startLineNumber && m < i.column || f.originalLength > 0)
        return;
      if (f.modifiedLength === 0)
        continue;
      const _ = f.modifiedStart + f.modifiedLength, v = Math.max(f.modifiedStart, Math.min(_, p)), C = s.text.substring(f.modifiedStart, v), w = s.text.substring(v, Math.max(f.modifiedStart, _));
      C.length > 0 && u.push(new Ul(m, C, !1)), w.length > 0 && u.push(new Ul(m, w, !0));
    }
    return new Pr(h, u);
  }
}
function Ak(r, e) {
  return e.getStartPosition().equals(r.getStartPosition()) && e.getEndPosition().isBeforeOrEqual(r.getEndPosition());
}
let Yt;
function Ok(r, e) {
  if ((Yt == null ? void 0 : Yt.originalValue) === r && (Yt == null ? void 0 : Yt.newValue) === e)
    return Yt == null ? void 0 : Yt.changes;
  {
    let t = Xf(r, e, !0);
    if (t) {
      const i = Zf(t);
      if (i > 0) {
        const n = Xf(r, e, !1);
        n && Zf(n) < i && (t = n);
      }
    }
    return Yt = {
      originalValue: r,
      newValue: e,
      changes: t
    }, t;
  }
}
function Zf(r) {
  let e = 0;
  for (const t of r)
    e += t.originalLength;
  return e;
}
function Xf(r, e, t) {
  if (r.length > 5e3 || e.length > 5e3)
    return;
  function i(d) {
    let c = 0;
    for (let h = 0, u = d.length; h < u; h++) {
      const p = d.charCodeAt(h);
      p > c && (c = p);
    }
    return c;
  }
  const n = Math.max(i(r), i(e));
  function s(d) {
    if (d < 0)
      throw new Error("unexpected");
    return n + d + 1;
  }
  function o(d) {
    let c = 0, h = 0;
    const u = new Int32Array(d.length);
    for (let p = 0, f = d.length; p < f; p++)
      if (t && d[p] === "(") {
        const m = h * 100 + c;
        u[p] = s(2 * m), c++;
      } else if (t && d[p] === ")") {
        c = Math.max(c - 1, 0);
        const m = h * 100 + c;
        u[p] = s(2 * m + 1), c === 0 && h++;
      } else
        u[p] = d.charCodeAt(p);
    return u;
  }
  const a = o(r), l = o(e);
  return new ww({ getElements: () => a }, { getElements: () => l }).ComputeDiff(!1).changes;
}
var Fk = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Qf = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let eu = class extends P {
  constructor(e, t, i, n, s) {
    super(), this.textModel = e, this.versionId = t, this._debounceValue = i, this.languageFeaturesService = n, this.languageConfigurationService = s, this._updateOperation = this._register(new ft()), this.inlineCompletions = Ll("inlineCompletions", void 0), this.suggestWidgetInlineCompletions = Ll("suggestWidgetInlineCompletions", void 0), this._register(this.textModel.onDidChangeContent(() => {
      this._updateOperation.clear();
    }));
  }
  fetch(e, t, i) {
    var n, s;
    const o = new Hk(e, t, this.textModel.getVersionId()), a = t.selectedSuggestionInfo ? this.suggestWidgetInlineCompletions : this.inlineCompletions;
    if (!((n = this._updateOperation.value) === null || n === void 0) && n.request.satisfies(o))
      return this._updateOperation.value.promise;
    if (!((s = a.get()) === null || s === void 0) && s.request.satisfies(o))
      return Promise.resolve(!0);
    const l = !!this._updateOperation.value;
    this._updateOperation.clear();
    const d = new Oe(), c = (async () => {
      if ((l || t.triggerKind === Tn.Automatic) && await Wk(this._debounceValue.get(this.textModel), d.token), d.token.isCancellationRequested || this.textModel.getVersionId() !== o.versionId)
        return !1;
      const p = /* @__PURE__ */ new Date(), f = await Pk(this.languageFeaturesService.inlineCompletionsProvider, e, this.textModel, t, d.token, this.languageConfigurationService);
      if (d.token.isCancellationRequested || this.textModel.getVersionId() !== o.versionId)
        return !1;
      const m = /* @__PURE__ */ new Date();
      this._debounceValue.update(this.textModel, m.getTime() - p.getTime());
      const _ = new Uk(f, o, this.textModel, this.versionId);
      if (i) {
        const v = i.toInlineCompletion(void 0);
        i.canBeReused(this.textModel, e) && !f.has(v) && _.prepend(i.inlineCompletion, v.range, !0);
      }
      return this._updateOperation.clear(), ht((v) => {
        a.set(_, v);
      }), !0;
    })(), h = new Vk(o, d, c);
    return this._updateOperation.value = h, c;
  }
  clear(e) {
    this._updateOperation.clear(), this.inlineCompletions.set(void 0, e), this.suggestWidgetInlineCompletions.set(void 0, e);
  }
  clearSuggestWidgetInlineCompletions(e) {
    var t;
    !((t = this._updateOperation.value) === null || t === void 0) && t.request.context.selectedSuggestionInfo && this._updateOperation.clear(), this.suggestWidgetInlineCompletions.set(void 0, e);
  }
  cancelUpdate() {
    this._updateOperation.clear();
  }
};
eu = Fk([
  Qf(3, V),
  Qf(4, fe)
], eu);
function Wk(r, e) {
  return new Promise((t) => {
    let i;
    const n = setTimeout(() => {
      i && i.dispose(), t();
    }, r);
    e && (i = e.onCancellationRequested(() => {
      clearTimeout(n), i && i.dispose(), t();
    }));
  });
}
class Hk {
  constructor(e, t, i) {
    this.position = e, this.context = t, this.versionId = i;
  }
  satisfies(e) {
    return this.position.equals(e.position) && Bk(this.context.selectedSuggestionInfo, e.context.selectedSuggestionInfo, (t, i) => t.equals(i)) && (e.context.triggerKind === Tn.Automatic || this.context.triggerKind === Tn.Explicit) && this.versionId === e.versionId;
  }
}
function Bk(r, e, t) {
  return !r || !e ? r === e : t(r, e);
}
class Vk {
  constructor(e, t, i) {
    this.request = e, this.cancellationTokenSource = t, this.promise = i;
  }
  dispose() {
    this.cancellationTokenSource.cancel();
  }
}
class Uk {
  get inlineCompletions() {
    return this._inlineCompletions;
  }
  constructor(e, t, i, n) {
    this.inlineCompletionProviderResult = e, this.request = t, this.textModel = i, this.versionId = n, this._refCount = 1, this._prependedInlineCompletionItems = [], this._rangeVersionIdValue = 0, this._rangeVersionId = Xe(this, (o) => {
      this.versionId.read(o);
      let a = !1;
      for (const l of this._inlineCompletions)
        a = a || l._updateRange(this.textModel);
      return a && this._rangeVersionIdValue++, this._rangeVersionIdValue;
    });
    const s = i.deltaDecorations([], e.completions.map((o) => ({
      range: o.range,
      options: {
        description: "inline-completion-tracking-range"
      }
    })));
    this._inlineCompletions = e.completions.map((o, a) => new Yf(o, s[a], this._rangeVersionId));
  }
  clone() {
    return this._refCount++, this;
  }
  dispose() {
    if (this._refCount--, this._refCount === 0) {
      setTimeout(() => {
        this.textModel.isDisposed() || this.textModel.deltaDecorations(this._inlineCompletions.map((e) => e.decorationId), []);
      }, 0), this.inlineCompletionProviderResult.dispose();
      for (const e of this._prependedInlineCompletionItems)
        e.source.removeRef();
    }
  }
  prepend(e, t, i) {
    i && e.source.addRef();
    const n = this.textModel.deltaDecorations([], [{
      range: t,
      options: {
        description: "inline-completion-tracking-range"
      }
    }])[0];
    this._inlineCompletions.unshift(new Yf(e, n, this._rangeVersionId, t)), this._prependedInlineCompletionItems.push(e);
  }
}
class Yf {
  get forwardStable() {
    var e;
    return (e = this.inlineCompletion.source.inlineCompletions.enableForwardStability) !== null && e !== void 0 ? e : !1;
  }
  constructor(e, t, i, n) {
    this.inlineCompletion = e, this.decorationId = t, this.rangeVersion = i, this.semanticId = JSON.stringify([
      this.inlineCompletion.filterText,
      this.inlineCompletion.insertText,
      this.inlineCompletion.range.getStartPosition().toString()
    ]), this._isValid = !0, this._updatedRange = n ?? e.range;
  }
  toInlineCompletion(e) {
    return this.inlineCompletion.withRange(this._getUpdatedRange(e));
  }
  toSingleTextEdit(e) {
    return new gn(this._getUpdatedRange(e), this.inlineCompletion.insertText);
  }
  isVisible(e, t, i) {
    const n = this._toFilterTextReplacement(i).removeCommonPrefix(e);
    if (!this._isValid || !this.inlineCompletion.range.getStartPosition().equals(this._getUpdatedRange(i).getStartPosition()) || t.lineNumber !== n.range.startLineNumber)
      return !1;
    const s = e.getValueInRange(
      n.range,
      1
      /* EndOfLinePreference.LF */
    ), o = n.text, a = Math.max(0, t.column - n.range.startColumn);
    let l = o.substring(0, a), d = o.substring(a), c = s.substring(0, a), h = s.substring(a);
    const u = e.getLineIndentColumn(n.range.startLineNumber);
    return n.range.startColumn <= u && (c = c.trimStart(), c.length === 0 && (h = h.trimStart()), l = l.trimStart(), l.length === 0 && (d = d.trimStart())), l.startsWith(c) && !!yw(h, d);
  }
  canBeReused(e, t) {
    return this._isValid && this._getUpdatedRange(void 0).containsPosition(t) && this.isVisible(e, t, void 0) && !this._isSmallerThanOriginal(void 0);
  }
  _toFilterTextReplacement(e) {
    return new gn(this._getUpdatedRange(e), this.inlineCompletion.filterText);
  }
  _isSmallerThanOriginal(e) {
    return Jf(this._getUpdatedRange(e)).isBefore(Jf(this.inlineCompletion.range));
  }
  _getUpdatedRange(e) {
    return this.rangeVersion.read(e), this._updatedRange;
  }
  _updateRange(e) {
    const t = e.getDecorationRange(this.decorationId);
    return t ? this._updatedRange.equalsRange(t) ? !1 : (this._updatedRange = t, !0) : (this._isValid = !1, !0);
  }
}
function Jf(r) {
  return r.startLineNumber === r.endLineNumber ? new F(1, 1 + r.endColumn - r.startColumn) : new F(1 + r.endLineNumber - r.startLineNumber, r.endColumn);
}
const U = {
  Visible: qg,
  HasFocusedSuggestion: new Q("suggestWidgetHasFocusedSuggestion", !1, g("suggestWidgetHasSelection", "Whether any suggestion is focused")),
  DetailsVisible: new Q("suggestWidgetDetailsVisible", !1, g("suggestWidgetDetailsVisible", "Whether suggestion details are visible")),
  MultipleSuggestions: new Q("suggestWidgetMultipleSuggestions", !1, g("suggestWidgetMultipleSuggestions", "Whether there are multiple suggestions to pick from")),
  MakesTextEdit: new Q("suggestionMakesTextEdit", !0, g("suggestionMakesTextEdit", "Whether inserting the current suggestion yields in a change or has everything already been typed")),
  AcceptSuggestionsOnEnter: new Q("acceptSuggestionOnEnter", !0, g("acceptSuggestionOnEnter", "Whether suggestions are inserted when pressing Enter")),
  HasInsertAndReplaceRange: new Q("suggestionHasInsertAndReplaceRange", !1, g("suggestionHasInsertAndReplaceRange", "Whether the current suggestion has insert and replace behaviour")),
  InsertMode: new Q("suggestionInsertMode", void 0, { type: "string", description: g("suggestionInsertMode", "Whether the default behaviour is to insert or replace") }),
  CanResolve: new Q("suggestionCanResolve", !1, g("suggestionCanResolve", "Whether the current suggestion supports to resolve further details"))
}, tn = new E("suggestWidgetStatusBar");
class zk {
  constructor(e, t, i, n) {
    var s;
    this.position = e, this.completion = t, this.container = i, this.provider = n, this.isInvalid = !1, this.score = mr.Default, this.distance = 0, this.textLabel = typeof t.label == "string" ? t.label : (s = t.label) === null || s === void 0 ? void 0 : s.label, this.labelLow = this.textLabel.toLowerCase(), this.isInvalid = !this.textLabel, this.sortTextLow = t.sortText && t.sortText.toLowerCase(), this.filterTextLow = t.filterText && t.filterText.toLowerCase(), this.extensionId = t.extensionId, S.isIRange(t.range) ? (this.editStart = new F(t.range.startLineNumber, t.range.startColumn), this.editInsertEnd = new F(t.range.endLineNumber, t.range.endColumn), this.editReplaceEnd = new F(t.range.endLineNumber, t.range.endColumn), this.isInvalid = this.isInvalid || S.spansMultipleLines(t.range) || t.range.startLineNumber !== e.lineNumber) : (this.editStart = new F(t.range.insert.startLineNumber, t.range.insert.startColumn), this.editInsertEnd = new F(t.range.insert.endLineNumber, t.range.insert.endColumn), this.editReplaceEnd = new F(t.range.replace.endLineNumber, t.range.replace.endColumn), this.isInvalid = this.isInvalid || S.spansMultipleLines(t.range.insert) || S.spansMultipleLines(t.range.replace) || t.range.insert.startLineNumber !== e.lineNumber || t.range.replace.startLineNumber !== e.lineNumber || t.range.insert.startColumn !== t.range.replace.startColumn), typeof n.resolveCompletionItem != "function" && (this._resolveCache = Promise.resolve(), this._resolveDuration = 0);
  }
  // ---- resolving
  get isResolved() {
    return this._resolveDuration !== void 0;
  }
  get resolveDuration() {
    return this._resolveDuration !== void 0 ? this._resolveDuration : -1;
  }
  async resolve(e) {
    if (!this._resolveCache) {
      const t = e.onCancellationRequested(() => {
        this._resolveCache = void 0, this._resolveDuration = void 0;
      }), i = new Rt(!0);
      this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, e)).then((n) => {
        Object.assign(this.completion, n), this._resolveDuration = i.elapsed();
      }, (n) => {
        go(n) && (this._resolveCache = void 0, this._resolveDuration = void 0);
      }).finally(() => {
        t.dispose();
      });
    }
    return this._resolveCache;
  }
}
class Mr {
  constructor(e = 2, t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Map(), s = !0) {
    this.snippetSortOrder = e, this.kindFilter = t, this.providerFilter = i, this.providerItemsToReuse = n, this.showDeprecated = s;
  }
}
Mr.default = new Mr();
let $k;
function jk() {
  return $k;
}
class qk {
  constructor(e, t, i, n) {
    this.items = e, this.needsClipboard = t, this.durations = i, this.disposable = n;
  }
}
async function ep(r, e, t, i = Mr.default, n = {
  triggerKind: 0
  /* languages.CompletionTriggerKind.Invoke */
}, s = X.None) {
  const o = new Rt();
  t = t.clone();
  const a = e.getWordAtPosition(t), l = a ? new S(t.lineNumber, a.startColumn, t.lineNumber, a.endColumn) : S.fromPositions(t), d = { replace: l, insert: l.setEndPosition(t.lineNumber, t.column) }, c = [], h = new M(), u = [];
  let p = !1;
  const f = (_, v, C) => {
    var w, y, I;
    let k = !1;
    if (!v)
      return k;
    for (const N of v.suggestions)
      if (!i.kindFilter.has(N.kind)) {
        if (!i.showDeprecated && (!((w = N == null ? void 0 : N.tags) === null || w === void 0) && w.includes(
          1
          /* languages.CompletionItemTag.Deprecated */
        )))
          continue;
        N.range || (N.range = d), N.sortText || (N.sortText = typeof N.label == "string" ? N.label : N.label.label), !p && N.insertTextRules && N.insertTextRules & 4 && (p = Un.guessNeedsClipboard(N.insertText)), c.push(new zk(t, N, v, _)), k = !0;
      }
    return D_(v) && h.add(v), u.push({
      providerName: (y = _._debugDisplayName) !== null && y !== void 0 ? y : "unknown_provider",
      elapsedProvider: (I = v.duration) !== null && I !== void 0 ? I : -1,
      elapsedOverall: C.elapsed()
    }), k;
  }, m = (async () => {
  })();
  for (const _ of r.orderedGroups(e)) {
    let v = !1;
    if (await Promise.all(_.map(async (C) => {
      if (i.providerItemsToReuse.has(C)) {
        const w = i.providerItemsToReuse.get(C);
        w.forEach((y) => c.push(y)), v = v || w.length > 0;
        return;
      }
      if (!(i.providerFilter.size > 0 && !i.providerFilter.has(C)))
        try {
          const w = new Rt(), y = await C.provideCompletionItems(e, t, n, s);
          v = f(C, y, w) || v;
        } catch (w) {
          Ie(w);
        }
    })), v || s.isCancellationRequested)
      break;
  }
  return await m, s.isCancellationRequested ? (h.dispose(), Promise.reject(new I_())) : new qk(c.sort(Zk(i.snippetSortOrder)), p, { entries: u, elapsed: o.elapsed() }, h);
}
function tp(r, e) {
  if (r.sortTextLow && e.sortTextLow) {
    if (r.sortTextLow < e.sortTextLow)
      return -1;
    if (r.sortTextLow > e.sortTextLow)
      return 1;
  }
  return r.textLabel < e.textLabel ? -1 : r.textLabel > e.textLabel ? 1 : r.completion.kind - e.completion.kind;
}
function Kk(r, e) {
  if (r.completion.kind !== e.completion.kind) {
    if (r.completion.kind === 27)
      return -1;
    if (e.completion.kind === 27)
      return 1;
  }
  return tp(r, e);
}
function Gk(r, e) {
  if (r.completion.kind !== e.completion.kind) {
    if (r.completion.kind === 27)
      return 1;
    if (e.completion.kind === 27)
      return -1;
  }
  return tp(r, e);
}
const Ud = /* @__PURE__ */ new Map();
Ud.set(0, Kk);
Ud.set(2, Gk);
Ud.set(1, tp);
function Zk(r) {
  return Ud.get(r);
}
de.registerCommand("_executeCompletionItemProvider", async (r, ...e) => {
  const [t, i, n, s] = e;
  ie(ce.isUri(t)), ie(F.isIPosition(i)), ie(typeof n == "string" || !n), ie(typeof s == "number" || !s);
  const { completionProvider: o } = r.get(V), a = await r.get(Zt).createModelReference(t);
  try {
    const l = {
      incomplete: !1,
      suggestions: []
    }, d = [], c = a.object.textEditorModel.validatePosition(i), h = await ep(o, a.object.textEditorModel, c, void 0, {
      triggerCharacter: n ?? void 0,
      triggerKind: n ? 1 : 0
      /* languages.CompletionTriggerKind.Invoke */
    });
    for (const u of h.items)
      d.length < (s ?? 0) && d.push(u.resolve(X.None)), l.incomplete = l.incomplete || u.container.incomplete, l.suggestions.push(u.completion);
    try {
      return await Promise.all(d), l;
    } finally {
      setTimeout(() => h.disposable.dispose(), 100);
    }
  } finally {
    a.dispose();
  }
});
function Xk(r, e) {
  var t;
  (t = r.getContribution("editor.contrib.suggestController")) === null || t === void 0 || t.triggerSuggest((/* @__PURE__ */ new Set()).add(e), void 0, !0);
}
class Es {
  static isAllOff(e) {
    return e.other === "off" && e.comments === "off" && e.strings === "off";
  }
  static isAllOn(e) {
    return e.other === "on" && e.comments === "on" && e.strings === "on";
  }
  static valueFor(e, t) {
    switch (t) {
      case 1:
        return e.comments;
      case 2:
        return e.strings;
      default:
        return e.other;
    }
  }
}
function em(r, e = nd) {
  return xw(r, e) ? r.charAt(0).toUpperCase() + r.slice(1) : r;
}
var Qk = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Yk = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class tm {
  constructor(e) {
    this._delegates = e;
  }
  resolve(e) {
    for (const t of this._delegates) {
      const i = t.resolve(e);
      if (i !== void 0)
        return i;
    }
  }
}
class im {
  constructor(e, t, i, n) {
    this._model = e, this._selection = t, this._selectionIdx = i, this._overtypingCapturer = n;
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "SELECTION" || t === "TM_SELECTED_TEXT") {
      let i = this._model.getValueInRange(this._selection) || void 0, n = this._selection.startLineNumber !== this._selection.endLineNumber;
      if (!i && this._overtypingCapturer) {
        const s = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
        s && (i = s.value, n = s.multiline);
      }
      if (i && n && e.snippet) {
        const s = this._model.getLineContent(this._selection.startLineNumber), o = Ee(s, 0, this._selection.startColumn - 1);
        let a = o;
        e.snippet.walk((d) => d === e ? !1 : (d instanceof ze && (a = Ee(dd(d.value).pop())), !0));
        const l = ta(a, o);
        i = i.replace(/(\r\n|\r|\n)(.*)/g, (d, c, h) => `${c}${a.substr(l)}${h}`);
      }
      return i;
    } else {
      if (t === "TM_CURRENT_LINE")
        return this._model.getLineContent(this._selection.positionLineNumber);
      if (t === "TM_CURRENT_WORD") {
        const i = this._model.getWordAtPosition({
          lineNumber: this._selection.positionLineNumber,
          column: this._selection.positionColumn
        });
        return i && i.word || void 0;
      } else {
        if (t === "TM_LINE_INDEX")
          return String(this._selection.positionLineNumber - 1);
        if (t === "TM_LINE_NUMBER")
          return String(this._selection.positionLineNumber);
        if (t === "CURSOR_INDEX")
          return String(this._selectionIdx);
        if (t === "CURSOR_NUMBER")
          return String(this._selectionIdx + 1);
      }
    }
  }
}
class nm {
  constructor(e, t) {
    this._labelService = e, this._model = t;
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "TM_FILENAME")
      return Yo(this._model.uri.fsPath);
    if (t === "TM_FILENAME_BASE") {
      const i = Yo(this._model.uri.fsPath), n = i.lastIndexOf(".");
      return n <= 0 ? i : i.slice(0, n);
    } else {
      if (t === "TM_DIRECTORY")
        return Lw(this._model.uri.fsPath) === "." ? "" : this._labelService.getUriLabel(ag(this._model.uri));
      if (t === "TM_FILEPATH")
        return this._labelService.getUriLabel(this._model.uri);
      if (t === "RELATIVE_FILEPATH")
        return this._labelService.getUriLabel(this._model.uri, { relative: !0, noPrefix: !0 });
    }
  }
}
class sm {
  constructor(e, t, i, n) {
    this._readClipboardText = e, this._selectionIdx = t, this._selectionCount = i, this._spread = n;
  }
  resolve(e) {
    if (e.name !== "CLIPBOARD")
      return;
    const t = this._readClipboardText();
    if (t) {
      if (this._spread) {
        const i = t.split(/\r\n|\n|\r/).filter((n) => !Iw(n));
        if (i.length === this._selectionCount)
          return i[this._selectionIdx];
      }
      return t;
    }
  }
}
let $l = class {
  constructor(e, t, i) {
    this._model = e, this._selection = t, this._languageConfigurationService = i;
  }
  resolve(e) {
    const { name: t } = e, i = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn), n = this._languageConfigurationService.getLanguageConfiguration(i).comments;
    if (n) {
      if (t === "LINE_COMMENT")
        return n.lineCommentToken || void 0;
      if (t === "BLOCK_COMMENT_START")
        return n.blockCommentStartToken || void 0;
      if (t === "BLOCK_COMMENT_END")
        return n.blockCommentEndToken || void 0;
    }
  }
};
$l = Qk([
  Yk(2, fe)
], $l);
class $t {
  constructor() {
    this._date = /* @__PURE__ */ new Date();
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "CURRENT_YEAR")
      return String(this._date.getFullYear());
    if (t === "CURRENT_YEAR_SHORT")
      return String(this._date.getFullYear()).slice(-2);
    if (t === "CURRENT_MONTH")
      return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
    if (t === "CURRENT_DATE")
      return String(this._date.getDate().valueOf()).padStart(2, "0");
    if (t === "CURRENT_HOUR")
      return String(this._date.getHours().valueOf()).padStart(2, "0");
    if (t === "CURRENT_MINUTE")
      return String(this._date.getMinutes().valueOf()).padStart(2, "0");
    if (t === "CURRENT_SECOND")
      return String(this._date.getSeconds().valueOf()).padStart(2, "0");
    if (t === "CURRENT_DAY_NAME")
      return $t.dayNames[this._date.getDay()];
    if (t === "CURRENT_DAY_NAME_SHORT")
      return $t.dayNamesShort[this._date.getDay()];
    if (t === "CURRENT_MONTH_NAME")
      return $t.monthNames[this._date.getMonth()];
    if (t === "CURRENT_MONTH_NAME_SHORT")
      return $t.monthNamesShort[this._date.getMonth()];
    if (t === "CURRENT_SECONDS_UNIX")
      return String(Math.floor(this._date.getTime() / 1e3));
    if (t === "CURRENT_TIMEZONE_OFFSET") {
      const i = this._date.getTimezoneOffset(), n = i > 0 ? "-" : "+", s = Math.trunc(Math.abs(i / 60)), o = s < 10 ? "0" + s : s, a = Math.abs(i) - s * 60, l = a < 10 ? "0" + a : a;
      return n + o + ":" + l;
    }
  }
}
$t.dayNames = [g("Sunday", "Sunday"), g("Monday", "Monday"), g("Tuesday", "Tuesday"), g("Wednesday", "Wednesday"), g("Thursday", "Thursday"), g("Friday", "Friday"), g("Saturday", "Saturday")];
$t.dayNamesShort = [g("SundayShort", "Sun"), g("MondayShort", "Mon"), g("TuesdayShort", "Tue"), g("WednesdayShort", "Wed"), g("ThursdayShort", "Thu"), g("FridayShort", "Fri"), g("SaturdayShort", "Sat")];
$t.monthNames = [g("January", "January"), g("February", "February"), g("March", "March"), g("April", "April"), g("May", "May"), g("June", "June"), g("July", "July"), g("August", "August"), g("September", "September"), g("October", "October"), g("November", "November"), g("December", "December")];
$t.monthNamesShort = [g("JanuaryShort", "Jan"), g("FebruaryShort", "Feb"), g("MarchShort", "Mar"), g("AprilShort", "Apr"), g("MayShort", "May"), g("JuneShort", "Jun"), g("JulyShort", "Jul"), g("AugustShort", "Aug"), g("SeptemberShort", "Sep"), g("OctoberShort", "Oct"), g("NovemberShort", "Nov"), g("DecemberShort", "Dec")];
class om {
  constructor(e) {
    this._workspaceService = e;
  }
  resolve(e) {
    if (!this._workspaceService)
      return;
    const t = Dw(this._workspaceService.getWorkspace());
    if (!kw(t)) {
      if (e.name === "WORKSPACE_NAME")
        return this._resolveWorkspaceName(t);
      if (e.name === "WORKSPACE_FOLDER")
        return this._resoveWorkspacePath(t);
    }
  }
  _resolveWorkspaceName(e) {
    if (Op(e))
      return Yo(e.uri.path);
    let t = Yo(e.configPath.path);
    return t.endsWith(Fp) && (t = t.substr(0, t.length - Fp.length - 1)), t;
  }
  _resoveWorkspacePath(e) {
    if (Op(e))
      return em(e.uri.fsPath);
    const t = Yo(e.configPath.path);
    let i = e.configPath.fsPath;
    return i.endsWith(t) && (i = i.substr(0, i.length - t.length - 1)), i ? em(i) : "/";
  }
}
class rm {
  resolve(e) {
    const { name: t } = e;
    if (t === "RANDOM")
      return Math.random().toString().slice(-6);
    if (t === "RANDOM_HEX")
      return Math.random().toString(16).slice(-6);
    if (t === "UUID")
      return wd();
  }
}
var Jk = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, eN = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Tt;
class Ct {
  constructor(e, t, i) {
    this._editor = e, this._snippet = t, this._snippetLineLeadingWhitespace = i, this._offset = -1, this._nestingLevel = 1, this._placeholderGroups = Wp(t.placeholders, St.compareByIndex), this._placeholderGroupsIdx = -1;
  }
  initialize(e) {
    this._offset = e.newPosition;
  }
  dispose() {
    this._placeholderDecorations && this._editor.removeDecorations([...this._placeholderDecorations.values()]), this._placeholderGroups.length = 0;
  }
  _initDecorations() {
    if (this._offset === -1)
      throw new Error("Snippet not initialized!");
    if (this._placeholderDecorations)
      return;
    this._placeholderDecorations = /* @__PURE__ */ new Map();
    const e = this._editor.getModel();
    this._editor.changeDecorations((t) => {
      for (const i of this._snippet.placeholders) {
        const n = this._snippet.offset(i), s = this._snippet.fullLen(i), o = S.fromPositions(e.getPositionAt(this._offset + n), e.getPositionAt(this._offset + n + s)), a = i.isFinalTabstop ? Ct._decor.inactiveFinal : Ct._decor.inactive, l = t.addDecoration(o, a);
        this._placeholderDecorations.set(i, l);
      }
    });
  }
  move(e) {
    if (!this._editor.hasModel())
      return [];
    if (this._initDecorations(), this._placeholderGroupsIdx >= 0) {
      const n = [];
      for (const s of this._placeholderGroups[this._placeholderGroupsIdx])
        if (s.transform) {
          const o = this._placeholderDecorations.get(s), a = this._editor.getModel().getDecorationRange(o), l = this._editor.getModel().getValueInRange(a), d = s.transform.resolve(l).split(/\r\n|\r|\n/);
          for (let c = 1; c < d.length; c++)
            d[c] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + d[c]);
          n.push(ue.replace(a, d.join(this._editor.getModel().getEOL())));
        }
      n.length > 0 && this._editor.executeEdits("snippet.placeholderTransform", n);
    }
    let t = !1;
    e === !0 && this._placeholderGroupsIdx < this._placeholderGroups.length - 1 ? (this._placeholderGroupsIdx += 1, t = !0) : e === !1 && this._placeholderGroupsIdx > 0 && (this._placeholderGroupsIdx -= 1, t = !0);
    const i = this._editor.getModel().changeDecorations((n) => {
      const s = /* @__PURE__ */ new Set(), o = [];
      for (const a of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const l = this._placeholderDecorations.get(a), d = this._editor.getModel().getDecorationRange(l);
        o.push(new z(d.startLineNumber, d.startColumn, d.endLineNumber, d.endColumn)), t = t && this._hasPlaceholderBeenCollapsed(a), n.changeDecorationOptions(l, a.isFinalTabstop ? Ct._decor.activeFinal : Ct._decor.active), s.add(a);
        for (const c of this._snippet.enclosingPlaceholders(a)) {
          const h = this._placeholderDecorations.get(c);
          n.changeDecorationOptions(h, c.isFinalTabstop ? Ct._decor.activeFinal : Ct._decor.active), s.add(c);
        }
      }
      for (const [a, l] of this._placeholderDecorations)
        s.has(a) || n.changeDecorationOptions(l, a.isFinalTabstop ? Ct._decor.inactiveFinal : Ct._decor.inactive);
      return o;
    });
    return t ? this.move(e) : i ?? [];
  }
  _hasPlaceholderBeenCollapsed(e) {
    let t = e;
    for (; t; ) {
      if (t instanceof St) {
        const i = this._placeholderDecorations.get(t);
        if (this._editor.getModel().getDecorationRange(i).isEmpty() && t.toString().length > 0)
          return !0;
      }
      t = t.parent;
    }
    return !1;
  }
  get isAtFirstPlaceholder() {
    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
  }
  get isAtLastPlaceholder() {
    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
  }
  get hasPlaceholder() {
    return this._snippet.placeholders.length > 0;
  }
  /**
   * A snippet is trivial when it has no placeholder or only a final placeholder at
   * its very end
   */
  get isTrivialSnippet() {
    if (this._snippet.placeholders.length === 0)
      return !0;
    if (this._snippet.placeholders.length === 1) {
      const [e] = this._snippet.placeholders;
      if (e.isFinalTabstop && this._snippet.rightMostDescendant === e)
        return !0;
    }
    return !1;
  }
  computePossibleSelections() {
    const e = /* @__PURE__ */ new Map();
    for (const t of this._placeholderGroups) {
      let i;
      for (const n of t) {
        if (n.isFinalTabstop)
          break;
        i || (i = [], e.set(n.index, i));
        const s = this._placeholderDecorations.get(n), o = this._editor.getModel().getDecorationRange(s);
        if (!o) {
          e.delete(n.index);
          break;
        }
        i.push(o);
      }
    }
    return e;
  }
  get activeChoice() {
    if (!this._placeholderDecorations)
      return;
    const e = this._placeholderGroups[this._placeholderGroupsIdx][0];
    if (!(e != null && e.choice))
      return;
    const t = this._placeholderDecorations.get(e);
    if (!t)
      return;
    const i = this._editor.getModel().getDecorationRange(t);
    if (i)
      return { range: i, choice: e.choice };
  }
  get hasChoice() {
    let e = !1;
    return this._snippet.walk((t) => (e = t instanceof Co, !e)), e;
  }
  merge(e) {
    const t = this._editor.getModel();
    this._nestingLevel *= 10, this._editor.changeDecorations((i) => {
      for (const n of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const s = e.shift();
        console.assert(s._offset !== -1), console.assert(!s._placeholderDecorations);
        const o = s._snippet.placeholderInfo.last.index;
        for (const l of s._snippet.placeholderInfo.all)
          l.isFinalTabstop ? l.index = n.index + (o + 1) / this._nestingLevel : l.index = n.index + l.index / this._nestingLevel;
        this._snippet.replace(n, s._snippet.children);
        const a = this._placeholderDecorations.get(n);
        i.removeDecoration(a), this._placeholderDecorations.delete(n);
        for (const l of s._snippet.placeholders) {
          const d = s._snippet.offset(l), c = s._snippet.fullLen(l), h = S.fromPositions(t.getPositionAt(s._offset + d), t.getPositionAt(s._offset + d + c)), u = i.addDecoration(h, Ct._decor.inactive);
          this._placeholderDecorations.set(l, u);
        }
      }
      this._placeholderGroups = Wp(this._snippet.placeholders, St.compareByIndex);
    });
  }
}
Ct._decor = {
  active: Y.register({ description: "snippet-placeholder-1", stickiness: 0, className: "snippet-placeholder" }),
  inactive: Y.register({ description: "snippet-placeholder-2", stickiness: 1, className: "snippet-placeholder" }),
  activeFinal: Y.register({ description: "snippet-placeholder-3", stickiness: 1, className: "finish-snippet-placeholder" }),
  inactiveFinal: Y.register({ description: "snippet-placeholder-4", stickiness: 1, className: "finish-snippet-placeholder" })
};
const am = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  adjustWhitespace: !0,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
let jl = Tt = class {
  static adjustWhitespace(e, t, i, n, s) {
    const o = e.getLineContent(t.lineNumber), a = Ee(o, 0, t.column - 1);
    let l;
    return n.walk((d) => {
      if (!(d instanceof ze) || d.parent instanceof Co || s && !s.has(d))
        return !0;
      const c = d.value.split(/\r\n|\r|\n/);
      if (i) {
        const u = n.offset(d);
        if (u === 0)
          c[0] = e.normalizeIndentation(c[0]);
        else {
          l = l ?? n.toString();
          const p = l.charCodeAt(u - 1);
          (p === 10 || p === 13) && (c[0] = e.normalizeIndentation(a + c[0]));
        }
        for (let p = 1; p < c.length; p++)
          c[p] = e.normalizeIndentation(a + c[p]);
      }
      const h = c.join(e.getEOL());
      return h !== d.value && (d.parent.replace(d, [new ze(h)]), l = void 0), !0;
    }), a;
  }
  static adjustSelection(e, t, i, n) {
    if (i !== 0 || n !== 0) {
      const { positionLineNumber: s, positionColumn: o } = t, a = o - i, l = o + n, d = e.validateRange({
        startLineNumber: s,
        startColumn: a,
        endLineNumber: s,
        endColumn: l
      });
      t = z.createWithDirection(d.startLineNumber, d.startColumn, d.endLineNumber, d.endColumn, t.getDirection());
    }
    return t;
  }
  static createEditsAndSnippetsFromSelections(e, t, i, n, s, o, a, l, d) {
    const c = [], h = [];
    if (!e.hasModel())
      return { edits: c, snippets: h };
    const u = e.getModel(), p = e.invokeWithinContext((y) => y.get(Zs)), f = e.invokeWithinContext((y) => new nm(y.get(fr), u)), m = () => a, _ = u.getValueInRange(Tt.adjustSelection(u, e.getSelection(), i, 0)), v = u.getValueInRange(Tt.adjustSelection(u, e.getSelection(), 0, n)), C = u.getLineFirstNonWhitespaceColumn(e.getSelection().positionLineNumber), w = e.getSelections().map((y, I) => ({ selection: y, idx: I })).sort((y, I) => S.compareRangesUsingStarts(y.selection, I.selection));
    for (const { selection: y, idx: I } of w) {
      let k = Tt.adjustSelection(u, y, i, 0), N = Tt.adjustSelection(u, y, 0, n);
      _ !== u.getValueInRange(k) && (k = y), v !== u.getValueInRange(N) && (N = y);
      const J = y.setStartPosition(k.startLineNumber, k.startColumn).setEndPosition(N.endLineNumber, N.endColumn), te = new Un().parse(t, !0, s), ve = J.getStartPosition(), be = Tt.adjustWhitespace(u, ve, o || I > 0 && C !== u.getLineFirstNonWhitespaceColumn(y.positionLineNumber), te);
      te.resolveVariables(new tm([
        f,
        new sm(m, I, w.length, e.getOption(
          79
          /* EditorOption.multiCursorPaste */
        ) === "spread"),
        new im(u, y, I, l),
        new $l(u, y, d),
        new $t(),
        new om(p),
        new rm()
      ])), c[I] = ue.replace(J, te.toString()), c[I].identifier = { major: I, minor: 0 }, c[I]._isTracked = !0, h[I] = new Ct(e, te, be);
    }
    return { edits: c, snippets: h };
  }
  static createEditsAndSnippetsFromEdits(e, t, i, n, s, o, a) {
    if (!e.hasModel() || t.length === 0)
      return { edits: [], snippets: [] };
    const l = [], d = e.getModel(), c = new Un(), h = new la(), u = new tm([
      e.invokeWithinContext((f) => new nm(f.get(fr), d)),
      new sm(() => s, 0, e.getSelections().length, e.getOption(
        79
        /* EditorOption.multiCursorPaste */
      ) === "spread"),
      new im(d, e.getSelection(), 0, o),
      new $l(d, e.getSelection(), a),
      new $t(),
      new om(e.invokeWithinContext((f) => f.get(Zs))),
      new rm()
    ]);
    t = t.sort((f, m) => S.compareRangesUsingStarts(f.range, m.range));
    let p = 0;
    for (let f = 0; f < t.length; f++) {
      const { range: m, template: _ } = t[f];
      if (f > 0) {
        const I = t[f - 1].range, k = S.fromPositions(I.getEndPosition(), m.getStartPosition()), N = new ze(d.getValueInRange(k));
        h.appendChild(N), p += N.value.length;
      }
      const v = c.parseFragment(_, h);
      Tt.adjustWhitespace(d, m.getStartPosition(), !0, h, new Set(v)), h.resolveVariables(u);
      const C = h.toString(), w = C.slice(p);
      p = C.length;
      const y = ue.replace(m, w);
      y.identifier = { major: f, minor: 0 }, y._isTracked = !0, l.push(y);
    }
    return c.ensureFinalTabstop(h, i, !0), {
      edits: l,
      snippets: [new Ct(e, h, "")]
    };
  }
  constructor(e, t, i = am, n) {
    this._editor = e, this._template = t, this._options = i, this._languageConfigurationService = n, this._templateMerges = [], this._snippets = [];
  }
  dispose() {
    $e(this._snippets);
  }
  _logInfo() {
    return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
  }
  insert() {
    if (!this._editor.hasModel())
      return;
    const { edits: e, snippets: t } = typeof this._template == "string" ? Tt.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, !1, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : Tt.createEditsAndSnippetsFromEdits(this._editor, this._template, !1, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);
    this._snippets = t, this._editor.executeEdits("snippet", e, (i) => {
      const n = i.filter((s) => !!s.identifier);
      for (let s = 0; s < t.length; s++)
        t[s].initialize(n[s].textChange);
      return this._snippets[0].hasPlaceholder ? this._move(!0) : n.map((s) => z.fromPositions(s.range.getEndPosition()));
    }), this._editor.revealRange(this._editor.getSelections()[0]);
  }
  merge(e, t = am) {
    if (!this._editor.hasModel())
      return;
    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, e]);
    const { edits: i, snippets: n } = Tt.createEditsAndSnippetsFromSelections(this._editor, e, t.overwriteBefore, t.overwriteAfter, !0, t.adjustWhitespace, t.clipboardText, t.overtypingCapturer, this._languageConfigurationService);
    this._editor.executeEdits("snippet", i, (s) => {
      const o = s.filter((l) => !!l.identifier);
      for (let l = 0; l < n.length; l++)
        n[l].initialize(o[l].textChange);
      const a = n[0].isTrivialSnippet;
      if (!a) {
        for (const l of this._snippets)
          l.merge(n);
        console.assert(n.length === 0);
      }
      return this._snippets[0].hasPlaceholder && !a ? this._move(void 0) : o.map((l) => z.fromPositions(l.range.getEndPosition()));
    });
  }
  next() {
    const e = this._move(!0);
    this._editor.setSelections(e), this._editor.revealPositionInCenterIfOutsideViewport(e[0].getPosition());
  }
  prev() {
    const e = this._move(!1);
    this._editor.setSelections(e), this._editor.revealPositionInCenterIfOutsideViewport(e[0].getPosition());
  }
  _move(e) {
    const t = [];
    for (const i of this._snippets) {
      const n = i.move(e);
      t.push(...n);
    }
    return t;
  }
  get isAtFirstPlaceholder() {
    return this._snippets[0].isAtFirstPlaceholder;
  }
  get isAtLastPlaceholder() {
    return this._snippets[0].isAtLastPlaceholder;
  }
  get hasPlaceholder() {
    return this._snippets[0].hasPlaceholder;
  }
  get hasChoice() {
    return this._snippets[0].hasChoice;
  }
  get activeChoice() {
    return this._snippets[0].activeChoice;
  }
  isSelectionWithinPlaceholders() {
    if (!this.hasPlaceholder)
      return !1;
    const e = this._editor.getSelections();
    if (e.length < this._snippets.length)
      return !1;
    const t = /* @__PURE__ */ new Map();
    for (const i of this._snippets) {
      const n = i.computePossibleSelections();
      if (t.size === 0)
        for (const [s, o] of n) {
          o.sort(S.compareRangesUsingStarts);
          for (const a of e)
            if (o[0].containsRange(a)) {
              t.set(s, []);
              break;
            }
        }
      if (t.size === 0)
        return !1;
      t.forEach((s, o) => {
        s.push(...n.get(o));
      });
    }
    e.sort(S.compareRangesUsingStarts);
    for (const [i, n] of t) {
      if (n.length !== e.length) {
        t.delete(i);
        continue;
      }
      n.sort(S.compareRangesUsingStarts);
      for (let s = 0; s < n.length; s++)
        if (!n[s].containsRange(e[s])) {
          t.delete(i);
          continue;
        }
    }
    return t.size > 0;
  }
};
jl = Tt = Jk([
  eN(3, fe)
], jl);
var tN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ga = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, ys;
const lm = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  undoStopBefore: !0,
  undoStopAfter: !0,
  adjustWhitespace: !0,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
let Me = ys = class {
  static get(e) {
    return e.getContribution(ys.ID);
  }
  constructor(e, t, i, n, s) {
    this._editor = e, this._logService = t, this._languageFeaturesService = i, this._languageConfigurationService = s, this._snippetListener = new M(), this._modelVersionId = -1, this._inSnippet = ys.InSnippetMode.bindTo(n), this._hasNextTabstop = ys.HasNextTabstop.bindTo(n), this._hasPrevTabstop = ys.HasPrevTabstop.bindTo(n);
  }
  dispose() {
    var e;
    this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), (e = this._session) === null || e === void 0 || e.dispose(), this._snippetListener.dispose();
  }
  insert(e, t) {
    try {
      this._doInsert(e, typeof t > "u" ? lm : { ...lm, ...t });
    } catch (i) {
      this.cancel(), this._logService.error(i), this._logService.error("snippet_error"), this._logService.error("insert_template=", e), this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
    }
  }
  _doInsert(e, t) {
    var i;
    if (this._editor.hasModel()) {
      if (this._snippetListener.clear(), t.undoStopBefore && this._editor.getModel().pushStackElement(), this._session && typeof e != "string" && this.cancel(), this._session ? (ie(typeof e == "string"), this._session.merge(e, t)) : (this._modelVersionId = this._editor.getModel().getAlternativeVersionId(), this._session = new jl(this._editor, e, t, this._languageConfigurationService), this._session.insert()), t.undoStopAfter && this._editor.getModel().pushStackElement(), !((i = this._session) === null || i === void 0) && i.hasChoice) {
        const n = {
          _debugDisplayName: "snippetChoiceCompletions",
          provideCompletionItems: (c, h) => {
            if (!this._session || c !== this._editor.getModel() || !F.equals(this._editor.getPosition(), h))
              return;
            const { activeChoice: u } = this._session;
            if (!u || u.choice.options.length === 0)
              return;
            const p = c.getValueInRange(u.range), f = !!u.choice.options.find((_) => _.value === p), m = [];
            for (let _ = 0; _ < u.choice.options.length; _++) {
              const v = u.choice.options[_];
              m.push({
                kind: 13,
                label: v.value,
                insertText: v.value,
                sortText: "a".repeat(_ + 1),
                range: u.range,
                filterText: f ? `${p}_${v.value}` : void 0,
                command: { id: "jumpToNextSnippetPlaceholder", title: g("next", "Go to next placeholder...") }
              });
            }
            return { suggestions: m };
          }
        }, s = this._editor.getModel();
        let o, a = !1;
        const l = () => {
          o == null || o.dispose(), a = !1;
        }, d = () => {
          a || (o = this._languageFeaturesService.completionProvider.register({
            language: s.getLanguageId(),
            pattern: s.uri.fsPath,
            scheme: s.uri.scheme,
            exclusive: !0
          }, n), this._snippetListener.add(o), a = !0);
        };
        this._choiceCompletions = { provider: n, enable: d, disable: l };
      }
      this._updateState(), this._snippetListener.add(this._editor.onDidChangeModelContent((n) => n.isFlush && this.cancel())), this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel())), this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
    }
  }
  _updateState() {
    if (!(!this._session || !this._editor.hasModel())) {
      if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId())
        return this.cancel();
      if (!this._session.hasPlaceholder)
        return this.cancel();
      if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders())
        return this._editor.getModel().pushStackElement(), this.cancel();
      this._inSnippet.set(!0), this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder), this._hasNextTabstop.set(!this._session.isAtLastPlaceholder), this._handleChoice();
    }
  }
  _handleChoice() {
    var e;
    if (!this._session || !this._editor.hasModel()) {
      this._currentChoice = void 0;
      return;
    }
    const { activeChoice: t } = this._session;
    if (!t || !this._choiceCompletions) {
      (e = this._choiceCompletions) === null || e === void 0 || e.disable(), this._currentChoice = void 0;
      return;
    }
    this._currentChoice !== t.choice && (this._currentChoice = t.choice, this._choiceCompletions.enable(), queueMicrotask(() => {
      Xk(this._editor, this._choiceCompletions.provider);
    }));
  }
  finish() {
    for (; this._inSnippet.get(); )
      this.next();
  }
  cancel(e = !1) {
    var t;
    this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), this._snippetListener.clear(), this._currentChoice = void 0, (t = this._session) === null || t === void 0 || t.dispose(), this._session = void 0, this._modelVersionId = -1, e && this._editor.setSelections([this._editor.getSelection()]);
  }
  prev() {
    var e;
    (e = this._session) === null || e === void 0 || e.prev(), this._updateState();
  }
  next() {
    var e;
    (e = this._session) === null || e === void 0 || e.next(), this._updateState();
  }
  isInSnippet() {
    return !!this._inSnippet.get();
  }
};
Me.ID = "snippetController2";
Me.InSnippetMode = new Q("inSnippetMode", !1, g("inSnippetMode", "Whether the editor in current in snippet mode"));
Me.HasNextTabstop = new Q("hasNextTabstop", !1, g("hasNextTabstop", "Whether there is a next tab stop when in snippet mode"));
Me.HasPrevTabstop = new Q("hasPrevTabstop", !1, g("hasPrevTabstop", "Whether there is a previous tab stop when in snippet mode"));
Me = ys = tN([
  Ga(1, fo),
  Ga(2, V),
  Ga(3, ee),
  Ga(4, fe)
], Me);
Z(
  Me.ID,
  Me,
  4
  /* EditorContributionInstantiation.Lazy */
);
const zd = bt.bindToContribution(Me.get);
B(new zd({
  id: "jumpToNextSnippetPlaceholder",
  precondition: L.and(Me.InSnippetMode, Me.HasNextTabstop),
  handler: (r) => r.next(),
  kbOpts: {
    weight: 130,
    kbExpr: b.editorTextFocus,
    primary: 2
    /* KeyCode.Tab */
  }
}));
B(new zd({
  id: "jumpToPrevSnippetPlaceholder",
  precondition: L.and(Me.InSnippetMode, Me.HasPrevTabstop),
  handler: (r) => r.prev(),
  kbOpts: {
    weight: 130,
    kbExpr: b.editorTextFocus,
    primary: 1026
    /* KeyCode.Tab */
  }
}));
B(new zd({
  id: "leaveSnippet",
  precondition: Me.InSnippetMode,
  handler: (r) => r.cancel(!0),
  kbOpts: {
    weight: 130,
    kbExpr: b.editorTextFocus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
B(new zd({
  id: "acceptSnippet",
  precondition: Me.InSnippetMode,
  handler: (r) => r.finish()
  // kbOpts: {
  // 	weight: KeybindingWeight.EditorContrib + 30,
  // 	kbExpr: EditorContextKeys.textFocus,
  // 	primary: KeyCode.Enter,
  // }
}));
var iN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Hc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, dt;
(function(r) {
  r[r.Undo = 0] = "Undo", r[r.Redo = 1] = "Redo", r[r.AcceptWord = 2] = "AcceptWord", r[r.Other = 3] = "Other";
})(dt || (dt = {}));
let tu = class extends P {
  get isAcceptingPartially() {
    return this._isAcceptingPartially;
  }
  constructor(e, t, i, n, s, o, a, l, d, c, h, u) {
    super(), this.textModel = e, this.selectedSuggestItem = t, this.textModelVersionId = i, this._positions = n, this._debounceValue = s, this._suggestPreviewEnabled = o, this._suggestPreviewMode = a, this._inlineSuggestMode = l, this._enabled = d, this._instantiationService = c, this._commandService = h, this._languageConfigurationService = u, this._source = this._register(this._instantiationService.createInstance(eu, this.textModel, this.textModelVersionId, this._debounceValue)), this._isActive = ai(this, !1), this._forceUpdateSignal = k_("forceUpdate"), this._selectedInlineCompletionId = ai(this, void 0), this._primaryPosition = Xe(this, (f) => {
      var m;
      return (m = this._positions.read(f)[0]) !== null && m !== void 0 ? m : new F(1, 1);
    }), this._isAcceptingPartially = !1, this._preserveCurrentCompletionReasons = /* @__PURE__ */ new Set([
      dt.Redo,
      dt.Undo,
      dt.AcceptWord
    ]), this._fetchInlineCompletions = Nw({
      owner: this,
      createEmptyChangeSummary: () => ({
        preserveCurrentCompletion: !1,
        inlineCompletionTriggerKind: Tn.Automatic
      }),
      handleChange: (f, m) => (f.didChange(this.textModelVersionId) && this._preserveCurrentCompletionReasons.has(f.change) ? m.preserveCurrentCompletion = !0 : f.didChange(this._forceUpdateSignal) && (m.inlineCompletionTriggerKind = f.change), !0)
    }, (f, m) => {
      if (this._forceUpdateSignal.read(f), !(this._enabled.read(f) && this.selectedSuggestItem.read(f) || this._isActive.read(f))) {
        this._source.cancelUpdate();
        return;
      }
      this.textModelVersionId.read(f);
      const v = this.selectedInlineCompletion.get(), C = m.preserveCurrentCompletion || v != null && v.forwardStable ? v : void 0, w = this._source.suggestWidgetInlineCompletions.get(), y = this.selectedSuggestItem.read(f);
      if (w && !y) {
        const N = this._source.inlineCompletions.get();
        ht((J) => {
          (!N || w.request.versionId > N.request.versionId) && this._source.inlineCompletions.set(w.clone(), J), this._source.clearSuggestWidgetInlineCompletions(J);
        });
      }
      const I = this._primaryPosition.read(f), k = {
        triggerKind: m.inlineCompletionTriggerKind,
        selectedSuggestionInfo: y == null ? void 0 : y.toSelectedSuggestionInfo()
      };
      return this._source.fetch(I, k, C);
    }), this._filteredInlineCompletionItems = Xe(this, (f) => {
      const m = this._source.inlineCompletions.read(f);
      if (!m)
        return [];
      const _ = this._primaryPosition.read(f);
      return m.inlineCompletions.filter((C) => C.isVisible(this.textModel, _, f));
    }), this.selectedInlineCompletionIndex = Xe(this, (f) => {
      const m = this._selectedInlineCompletionId.read(f), _ = this._filteredInlineCompletionItems.read(f), v = this._selectedInlineCompletionId === void 0 ? -1 : _.findIndex((C) => C.semanticId === m);
      return v === -1 ? (this._selectedInlineCompletionId.set(void 0, void 0), 0) : v;
    }), this.selectedInlineCompletion = Xe(this, (f) => {
      const m = this._filteredInlineCompletionItems.read(f), _ = this.selectedInlineCompletionIndex.read(f);
      return m[_];
    }), this.lastTriggerKind = this._source.inlineCompletions.map(this, (f) => f == null ? void 0 : f.request.context.triggerKind), this.inlineCompletionsCount = Xe(this, (f) => {
      if (this.lastTriggerKind.read(f) === Tn.Explicit)
        return this._filteredInlineCompletionItems.read(f).length;
    }), this.state = _c({
      owner: this,
      equalityComparer: (f, m) => !f || !m ? f === m : jf(f.ghostTexts, m.ghostTexts) && f.inlineCompletion === m.inlineCompletion && f.suggestItem === m.suggestItem
    }, (f) => {
      var m, _;
      const v = this.textModel, C = this.selectedSuggestItem.read(f);
      if (C) {
        const w = C.toSingleTextEdit().removeCommonPrefix(v), y = this._computeAugmentation(w, f);
        if (!this._suggestPreviewEnabled.read(f) && !y)
          return;
        const k = (m = y == null ? void 0 : y.edit) !== null && m !== void 0 ? m : w, N = y ? y.edit.text.length - w.text.length : 0, J = this._suggestPreviewMode.read(f), te = this._positions.read(f), ve = [k, ...Bc(this.textModel, te, k)], be = ve.map((cs, ko) => cs.computeGhostText(v, J, te[ko], N)).filter(rl), et = (_ = be[0]) !== null && _ !== void 0 ? _ : new Pr(k.range.endLineNumber, []);
        return { edits: ve, primaryGhostText: et, ghostTexts: be, inlineCompletion: y == null ? void 0 : y.completion, suggestItem: C };
      } else {
        if (!this._isActive.read(f))
          return;
        const w = this.selectedInlineCompletion.read(f);
        if (!w)
          return;
        const y = w.toSingleTextEdit(f), I = this._inlineSuggestMode.read(f), k = this._positions.read(f), N = [y, ...Bc(this.textModel, k, y)], J = N.map((te, ve) => te.computeGhostText(v, I, k[ve], 0)).filter(rl);
        return J[0] ? { edits: N, primaryGhostText: J[0], ghostTexts: J, inlineCompletion: w, suggestItem: void 0 } : void 0;
      }
    }), this.ghostTexts = _c({
      owner: this,
      equalityComparer: jf
    }, (f) => {
      const m = this.state.read(f);
      if (m)
        return m.ghostTexts;
    }), this.primaryGhostText = _c({
      owner: this,
      equalityComparer: Xb
    }, (f) => {
      const m = this.state.read(f);
      if (m)
        return m == null ? void 0 : m.primaryGhostText;
    }), this._register(Rw(this._fetchInlineCompletions));
    let p;
    this._register(Ne((f) => {
      var m, _;
      const v = this.state.read(f), C = v == null ? void 0 : v.inlineCompletion;
      if ((C == null ? void 0 : C.semanticId) !== (p == null ? void 0 : p.semanticId) && (p = C, C)) {
        const w = C.inlineCompletion, y = w.source;
        (_ = (m = y.provider).handleItemDidShow) === null || _ === void 0 || _.call(m, y.inlineCompletions, w.sourceInlineCompletion, w.insertText);
      }
    }));
  }
  async trigger(e) {
    this._isActive.set(!0, e), await this._fetchInlineCompletions.get();
  }
  async triggerExplicitly(e) {
    Hp(e, (t) => {
      this._isActive.set(!0, t), this._forceUpdateSignal.trigger(t, Tn.Explicit);
    }), await this._fetchInlineCompletions.get();
  }
  stop(e) {
    Hp(e, (t) => {
      this._isActive.set(!1, t), this._source.clear(t);
    });
  }
  _computeAugmentation(e, t) {
    const i = this.textModel, n = this._source.suggestWidgetInlineCompletions.read(t), s = n ? n.inlineCompletions : [this.selectedInlineCompletion.read(t)].filter(rl);
    return Pw(s, (a) => {
      let l = a.toSingleTextEdit(t);
      return l = l.removeCommonPrefix(i, S.fromPositions(l.range.getStartPosition(), e.range.getEndPosition())), l.augments(e) ? { completion: a, edit: l } : void 0;
    });
  }
  async _deltaSelectedInlineCompletionIndex(e) {
    await this.triggerExplicitly();
    const t = this._filteredInlineCompletionItems.get() || [];
    if (t.length > 0) {
      const i = (this.selectedInlineCompletionIndex.get() + e + t.length) % t.length;
      this._selectedInlineCompletionId.set(t[i].semanticId, void 0);
    } else
      this._selectedInlineCompletionId.set(void 0, void 0);
  }
  async next() {
    await this._deltaSelectedInlineCompletionIndex(1);
  }
  async previous() {
    await this._deltaSelectedInlineCompletionIndex(-1);
  }
  async accept(e) {
    var t;
    if (e.getModel() !== this.textModel)
      throw new xl();
    const i = this.state.get();
    if (!i || i.primaryGhostText.isEmpty() || !i.inlineCompletion)
      return;
    const n = i.inlineCompletion.toInlineCompletion(void 0);
    if (e.pushUndoStop(), n.snippetInfo)
      e.executeEdits("inlineSuggestion.accept", [
        ue.replaceMove(n.range, ""),
        ...n.additionalTextEdits
      ]), e.setPosition(n.snippetInfo.range.getStartPosition(), "inlineCompletionAccept"), (t = Me.get(e)) === null || t === void 0 || t.insert(n.snippetInfo.snippet, { undoStopBefore: !1 });
    else {
      const s = i.edits, o = dm(s).map((a) => z.fromPositions(a));
      e.executeEdits("inlineSuggestion.accept", [
        ...s.map((a) => ue.replaceMove(a.range, a.text)),
        ...n.additionalTextEdits
      ]), e.setSelections(o, "inlineCompletionAccept");
    }
    n.command && n.source.addRef(), ht((s) => {
      this._source.clear(s), this._isActive.set(!1, s);
    }), n.command && (await this._commandService.executeCommand(n.command.id, ...n.command.arguments || []).then(void 0, Ie), n.source.removeRef());
  }
  async acceptNextWord(e) {
    await this._acceptNext(e, (t, i) => {
      const n = this.textModel.getLanguageIdAtPosition(t.lineNumber, t.column), s = this._languageConfigurationService.getLanguageConfiguration(n), o = new RegExp(s.wordDefinition.source, s.wordDefinition.flags.replace("g", "")), a = i.match(o);
      let l = 0;
      a && a.index !== void 0 ? a.index === 0 ? l = a[0].length : l = a.index : l = i.length;
      const c = /\s+/g.exec(i);
      return c && c.index !== void 0 && c.index + c[0].length < l && (l = c.index + c[0].length), l;
    });
  }
  async acceptNextLine(e) {
    await this._acceptNext(e, (t, i) => {
      const n = i.match(/\n/);
      return n && n.index !== void 0 ? n.index + 1 : i.length;
    });
  }
  async _acceptNext(e, t) {
    if (e.getModel() !== this.textModel)
      throw new xl();
    const i = this.state.get();
    if (!i || i.primaryGhostText.isEmpty() || !i.inlineCompletion)
      return;
    const n = i.primaryGhostText, s = i.inlineCompletion.toInlineCompletion(void 0);
    if (s.snippetInfo || s.filterText !== s.insertText) {
      await this.accept(e);
      return;
    }
    const o = n.parts[0], a = new F(n.lineNumber, o.column), l = o.text, d = t(a, l);
    if (d === l.length && n.parts.length === 1) {
      this.accept(e);
      return;
    }
    const c = l.substring(0, d), h = this._positions.get(), u = h[0];
    s.source.addRef();
    try {
      this._isAcceptingPartially = !0;
      try {
        e.pushUndoStop();
        const p = S.fromPositions(u, a), f = e.getModel().getValueInRange(p) + c, m = new gn(p, f), _ = [m, ...Bc(this.textModel, h, m)], v = dm(_).map((C) => z.fromPositions(C));
        e.executeEdits("inlineSuggestion.accept", _.map((C) => ue.replaceMove(C.range, C.text))), e.setSelections(v, "inlineCompletionPartialAccept");
      } finally {
        this._isAcceptingPartially = !1;
      }
      if (s.source.provider.handlePartialAccept) {
        const p = S.fromPositions(s.range.getStartPosition(), Vd(a, Jg(c))), f = e.getModel().getValueInRange(
          p,
          1
          /* EndOfLinePreference.LF */
        );
        s.source.provider.handlePartialAccept(s.source.inlineCompletions, s.sourceInlineCompletion, f.length);
      }
    } finally {
      s.source.removeRef();
    }
  }
  handleSuggestAccepted(e) {
    var t, i;
    const n = e.toSingleTextEdit().removeCommonPrefix(this.textModel), s = this._computeAugmentation(n, void 0);
    if (!s)
      return;
    const o = s.completion.inlineCompletion;
    (i = (t = o.source.provider).handlePartialAccept) === null || i === void 0 || i.call(t, o.source.inlineCompletions, o.sourceInlineCompletion, n.text.length);
  }
};
tu = iN([
  Hc(9, q),
  Hc(10, Fe),
  Hc(11, fe)
], tu);
function Bc(r, e, t) {
  if (e.length === 1)
    return [];
  const i = e[0], n = e.slice(1), s = t.range.getStartPosition(), o = t.range.getEndPosition(), a = r.getValueInRange(S.fromPositions(i, o)), l = $f(i, s);
  if (l.lineNumber < 1)
    return re(new xl(`positionWithinTextEdit line number should be bigger than 0.
			Invalid subtraction between ${i.toString()} and ${s.toString()}`)), [];
  const d = nN(t.text, l);
  return n.map((c) => {
    const h = Vd($f(c, s), o), u = r.getValueInRange(S.fromPositions(c, h)), p = ta(a, u), f = S.fromPositions(c, c.delta(0, p));
    return new gn(f, d);
  });
}
function nN(r, e) {
  let t = "";
  const i = Mw(r);
  for (let n = e.lineNumber - 1; n < i.length; n++)
    t += i[n].substring(n === e.lineNumber - 1 ? e.column - 1 : 0);
  return t;
}
function dm(r) {
  const e = Vl.createSortPermutation(r, (n, s) => S.compareRangesUsingStarts(n.range, s.range)), t = Lk(e.apply(r));
  return e.inverse().apply(t).map((n) => n.getEndPosition());
}
var sN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, cm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Go;
class ip {
  constructor(e) {
    this.name = e;
  }
  select(e, t, i) {
    if (i.length === 0)
      return 0;
    const n = i[0].score[0];
    for (let s = 0; s < i.length; s++) {
      const { score: o, completion: a } = i[s];
      if (o[0] !== n)
        break;
      if (a.preselect)
        return s;
    }
    return 0;
  }
}
class Yb extends ip {
  constructor() {
    super("first");
  }
  memorize(e, t, i) {
  }
  toJSON() {
  }
  fromJSON() {
  }
}
class oN extends ip {
  constructor() {
    super("recentlyUsed"), this._cache = new Yr(300, 0.66), this._seq = 0;
  }
  memorize(e, t, i) {
    const n = `${e.getLanguageId()}/${i.textLabel}`;
    this._cache.set(n, {
      touch: this._seq++,
      type: i.completion.kind,
      insertText: i.completion.insertText
    });
  }
  select(e, t, i) {
    if (i.length === 0)
      return 0;
    const n = e.getLineContent(t.lineNumber).substr(t.column - 10, t.column - 1);
    if (/\s$/.test(n))
      return super.select(e, t, i);
    const s = i[0].score[0];
    let o = -1, a = -1, l = -1;
    for (let d = 0; d < i.length && i[d].score[0] === s; d++) {
      const c = `${e.getLanguageId()}/${i[d].textLabel}`, h = this._cache.peek(c);
      if (h && h.touch > l && h.type === i[d].completion.kind && h.insertText === i[d].completion.insertText && (l = h.touch, a = d), i[d].completion.preselect && o === -1)
        return o = d;
    }
    return a !== -1 ? a : o !== -1 ? o : 0;
  }
  toJSON() {
    return this._cache.toJSON();
  }
  fromJSON(e) {
    this._cache.clear();
    const t = 0;
    for (const [i, n] of e)
      n.touch = t, n.type = typeof n.type == "number" ? n.type : _g.fromString(n.type), this._cache.set(i, n);
    this._seq = this._cache.size;
  }
}
class rN extends ip {
  constructor() {
    super("recentlyUsedByPrefix"), this._trie = Ew.forStrings(), this._seq = 0;
  }
  memorize(e, t, i) {
    const { word: n } = e.getWordUntilPosition(t), s = `${e.getLanguageId()}/${n}`;
    this._trie.set(s, {
      type: i.completion.kind,
      insertText: i.completion.insertText,
      touch: this._seq++
    });
  }
  select(e, t, i) {
    const { word: n } = e.getWordUntilPosition(t);
    if (!n)
      return super.select(e, t, i);
    const s = `${e.getLanguageId()}/${n}`;
    let o = this._trie.get(s);
    if (o || (o = this._trie.findSubstr(s)), o)
      for (let a = 0; a < i.length; a++) {
        const { kind: l, insertText: d } = i[a].completion;
        if (l === o.type && d === o.insertText)
          return a;
      }
    return super.select(e, t, i);
  }
  toJSON() {
    const e = [];
    return this._trie.forEach((t, i) => e.push([i, t])), e.sort((t, i) => -(t[1].touch - i[1].touch)).forEach((t, i) => t[1].touch = i), e.slice(0, 200);
  }
  fromJSON(e) {
    if (this._trie.clear(), e.length > 0) {
      this._seq = e[0][1].touch + 1;
      for (const [t, i] of e)
        i.type = typeof i.type == "number" ? i.type : _g.fromString(i.type), this._trie.set(t, i);
    }
  }
}
let Er = Go = class {
  constructor(e, t) {
    this._storageService = e, this._configService = t, this._disposables = new M(), this._persistSoon = new Re(() => this._saveState(), 500), this._disposables.add(e.onWillSaveState((i) => {
      i.reason === sg.SHUTDOWN && this._saveState();
    }));
  }
  dispose() {
    this._disposables.dispose(), this._persistSoon.dispose();
  }
  memorize(e, t, i) {
    this._withStrategy(e, t).memorize(e, t, i), this._persistSoon.schedule();
  }
  select(e, t, i) {
    return this._withStrategy(e, t).select(e, t, i);
  }
  _withStrategy(e, t) {
    var i;
    const n = this._configService.getValue("editor.suggestSelection", {
      overrideIdentifier: e.getLanguageIdAtPosition(t.lineNumber, t.column),
      resource: e.uri
    });
    if (((i = this._strategy) === null || i === void 0 ? void 0 : i.name) !== n) {
      this._saveState();
      const s = Go._strategyCtors.get(n) || Yb;
      this._strategy = new s();
      try {
        const a = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1, l = this._storageService.get(`${Go._storagePrefix}/${n}`, a);
        l && this._strategy.fromJSON(JSON.parse(l));
      } catch {
      }
    }
    return this._strategy;
  }
  _saveState() {
    if (this._strategy) {
      const t = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1, i = JSON.stringify(this._strategy);
      this._storageService.store(
        `${Go._storagePrefix}/${this._strategy.name}`,
        i,
        t,
        1
        /* StorageTarget.MACHINE */
      );
    }
  }
};
Er._strategyCtors = /* @__PURE__ */ new Map([
  ["recentlyUsedByPrefix", rN],
  ["recentlyUsed", oN],
  ["first", Yb]
]);
Er._storagePrefix = "suggest/memories";
Er = Go = sN([
  cm(0, vn),
  cm(1, he)
], Er);
const $d = Ti("ISuggestMemories");
Ai(
  $d,
  Er,
  1
  /* InstantiationType.Delayed */
);
var aN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, lN = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, iu;
let Tr = iu = class {
  constructor(e, t) {
    this._editor = e, this._enabled = !1, this._ckAtEnd = iu.AtEnd.bindTo(t), this._configListener = this._editor.onDidChangeConfiguration((i) => i.hasChanged(
      123
      /* EditorOption.tabCompletion */
    ) && this._update()), this._update();
  }
  dispose() {
    var e;
    this._configListener.dispose(), (e = this._selectionListener) === null || e === void 0 || e.dispose(), this._ckAtEnd.reset();
  }
  _update() {
    const e = this._editor.getOption(
      123
      /* EditorOption.tabCompletion */
    ) === "on";
    if (this._enabled !== e)
      if (this._enabled = e, this._enabled) {
        const t = () => {
          if (!this._editor.hasModel()) {
            this._ckAtEnd.set(!1);
            return;
          }
          const i = this._editor.getModel(), n = this._editor.getSelection(), s = i.getWordAtPosition(n.getStartPosition());
          if (!s) {
            this._ckAtEnd.set(!1);
            return;
          }
          this._ckAtEnd.set(s.endColumn === n.getStartPosition().column);
        };
        this._selectionListener = this._editor.onDidChangeCursorSelection(t), t();
      } else
        this._selectionListener && (this._ckAtEnd.reset(), this._selectionListener.dispose(), this._selectionListener = void 0);
  }
};
Tr.AtEnd = new Q("atEndOfWord", !1);
Tr = iu = aN([
  lN(1, ee)
], Tr);
var dN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, cN = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Zo;
let Xn = Zo = class {
  constructor(e, t) {
    this._editor = e, this._index = 0, this._ckOtherSuggestions = Zo.OtherSuggestions.bindTo(t);
  }
  dispose() {
    this.reset();
  }
  reset() {
    var e;
    this._ckOtherSuggestions.reset(), (e = this._listener) === null || e === void 0 || e.dispose(), this._model = void 0, this._acceptNext = void 0, this._ignore = !1;
  }
  set({ model: e, index: t }, i) {
    if (e.items.length === 0) {
      this.reset();
      return;
    }
    if (Zo._moveIndex(!0, e, t) === t) {
      this.reset();
      return;
    }
    this._acceptNext = i, this._model = e, this._index = t, this._listener = this._editor.onDidChangeCursorPosition(() => {
      this._ignore || this.reset();
    }), this._ckOtherSuggestions.set(!0);
  }
  static _moveIndex(e, t, i) {
    let n = i;
    for (let s = t.items.length; s > 0 && (n = (n + t.items.length + (e ? 1 : -1)) % t.items.length, !(n === i || !t.items[n].completion.additionalTextEdits)); s--)
      ;
    return n;
  }
  next() {
    this._move(!0);
  }
  prev() {
    this._move(!1);
  }
  _move(e) {
    if (this._model)
      try {
        this._ignore = !0, this._index = Zo._moveIndex(e, this._model, this._index), this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });
      } finally {
        this._ignore = !1;
      }
  }
};
Xn.OtherSuggestions = new Q("hasOtherSuggestions", !1);
Xn = Zo = dN([
  cN(1, ee)
], Xn);
class hN {
  constructor(e, t, i, n) {
    this._disposables = new M(), this._disposables.add(i.onDidSuggest((s) => {
      s.completionModel.items.length === 0 && this.reset();
    })), this._disposables.add(i.onDidCancel((s) => {
      this.reset();
    })), this._disposables.add(t.onDidShow(() => this._onItem(t.getFocusedItem()))), this._disposables.add(t.onDidFocus(this._onItem, this)), this._disposables.add(t.onDidHide(this.reset, this)), this._disposables.add(e.onWillType((s) => {
      if (this._active && !t.isFrozen() && i.state !== 0) {
        const o = s.charCodeAt(s.length - 1);
        this._active.acceptCharacters.has(o) && e.getOption(
          0
          /* EditorOption.acceptSuggestionOnCommitCharacter */
        ) && n(this._active.item);
      }
    }));
  }
  _onItem(e) {
    if (!e || !nt(e.item.completion.commitCharacters)) {
      this.reset();
      return;
    }
    if (this._active && this._active.item.item === e.item)
      return;
    const t = new yl();
    for (const i of e.item.completion.commitCharacters)
      i.length > 0 && t.add(i.charCodeAt(0));
    this._active = { acceptCharacters: t, item: e };
  }
  reset() {
    this._active = void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
}
class ct {
  async provideSelectionRanges(e, t) {
    const i = [];
    for (const n of t) {
      const s = [];
      i.push(s);
      const o = /* @__PURE__ */ new Map();
      await new Promise((a) => ct._bracketsRightYield(a, 0, e, n, o)), await new Promise((a) => ct._bracketsLeftYield(a, 0, e, n, o, s));
    }
    return i;
  }
  static _bracketsRightYield(e, t, i, n, s) {
    const o = /* @__PURE__ */ new Map(), a = Date.now();
    for (; ; ) {
      if (t >= ct._maxRounds) {
        e();
        break;
      }
      if (!n) {
        e();
        break;
      }
      const l = i.bracketPairs.findNextBracket(n);
      if (!l) {
        e();
        break;
      }
      if (Date.now() - a > ct._maxDuration) {
        setTimeout(() => ct._bracketsRightYield(e, t + 1, i, n, s));
        break;
      }
      if (l.bracketInfo.isOpeningBracket) {
        const c = l.bracketInfo.bracketText, h = o.has(c) ? o.get(c) : 0;
        o.set(c, h + 1);
      } else {
        const c = l.bracketInfo.getOpeningBrackets()[0].bracketText;
        let h = o.has(c) ? o.get(c) : 0;
        if (h -= 1, o.set(c, Math.max(0, h)), h < 0) {
          let u = s.get(c);
          u || (u = new t_(), s.set(c, u)), u.push(l.range);
        }
      }
      n = l.range.getEndPosition();
    }
  }
  static _bracketsLeftYield(e, t, i, n, s, o) {
    const a = /* @__PURE__ */ new Map(), l = Date.now();
    for (; ; ) {
      if (t >= ct._maxRounds && s.size === 0) {
        e();
        break;
      }
      if (!n) {
        e();
        break;
      }
      const d = i.bracketPairs.findPrevBracket(n);
      if (!d) {
        e();
        break;
      }
      if (Date.now() - l > ct._maxDuration) {
        setTimeout(() => ct._bracketsLeftYield(e, t + 1, i, n, s, o));
        break;
      }
      if (d.bracketInfo.isOpeningBracket) {
        const h = d.bracketInfo.bracketText;
        let u = a.has(h) ? a.get(h) : 0;
        if (u -= 1, a.set(h, Math.max(0, u)), u < 0) {
          const p = s.get(h);
          if (p) {
            const f = p.shift();
            p.size === 0 && s.delete(h);
            const m = S.fromPositions(d.range.getEndPosition(), f.getStartPosition()), _ = S.fromPositions(d.range.getStartPosition(), f.getEndPosition());
            o.push({ range: m }), o.push({ range: _ }), ct._addBracketLeading(i, _, o);
          }
        }
      } else {
        const h = d.bracketInfo.getOpeningBrackets()[0].bracketText, u = a.has(h) ? a.get(h) : 0;
        a.set(h, u + 1);
      }
      n = d.range.getStartPosition();
    }
  }
  static _addBracketLeading(e, t, i) {
    if (t.startLineNumber === t.endLineNumber)
      return;
    const n = t.startLineNumber, s = e.getLineFirstNonWhitespaceColumn(n);
    s !== 0 && s !== t.startColumn && (i.push({ range: S.fromPositions(new F(n, s), t.getEndPosition()) }), i.push({ range: S.fromPositions(new F(n, 1), t.getEndPosition()) }));
    const o = n - 1;
    if (o > 0) {
      const a = e.getLineFirstNonWhitespaceColumn(o);
      a === t.startColumn && a !== e.getLineLastNonWhitespaceColumn(o) && (i.push({ range: S.fromPositions(new F(o, a), t.getEndPosition()) }), i.push({ range: S.fromPositions(new F(o, 1), t.getEndPosition()) }));
    }
  }
}
ct._maxDuration = 30;
ct._maxRounds = 2;
class Bt {
  static async create(e, t) {
    if (!t.getOption(
      118
      /* EditorOption.suggest */
    ).localityBonus || !t.hasModel())
      return Bt.None;
    const i = t.getModel(), n = t.getPosition();
    if (!e.canComputeWordRanges(i.uri))
      return Bt.None;
    const [s] = await new ct().provideSelectionRanges(i, [n]);
    if (s.length === 0)
      return Bt.None;
    const o = await e.computeWordRanges(i.uri, s[0].range);
    if (!o)
      return Bt.None;
    const a = i.getWordUntilPosition(n);
    return delete o[a.word], new class extends Bt {
      distance(l, d) {
        if (!n.equals(t.getPosition()))
          return 0;
        if (d.kind === 17)
          return 2 << 20;
        const c = typeof d.label == "string" ? d.label : d.label.label, h = o[c];
        if (Tw(h))
          return 2 << 20;
        const u = Sl(h, S.fromPositions(l), S.compareRangesUsingStarts), p = u >= 0 ? h[u] : h[Math.max(0, ~u - 1)];
        let f = s.length;
        for (const m of s) {
          if (!S.containsRange(m.range, p))
            break;
          f -= 1;
        }
        return f;
      }
    }();
  }
}
Bt.None = new class extends Bt {
  distance() {
    return 0;
  }
}();
let hm = class {
  constructor(e, t) {
    this.leadingLineContent = e, this.characterCountDelta = t;
  }
};
class zi {
  constructor(e, t, i, n, s, o, a = N_.default, l = void 0) {
    this.clipboardText = l, this._snippetCompareFn = zi._compareCompletionItems, this._items = e, this._column = t, this._wordDistance = n, this._options = s, this._refilterKind = 1, this._lineContext = i, this._fuzzyScoreOptions = a, o === "top" ? this._snippetCompareFn = zi._compareCompletionItemsSnippetsUp : o === "bottom" && (this._snippetCompareFn = zi._compareCompletionItemsSnippetsDown);
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(e) {
    (this._lineContext.leadingLineContent !== e.leadingLineContent || this._lineContext.characterCountDelta !== e.characterCountDelta) && (this._refilterKind = this._lineContext.characterCountDelta < e.characterCountDelta && this._filteredItems ? 2 : 1, this._lineContext = e);
  }
  get items() {
    return this._ensureCachedState(), this._filteredItems;
  }
  getItemsByProvider() {
    return this._ensureCachedState(), this._itemsByProvider;
  }
  getIncompleteProvider() {
    this._ensureCachedState();
    const e = /* @__PURE__ */ new Set();
    for (const [t, i] of this.getItemsByProvider())
      i.length > 0 && i[0].container.incomplete && e.add(t);
    return e;
  }
  get stats() {
    return this._ensureCachedState(), this._stats;
  }
  _ensureCachedState() {
    this._refilterKind !== 0 && this._createCachedState();
  }
  _createCachedState() {
    this._itemsByProvider = /* @__PURE__ */ new Map();
    const e = [], { leadingLineContent: t, characterCountDelta: i } = this._lineContext;
    let n = "", s = "";
    const o = this._refilterKind === 1 ? this._items : this._filteredItems, a = [], l = !this._options.filterGraceful || o.length > 2e3 ? R_ : Aw;
    for (let d = 0; d < o.length; d++) {
      const c = o[d];
      if (c.isInvalid)
        continue;
      const h = this._itemsByProvider.get(c.provider);
      h ? h.push(c) : this._itemsByProvider.set(c.provider, [c]);
      const u = c.position.column - c.editStart.column, p = u + i - (c.position.column - this._column);
      if (n.length !== p && (n = p === 0 ? "" : t.slice(-p), s = n.toLowerCase()), c.word = n, p === 0)
        c.score = mr.Default;
      else {
        let f = 0;
        for (; f < u; ) {
          const m = n.charCodeAt(f);
          if (m === 32 || m === 9)
            f += 1;
          else
            break;
        }
        if (f >= p)
          c.score = mr.Default;
        else if (typeof c.completion.filterText == "string") {
          const m = l(n, s, f, c.completion.filterText, c.filterTextLow, 0, this._fuzzyScoreOptions);
          if (!m)
            continue;
          Ow(c.completion.filterText, c.textLabel) === 0 ? c.score = m : (c.score = Fw(n, s, f, c.textLabel, c.labelLow, 0), c.score[0] = m[0]);
        } else {
          const m = l(n, s, f, c.textLabel, c.labelLow, 0, this._fuzzyScoreOptions);
          if (!m)
            continue;
          c.score = m;
        }
      }
      c.idx = d, c.distance = this._wordDistance.distance(c.position, c.completion), a.push(c), e.push(c.textLabel.length);
    }
    this._filteredItems = a.sort(this._snippetCompareFn), this._refilterKind = 0, this._stats = {
      pLabelLen: e.length ? Ww(e.length - 0.85, e, (d, c) => d - c) : 0
    };
  }
  static _compareCompletionItems(e, t) {
    return e.score[0] > t.score[0] ? -1 : e.score[0] < t.score[0] ? 1 : e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : e.idx < t.idx ? -1 : e.idx > t.idx ? 1 : 0;
  }
  static _compareCompletionItemsSnippetsDown(e, t) {
    if (e.completion.kind !== t.completion.kind) {
      if (e.completion.kind === 27)
        return 1;
      if (t.completion.kind === 27)
        return -1;
    }
    return zi._compareCompletionItems(e, t);
  }
  static _compareCompletionItemsSnippetsUp(e, t) {
    if (e.completion.kind !== t.completion.kind) {
      if (e.completion.kind === 27)
        return -1;
      if (t.completion.kind === 27)
        return 1;
    }
    return zi._compareCompletionItems(e, t);
  }
}
var uN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Fi = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, nu;
class Ln {
  static shouldAutoTrigger(e) {
    if (!e.hasModel())
      return !1;
    const t = e.getModel(), i = e.getPosition();
    t.tokenization.tokenizeIfCheap(i.lineNumber);
    const n = t.getWordAtPosition(i);
    return !(!n || n.endColumn !== i.column && n.startColumn + 1 !== i.column || !isNaN(Number(n.word)));
  }
  constructor(e, t, i) {
    this.leadingLineContent = e.getLineContent(t.lineNumber).substr(0, t.column - 1), this.leadingWord = e.getWordUntilPosition(t), this.lineNumber = t.lineNumber, this.column = t.column, this.triggerOptions = i;
  }
}
function gN(r, e, t) {
  if (!e.getContextKeyValue(ke.inlineSuggestionVisible.key))
    return !0;
  const i = e.getContextKeyValue(ke.suppressSuggestions.key);
  return i !== void 0 ? !i : !r.getOption(
    62
    /* EditorOption.inlineSuggest */
  ).suppressSuggestions;
}
function pN(r, e, t) {
  if (!e.getContextKeyValue("inlineSuggestionVisible"))
    return !0;
  const i = e.getContextKeyValue(ke.suppressSuggestions.key);
  return i !== void 0 ? !i : !r.getOption(
    62
    /* EditorOption.inlineSuggest */
  ).suppressSuggestions;
}
let ql = nu = class {
  constructor(e, t, i, n, s, o, a, l, d) {
    this._editor = e, this._editorWorkerService = t, this._clipboardService = i, this._telemetryService = n, this._logService = s, this._contextKeyService = o, this._configurationService = a, this._languageFeaturesService = l, this._envService = d, this._toDispose = new M(), this._triggerCharacterListener = new M(), this._triggerQuickSuggest = new Xr(), this._triggerState = void 0, this._completionDisposables = new M(), this._onDidCancel = new G(), this._onDidTrigger = new G(), this._onDidSuggest = new G(), this.onDidCancel = this._onDidCancel.event, this.onDidTrigger = this._onDidTrigger.event, this.onDidSuggest = this._onDidSuggest.event, this._telemetryGate = 0, this._currentSelection = this._editor.getSelection() || new z(1, 1, 1, 1), this._toDispose.add(this._editor.onDidChangeModel(() => {
      this._updateTriggerCharacters(), this.cancel();
    })), this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
      this._updateTriggerCharacters(), this.cancel();
    })), this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
      this._updateTriggerCharacters();
    })), this._toDispose.add(this._languageFeaturesService.completionProvider.onDidChange(() => {
      this._updateTriggerCharacters(), this._updateActiveSuggestSession();
    }));
    let c = !1;
    this._toDispose.add(this._editor.onDidCompositionStart(() => {
      c = !0;
    })), this._toDispose.add(this._editor.onDidCompositionEnd(() => {
      c = !1, this._onCompositionEnd();
    })), this._toDispose.add(this._editor.onDidChangeCursorSelection((h) => {
      c || this._onCursorChange(h);
    })), this._toDispose.add(this._editor.onDidChangeModelContent(() => {
      !c && this._triggerState !== void 0 && this._refilterCompletionItems();
    })), this._updateTriggerCharacters();
  }
  dispose() {
    $e(this._triggerCharacterListener), $e([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]), this._toDispose.dispose(), this._completionDisposables.dispose(), this.cancel();
  }
  _updateTriggerCharacters() {
    if (this._triggerCharacterListener.clear(), this._editor.getOption(
      91
      /* EditorOption.readOnly */
    ) || !this._editor.hasModel() || !this._editor.getOption(
      121
      /* EditorOption.suggestOnTriggerCharacters */
    ))
      return;
    const e = /* @__PURE__ */ new Map();
    for (const i of this._languageFeaturesService.completionProvider.all(this._editor.getModel()))
      for (const n of i.triggerCharacters || []) {
        let s = e.get(n);
        s || (s = /* @__PURE__ */ new Set(), s.add(jk()), e.set(n, s)), s.add(i);
      }
    const t = (i) => {
      var n;
      if (!pN(this._editor, this._contextKeyService, this._configurationService) || Ln.shouldAutoTrigger(this._editor))
        return;
      if (!i) {
        const a = this._editor.getPosition();
        i = this._editor.getModel().getLineContent(a.lineNumber).substr(0, a.column - 1);
      }
      let s = "";
      Bw(i.charCodeAt(i.length - 1)) ? Vw(i.charCodeAt(i.length - 2)) && (s = i.substr(i.length - 2)) : s = i.charAt(i.length - 1);
      const o = e.get(s);
      if (o) {
        const a = /* @__PURE__ */ new Map();
        if (this._completionModel)
          for (const [l, d] of this._completionModel.getItemsByProvider())
            o.has(l) || a.set(l, d);
        this.trigger({
          auto: !0,
          triggerKind: 1,
          triggerCharacter: s,
          retrigger: !!this._completionModel,
          clipboardText: (n = this._completionModel) === null || n === void 0 ? void 0 : n.clipboardText,
          completionOptions: { providerFilter: o, providerItemsToReuse: a }
        });
      }
    };
    this._triggerCharacterListener.add(this._editor.onDidType(t)), this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(() => t()));
  }
  // --- trigger/retrigger/cancel suggest
  get state() {
    return this._triggerState ? this._triggerState.auto ? 2 : 1 : 0;
  }
  cancel(e = !1) {
    var t;
    this._triggerState !== void 0 && (this._triggerQuickSuggest.cancel(), (t = this._requestToken) === null || t === void 0 || t.cancel(), this._requestToken = void 0, this._triggerState = void 0, this._completionModel = void 0, this._context = void 0, this._onDidCancel.fire({ retrigger: e }));
  }
  clear() {
    this._completionDisposables.clear();
  }
  _updateActiveSuggestSession() {
    this._triggerState !== void 0 && (!this._editor.hasModel() || !this._languageFeaturesService.completionProvider.has(this._editor.getModel()) ? this.cancel() : this.trigger({ auto: this._triggerState.auto, retrigger: !0 }));
  }
  _onCursorChange(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._currentSelection;
    if (this._currentSelection = this._editor.getSelection(), !e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
      this.cancel();
      return;
    }
    this._triggerState === void 0 && e.reason === 0 ? (t.containsRange(this._currentSelection) || t.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) && this._doTriggerQuickSuggest() : this._triggerState !== void 0 && e.reason === 3 && this._refilterCompletionItems();
  }
  _onCompositionEnd() {
    this._triggerState === void 0 ? this._doTriggerQuickSuggest() : this._refilterCompletionItems();
  }
  _doTriggerQuickSuggest() {
    var e;
    Es.isAllOff(this._editor.getOption(
      89
      /* EditorOption.quickSuggestions */
    )) || this._editor.getOption(
      118
      /* EditorOption.suggest */
    ).snippetsPreventQuickSuggestions && (!((e = Me.get(this._editor)) === null || e === void 0) && e.isInSnippet()) || (this.cancel(), this._triggerQuickSuggest.cancelAndSet(() => {
      if (this._triggerState !== void 0 || !Ln.shouldAutoTrigger(this._editor) || !this._editor.hasModel() || !this._editor.hasWidgetFocus())
        return;
      const t = this._editor.getModel(), i = this._editor.getPosition(), n = this._editor.getOption(
        89
        /* EditorOption.quickSuggestions */
      );
      if (!Es.isAllOff(n)) {
        if (!Es.isAllOn(n)) {
          t.tokenization.tokenizeIfCheap(i.lineNumber);
          const s = t.tokenization.getLineTokens(i.lineNumber), o = s.getStandardTokenType(s.findTokenIndexAtOffset(Math.max(i.column - 1 - 1, 0)));
          if (Es.valueFor(n, o) !== "on")
            return;
        }
        gN(this._editor, this._contextKeyService, this._configurationService) && this._languageFeaturesService.completionProvider.has(t) && this.trigger({ auto: !0 });
      }
    }, this._editor.getOption(
      90
      /* EditorOption.quickSuggestionsDelay */
    )));
  }
  _refilterCompletionItems() {
    ie(this._editor.hasModel()), ie(this._triggerState !== void 0);
    const e = this._editor.getModel(), t = this._editor.getPosition(), i = new Ln(e, t, { ...this._triggerState, refilter: !0 });
    this._onNewContext(i);
  }
  trigger(e) {
    var t, i, n, s, o, a;
    if (!this._editor.hasModel())
      return;
    const l = this._editor.getModel(), d = new Ln(l, this._editor.getPosition(), e);
    this.cancel(e.retrigger), this._triggerState = e, this._onDidTrigger.fire({ auto: e.auto, shy: (t = e.shy) !== null && t !== void 0 ? t : !1, position: this._editor.getPosition() }), this._context = d;
    let c = {
      triggerKind: (i = e.triggerKind) !== null && i !== void 0 ? i : 0
      /* CompletionTriggerKind.Invoke */
    };
    e.triggerCharacter && (c = {
      triggerKind: 1,
      triggerCharacter: e.triggerCharacter
    }), this._requestToken = new Oe();
    const h = this._editor.getOption(
      112
      /* EditorOption.snippetSuggestions */
    );
    let u = 1;
    switch (h) {
      case "top":
        u = 0;
        break;
      case "bottom":
        u = 2;
        break;
    }
    const { itemKind: p, showDeprecated: f } = nu.createSuggestFilter(this._editor), m = new Mr(u, (s = (n = e.completionOptions) === null || n === void 0 ? void 0 : n.kindFilter) !== null && s !== void 0 ? s : p, (o = e.completionOptions) === null || o === void 0 ? void 0 : o.providerFilter, (a = e.completionOptions) === null || a === void 0 ? void 0 : a.providerItemsToReuse, f), _ = Bt.create(this._editorWorkerService, this._editor), v = ep(this._languageFeaturesService.completionProvider, l, this._editor.getPosition(), m, c, this._requestToken.token);
    Promise.all([v, _]).then(async ([C, w]) => {
      var y;
      if ((y = this._requestToken) === null || y === void 0 || y.dispose(), !this._editor.hasModel())
        return;
      let I = e == null ? void 0 : e.clipboardText;
      if (!I && C.needsClipboard && (I = await this._clipboardService.readText()), this._triggerState === void 0)
        return;
      const k = this._editor.getModel(), N = new Ln(k, this._editor.getPosition(), e), J = {
        ...N_.default,
        firstMatchCanBeWeak: !this._editor.getOption(
          118
          /* EditorOption.suggest */
        ).matchOnWordStartOnly
      };
      if (this._completionModel = new zi(C.items, this._context.column, {
        leadingLineContent: N.leadingLineContent,
        characterCountDelta: N.column - this._context.column
      }, w, this._editor.getOption(
        118
        /* EditorOption.suggest */
      ), this._editor.getOption(
        112
        /* EditorOption.snippetSuggestions */
      ), J, I), this._completionDisposables.add(C.disposable), this._onNewContext(N), this._reportDurationsTelemetry(C.durations), !this._envService.isBuilt || this._envService.isExtensionDevelopment)
        for (const te of C.items)
          te.isInvalid && this._logService.warn(`[suggest] did IGNORE invalid completion item from ${te.provider._debugDisplayName}`, te.completion);
    }).catch(re);
  }
  _reportDurationsTelemetry(e) {
    this._telemetryGate++ % 230 === 0 && setTimeout(() => {
      this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(e) }), this._logService.debug("suggest.durations.json", e);
    });
  }
  static createSuggestFilter(e) {
    const t = /* @__PURE__ */ new Set();
    e.getOption(
      112
      /* EditorOption.snippetSuggestions */
    ) === "none" && t.add(
      27
      /* CompletionItemKind.Snippet */
    );
    const n = e.getOption(
      118
      /* EditorOption.suggest */
    );
    return n.showMethods || t.add(
      0
      /* CompletionItemKind.Method */
    ), n.showFunctions || t.add(
      1
      /* CompletionItemKind.Function */
    ), n.showConstructors || t.add(
      2
      /* CompletionItemKind.Constructor */
    ), n.showFields || t.add(
      3
      /* CompletionItemKind.Field */
    ), n.showVariables || t.add(
      4
      /* CompletionItemKind.Variable */
    ), n.showClasses || t.add(
      5
      /* CompletionItemKind.Class */
    ), n.showStructs || t.add(
      6
      /* CompletionItemKind.Struct */
    ), n.showInterfaces || t.add(
      7
      /* CompletionItemKind.Interface */
    ), n.showModules || t.add(
      8
      /* CompletionItemKind.Module */
    ), n.showProperties || t.add(
      9
      /* CompletionItemKind.Property */
    ), n.showEvents || t.add(
      10
      /* CompletionItemKind.Event */
    ), n.showOperators || t.add(
      11
      /* CompletionItemKind.Operator */
    ), n.showUnits || t.add(
      12
      /* CompletionItemKind.Unit */
    ), n.showValues || t.add(
      13
      /* CompletionItemKind.Value */
    ), n.showConstants || t.add(
      14
      /* CompletionItemKind.Constant */
    ), n.showEnums || t.add(
      15
      /* CompletionItemKind.Enum */
    ), n.showEnumMembers || t.add(
      16
      /* CompletionItemKind.EnumMember */
    ), n.showKeywords || t.add(
      17
      /* CompletionItemKind.Keyword */
    ), n.showWords || t.add(
      18
      /* CompletionItemKind.Text */
    ), n.showColors || t.add(
      19
      /* CompletionItemKind.Color */
    ), n.showFiles || t.add(
      20
      /* CompletionItemKind.File */
    ), n.showReferences || t.add(
      21
      /* CompletionItemKind.Reference */
    ), n.showColors || t.add(
      22
      /* CompletionItemKind.Customcolor */
    ), n.showFolders || t.add(
      23
      /* CompletionItemKind.Folder */
    ), n.showTypeParameters || t.add(
      24
      /* CompletionItemKind.TypeParameter */
    ), n.showSnippets || t.add(
      27
      /* CompletionItemKind.Snippet */
    ), n.showUsers || t.add(
      25
      /* CompletionItemKind.User */
    ), n.showIssues || t.add(
      26
      /* CompletionItemKind.Issue */
    ), { itemKind: t, showDeprecated: n.showDeprecated };
  }
  _onNewContext(e) {
    if (this._context) {
      if (e.lineNumber !== this._context.lineNumber) {
        this.cancel();
        return;
      }
      if (Ee(e.leadingLineContent) !== Ee(this._context.leadingLineContent)) {
        this.cancel();
        return;
      }
      if (e.column < this._context.column) {
        e.leadingWord.word ? this.trigger({ auto: this._context.triggerOptions.auto, retrigger: !0 }) : this.cancel();
        return;
      }
      if (this._completionModel) {
        if (e.leadingWord.word.length !== 0 && e.leadingWord.startColumn > this._context.leadingWord.startColumn) {
          if (Ln.shouldAutoTrigger(this._editor) && this._context) {
            const i = this._completionModel.getItemsByProvider();
            this.trigger({
              auto: this._context.triggerOptions.auto,
              retrigger: !0,
              clipboardText: this._completionModel.clipboardText,
              completionOptions: { providerItemsToReuse: i }
            });
          }
          return;
        }
        if (e.column > this._context.column && this._completionModel.getIncompleteProvider().size > 0 && e.leadingWord.word.length !== 0) {
          const t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
          for (const [n, s] of this._completionModel.getItemsByProvider())
            s.length > 0 && s[0].container.incomplete ? i.add(n) : t.set(n, s);
          this.trigger({
            auto: this._context.triggerOptions.auto,
            triggerKind: 2,
            retrigger: !0,
            clipboardText: this._completionModel.clipboardText,
            completionOptions: { providerFilter: i, providerItemsToReuse: t }
          });
        } else {
          const t = this._completionModel.lineContext;
          let i = !1;
          if (this._completionModel.lineContext = {
            leadingLineContent: e.leadingLineContent,
            characterCountDelta: e.column - this._context.column
          }, this._completionModel.items.length === 0) {
            const n = Ln.shouldAutoTrigger(this._editor);
            if (!this._context) {
              this.cancel();
              return;
            }
            if (n && this._context.leadingWord.endColumn < e.leadingWord.startColumn) {
              this.trigger({ auto: this._context.triggerOptions.auto, retrigger: !0 });
              return;
            }
            if (this._context.triggerOptions.auto) {
              this.cancel();
              return;
            } else if (this._completionModel.lineContext = t, i = this._completionModel.items.length > 0, i && e.leadingWord.word.length === 0) {
              this.cancel();
              return;
            }
          }
          this._onDidSuggest.fire({
            completionModel: this._completionModel,
            triggerOptions: e.triggerOptions,
            isFrozen: i
          });
        }
      }
    }
  }
};
ql = nu = uN([
  Fi(1, sa),
  Fi(2, ho),
  Fi(3, ui),
  Fi(4, fo),
  Fi(5, ee),
  Fi(6, he),
  Fi(7, V),
  Fi(8, Hw)
], ql);
class jd {
  constructor(e, t) {
    this._disposables = new M(), this._lastOvertyped = [], this._locked = !1, this._disposables.add(e.onWillType(() => {
      if (this._locked || !e.hasModel())
        return;
      const i = e.getSelections(), n = i.length;
      let s = !1;
      for (let a = 0; a < n; a++)
        if (!i[a].isEmpty()) {
          s = !0;
          break;
        }
      if (!s) {
        this._lastOvertyped.length !== 0 && (this._lastOvertyped.length = 0);
        return;
      }
      this._lastOvertyped = [];
      const o = e.getModel();
      for (let a = 0; a < n; a++) {
        const l = i[a];
        if (o.getValueLengthInRange(l) > jd._maxSelectionLength)
          return;
        this._lastOvertyped[a] = { value: o.getValueInRange(l), multiline: l.startLineNumber !== l.endLineNumber };
      }
    })), this._disposables.add(t.onDidTrigger((i) => {
      this._locked = !0;
    })), this._disposables.add(t.onDidCancel((i) => {
      this._locked = !1;
    }));
  }
  getLastOvertypedInfo(e) {
    if (e >= 0 && e < this._lastOvertyped.length)
      return this._lastOvertyped[e];
  }
  dispose() {
    this._disposables.dispose();
  }
}
jd._maxSelectionLength = 51200;
var fN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Vc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let mN = class Jb extends gg {
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    this.label && (this.label.textContent = g({ key: "content", comment: ["A label", "A keybinding"] }, "{0} ({1})", this._action.label, Jb.symbolPrintEnter(e)));
  }
  static symbolPrintEnter(e) {
    var t;
    return (t = e.getLabel()) === null || t === void 0 ? void 0 : t.replace(/\benter\b/gi, "");
  }
}, su = class {
  constructor(e, t, i, n, s) {
    this._menuId = t, this._menuService = n, this._contextKeyService = s, this._menuDisposables = new M(), this.element = A(e, O(".suggest-status-bar"));
    const o = (a) => a instanceof Gs ? i.createInstance(mN, a, void 0) : void 0;
    this._leftActions = new ur(this.element, { actionViewItemProvider: o }), this._rightActions = new ur(this.element, { actionViewItemProvider: o }), this._leftActions.domNode.classList.add("left"), this._rightActions.domNode.classList.add("right");
  }
  dispose() {
    this._menuDisposables.dispose(), this._leftActions.dispose(), this._rightActions.dispose(), this.element.remove();
  }
  show() {
    const e = this._menuService.createMenu(this._menuId, this._contextKeyService), t = () => {
      const i = [], n = [];
      for (const [s, o] of e.getActions())
        s === "left" ? i.push(...o) : n.push(...o);
      this._leftActions.clear(), this._leftActions.push(i), this._rightActions.clear(), this._rightActions.push(n);
    };
    this._menuDisposables.add(e.onDidChange(() => t())), this._menuDisposables.add(e);
  }
  hide() {
    this._menuDisposables.clear();
  }
};
su = fN([
  Vc(2, q),
  Vc(3, is),
  Vc(4, ee)
], su);
var _N = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, vN = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
function np(r) {
  return !!r && !!(r.completion.documentation || r.completion.detail && r.completion.detail !== r.completion.label);
}
let ou = class {
  constructor(e, t) {
    this._editor = e, this._onDidClose = new G(), this.onDidClose = this._onDidClose.event, this._onDidChangeContents = new G(), this.onDidChangeContents = this._onDidChangeContents.event, this._disposables = new M(), this._renderDisposeable = new M(), this._borderWidth = 1, this._size = new ae(330, 0), this.domNode = O(".suggest-details"), this.domNode.classList.add("no-docs"), this._markdownRenderer = t.createInstance(po, { editor: e }), this._body = O(".body"), this._scrollbar = new P_(this._body, {
      alwaysConsumeMouseWheel: !0
    }), A(this.domNode, this._scrollbar.getDomNode()), this._disposables.add(this._scrollbar), this._header = A(this._body, O(".header")), this._close = A(this._header, O("span" + oe.asCSSSelector(j.close))), this._close.title = g("details.close", "Close"), this._type = A(this._header, O("p.type")), this._docs = A(this._body, O("p.docs")), this._configureFont(), this._disposables.add(this._editor.onDidChangeConfiguration((i) => {
      i.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._configureFont();
    }));
  }
  dispose() {
    this._disposables.dispose(), this._renderDisposeable.dispose();
  }
  _configureFont() {
    const e = this._editor.getOptions(), t = e.get(
      50
      /* EditorOption.fontInfo */
    ), i = t.getMassagedFontFamily(), n = e.get(
      119
      /* EditorOption.suggestFontSize */
    ) || t.fontSize, s = e.get(
      120
      /* EditorOption.suggestLineHeight */
    ) || t.lineHeight, o = t.fontWeight, a = `${n}px`, l = `${s}px`;
    this.domNode.style.fontSize = a, this.domNode.style.lineHeight = `${s / n}`, this.domNode.style.fontWeight = o, this.domNode.style.fontFeatureSettings = t.fontFeatureSettings, this._type.style.fontFamily = i, this._close.style.height = l, this._close.style.width = l;
  }
  getLayoutInfo() {
    const e = this._editor.getOption(
      120
      /* EditorOption.suggestLineHeight */
    ) || this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ).lineHeight, t = this._borderWidth, i = t * 2;
    return {
      lineHeight: e,
      borderWidth: t,
      borderHeight: i,
      verticalPadding: 22,
      horizontalPadding: 14
    };
  }
  renderLoading() {
    this._type.textContent = g("loading", "Loading..."), this._docs.textContent = "", this.domNode.classList.remove("no-docs", "no-type"), this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2), this._onDidChangeContents.fire(this);
  }
  renderItem(e, t) {
    var i, n;
    this._renderDisposeable.clear();
    let { detail: s, documentation: o } = e.completion;
    if (t) {
      let a = "";
      a += `score: ${e.score[0]}
`, a += `prefix: ${(i = e.word) !== null && i !== void 0 ? i : "(no prefix)"}
`, a += `word: ${e.completion.filterText ? e.completion.filterText + " (filterText)" : e.textLabel}
`, a += `distance: ${e.distance} (localityBonus-setting)
`, a += `index: ${e.idx}, based on ${e.completion.sortText && `sortText: "${e.completion.sortText}"` || "label"}
`, a += `commit_chars: ${(n = e.completion.commitCharacters) === null || n === void 0 ? void 0 : n.join("")}
`, o = new Ue().appendCodeblock("empty", a), s = `Provider: ${e.provider._debugDisplayName}`;
    }
    if (!t && !np(e)) {
      this.clearContents();
      return;
    }
    if (this.domNode.classList.remove("no-docs", "no-type"), s) {
      const a = s.length > 1e5 ? `${s.substr(0, 1e5)}` : s;
      this._type.textContent = a, this._type.title = a, Dt(this._type), this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gmi.test(a));
    } else
      Qi(this._type), this._type.title = "", ut(this._type), this.domNode.classList.add("no-type");
    if (Qi(this._docs), typeof o == "string")
      this._docs.classList.remove("markdown-docs"), this._docs.textContent = o;
    else if (o) {
      this._docs.classList.add("markdown-docs"), Qi(this._docs);
      const a = this._markdownRenderer.render(o);
      this._docs.appendChild(a.element), this._renderDisposeable.add(a), this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {
        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight), this._onDidChangeContents.fire(this);
      }));
    }
    this.domNode.style.userSelect = "text", this.domNode.tabIndex = -1, this._close.onmousedown = (a) => {
      a.preventDefault(), a.stopPropagation();
    }, this._close.onclick = (a) => {
      a.preventDefault(), a.stopPropagation(), this._onDidClose.fire();
    }, this._body.scrollTop = 0, this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight), this._onDidChangeContents.fire(this);
  }
  clearContents() {
    this.domNode.classList.add("no-docs"), this._type.textContent = "", this._docs.textContent = "";
  }
  get isEmpty() {
    return this.domNode.classList.contains("no-docs");
  }
  get size() {
    return this._size;
  }
  layout(e, t) {
    const i = new ae(e, t);
    ae.equals(i, this._size) || (this._size = i, Uw(this.domNode, e, t)), this._scrollbar.scanDomNode();
  }
  scrollDown(e = 8) {
    this._body.scrollTop += e;
  }
  scrollUp(e = 8) {
    this._body.scrollTop -= e;
  }
  scrollTop() {
    this._body.scrollTop = 0;
  }
  scrollBottom() {
    this._body.scrollTop = this._body.scrollHeight;
  }
  pageDown() {
    this.scrollDown(80);
  }
  pageUp() {
    this.scrollUp(80);
  }
  set borderWidth(e) {
    this._borderWidth = e;
  }
  get borderWidth() {
    return this._borderWidth;
  }
};
ou = _N([
  vN(1, q)
], ou);
class bN {
  constructor(e, t) {
    this.widget = e, this._editor = t, this.allowEditorOverflow = !0, this._disposables = new M(), this._added = !1, this._preferAlignAtTop = !0, this._resizable = new Wg(), this._resizable.domNode.classList.add("suggest-details-container"), this._resizable.domNode.appendChild(e.domNode), this._resizable.enableSashes(!1, !0, !0, !1);
    let i, n, s = 0, o = 0;
    this._disposables.add(this._resizable.onDidWillResize(() => {
      i = this._topLeft, n = this._resizable.size;
    })), this._disposables.add(this._resizable.onDidResize((a) => {
      if (i && n) {
        this.widget.layout(a.dimension.width, a.dimension.height);
        let l = !1;
        a.west && (o = n.width - a.dimension.width, l = !0), a.north && (s = n.height - a.dimension.height, l = !0), l && this._applyTopLeft({
          top: i.top + s,
          left: i.left + o
        });
      }
      a.done && (i = void 0, n = void 0, s = 0, o = 0, this._userSize = a.dimension);
    })), this._disposables.add(this.widget.onDidChangeContents(() => {
      var a;
      this._anchorBox && this._placeAtAnchor(this._anchorBox, (a = this._userSize) !== null && a !== void 0 ? a : this.widget.size, this._preferAlignAtTop);
    }));
  }
  dispose() {
    this._resizable.dispose(), this._disposables.dispose(), this.hide();
  }
  getId() {
    return "suggest.details";
  }
  getDomNode() {
    return this._resizable.domNode;
  }
  getPosition() {
    return this._topLeft ? { preference: this._topLeft } : null;
  }
  show() {
    this._added || (this._editor.addOverlayWidget(this), this._added = !0);
  }
  hide(e = !1) {
    this._resizable.clearSashHoverState(), this._added && (this._editor.removeOverlayWidget(this), this._added = !1, this._anchorBox = void 0, this._topLeft = void 0), e && (this._userSize = void 0, this.widget.clearContents());
  }
  placeAtAnchor(e, t) {
    var i;
    const n = e.getBoundingClientRect();
    this._anchorBox = n, this._preferAlignAtTop = t, this._placeAtAnchor(this._anchorBox, (i = this._userSize) !== null && i !== void 0 ? i : this.widget.size, t);
  }
  _placeAtAnchor(e, t, i) {
    var n;
    const s = ia(this.getDomNode().ownerDocument.body), o = this.widget.getLayoutInfo(), a = new ae(220, 2 * o.lineHeight), l = e.top, d = function() {
      const k = s.width - (e.left + e.width + o.borderWidth + o.horizontalPadding), N = -o.borderWidth + e.left + e.width, J = new ae(k, s.height - e.top - o.borderHeight - o.verticalPadding), te = J.with(void 0, e.top + e.height - o.borderHeight - o.verticalPadding);
      return { top: l, left: N, fit: k - t.width, maxSizeTop: J, maxSizeBottom: te, minSize: a.with(Math.min(k, a.width)) };
    }(), c = function() {
      const k = e.left - o.borderWidth - o.horizontalPadding, N = Math.max(o.horizontalPadding, e.left - t.width - o.borderWidth), J = new ae(k, s.height - e.top - o.borderHeight - o.verticalPadding), te = J.with(void 0, e.top + e.height - o.borderHeight - o.verticalPadding);
      return { top: l, left: N, fit: k - t.width, maxSizeTop: J, maxSizeBottom: te, minSize: a.with(Math.min(k, a.width)) };
    }(), h = function() {
      const k = e.left, N = -o.borderWidth + e.top + e.height, J = new ae(e.width - o.borderHeight, s.height - e.top - e.height - o.verticalPadding);
      return { top: N, left: k, fit: J.height - t.height, maxSizeBottom: J, maxSizeTop: J, minSize: a.with(J.width) };
    }(), u = [d, c, h], p = (n = u.find((k) => k.fit >= 0)) !== null && n !== void 0 ? n : u.sort((k, N) => N.fit - k.fit)[0], f = e.top + e.height - o.borderHeight;
    let m, _ = t.height;
    const v = Math.max(p.maxSizeTop.height, p.maxSizeBottom.height);
    _ > v && (_ = v);
    let C;
    i ? _ <= p.maxSizeTop.height ? (m = !0, C = p.maxSizeTop) : (m = !1, C = p.maxSizeBottom) : _ <= p.maxSizeBottom.height ? (m = !1, C = p.maxSizeBottom) : (m = !0, C = p.maxSizeTop);
    let { top: w, left: y } = p;
    !m && _ > e.height && (w = f - _);
    const I = this._editor.getDomNode();
    if (I) {
      const k = I.getBoundingClientRect();
      w -= k.top, y -= k.left;
    }
    this._applyTopLeft({ left: y, top: w }), this._resizable.enableSashes(!m, p === d, m, p !== d), this._resizable.minSize = p.minSize, this._resizable.maxSize = C, this._resizable.layout(_, Math.min(C.width, t.width)), this.widget.layout(this._resizable.size.width, this._resizable.size.height);
  }
  _applyTopLeft(e) {
    this._topLeft = e, this._editor.layoutOverlayWidget(this);
  }
}
var ii;
(function(r) {
  r[r.FILE = 0] = "FILE", r[r.FOLDER = 1] = "FOLDER", r[r.ROOT_FOLDER = 2] = "ROOT_FOLDER";
})(ii || (ii = {}));
const CN = /(?:\/|^)(?:([^\/]+)\/)?([^\/]+)$/;
function Za(r, e, t, i, n) {
  if (n)
    return [`codicon-${n.id}`, "predefined-file-icon"];
  const s = i === ii.ROOT_FOLDER ? ["rootfolder-icon"] : i === ii.FOLDER ? ["folder-icon"] : ["file-icon"];
  if (t) {
    let o;
    if (t.scheme === wt.data)
      o = Il.parseMetaData(t).get(Il.META_DATA_LABEL);
    else {
      const a = t.path.match(CN);
      a ? (o = Xa(a[2].toLowerCase()), a[1] && s.push(`${Xa(a[1].toLowerCase())}-name-dir-icon`)) : o = Xa(t.authority.toLowerCase());
    }
    if (i === ii.ROOT_FOLDER)
      s.push(`${o}-root-name-folder-icon`);
    else if (i === ii.FOLDER)
      s.push(`${o}-name-folder-icon`);
    else {
      if (o) {
        if (s.push(`${o}-name-file-icon`), s.push("name-file-icon"), o.length <= 255) {
          const l = o.split(".");
          for (let d = 1; d < l.length; d++)
            s.push(`${l.slice(d).join(".")}-ext-file-icon`);
        }
        s.push("ext-file-icon");
      }
      const a = SN(r, e, t);
      a && s.push(`${Xa(a)}-lang-file-icon`);
    }
  }
  return s;
}
function SN(r, e, t) {
  if (!t)
    return null;
  let i = null;
  if (t.scheme === wt.data) {
    const s = Il.parseMetaData(t).get(Il.META_DATA_MIME);
    s && (i = e.getLanguageIdByMimeType(s));
  } else {
    const n = r.getModel(t);
    n && (i = n.getLanguageId());
  }
  return i && i !== jm ? i : e.guessLanguageIdByFilepathOrFirstLine(t);
}
function Xa(r) {
  return r.replace(/[\11\12\14\15\40]/g, "/");
}
var wN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Uc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Wi;
function eC(r) {
  return `suggest-aria-id:${r}`;
}
const yN = Ae("suggest-more-info", j.chevronRight, g("suggestMoreInfoIcon", "Icon for more information in the suggest widget.")), xN = new (Wi = class {
  extract(e, t) {
    if (e.textLabel.match(Wi._regexStrict))
      return t[0] = e.textLabel, !0;
    if (e.completion.detail && e.completion.detail.match(Wi._regexStrict))
      return t[0] = e.completion.detail, !0;
    if (e.completion.documentation) {
      const i = typeof e.completion.documentation == "string" ? e.completion.documentation : e.completion.documentation.value, n = Wi._regexRelaxed.exec(i);
      if (n && (n.index === 0 || n.index + n[0].length === i.length))
        return t[0] = n[0], !0;
    }
    return !1;
  }
}, Wi._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, Wi._regexStrict = new RegExp(`^${Wi._regexRelaxed.source}$`, "i"), Wi)();
let ru = class {
  constructor(e, t, i, n) {
    this._editor = e, this._modelService = t, this._languageService = i, this._themeService = n, this._onDidToggleDetails = new G(), this.onDidToggleDetails = this._onDidToggleDetails.event, this.templateId = "suggestion";
  }
  dispose() {
    this._onDidToggleDetails.dispose();
  }
  renderTemplate(e) {
    const t = new M(), i = e;
    i.classList.add("show-file-icons");
    const n = A(e, O(".icon")), s = A(n, O("span.colorspan")), o = A(e, O(".contents")), a = A(o, O(".main")), l = A(a, O(".icon-label.codicon")), d = A(a, O("span.left")), c = A(a, O("span.right")), h = new $m(d, { supportHighlights: !0, supportIcons: !0 });
    t.add(h);
    const u = A(d, O("span.signature-label")), p = A(d, O("span.qualifier-label")), f = A(c, O("span.details-label")), m = A(c, O("span.readMore" + oe.asCSSSelector(yN)));
    return m.title = g("readMore", "Read More"), { root: i, left: d, right: c, icon: n, colorspan: s, iconLabel: h, iconContainer: l, parametersLabel: u, qualifierLabel: p, detailsLabel: f, readMore: m, disposables: t, configureFont: () => {
      const v = this._editor.getOptions(), C = v.get(
        50
        /* EditorOption.fontInfo */
      ), w = C.getMassagedFontFamily(), y = C.fontFeatureSettings, I = v.get(
        119
        /* EditorOption.suggestFontSize */
      ) || C.fontSize, k = v.get(
        120
        /* EditorOption.suggestLineHeight */
      ) || C.lineHeight, N = C.fontWeight, J = C.letterSpacing, te = `${I}px`, ve = `${k}px`, be = `${J}px`;
      i.style.fontSize = te, i.style.fontWeight = N, i.style.letterSpacing = be, a.style.fontFamily = w, a.style.fontFeatureSettings = y, a.style.lineHeight = ve, n.style.height = ve, n.style.width = ve, m.style.height = ve, m.style.width = ve;
    } };
  }
  renderElement(e, t, i) {
    i.configureFont();
    const { completion: n } = e;
    i.root.id = eC(t), i.colorspan.style.backgroundColor = "";
    const s = {
      labelEscapeNewLines: !0,
      matches: ad(e.score)
    }, o = [];
    if (n.kind === 19 && xN.extract(e, o))
      i.icon.className = "icon customcolor", i.iconContainer.className = "icon hide", i.colorspan.style.backgroundColor = o[0];
    else if (n.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
      i.icon.className = "icon hide", i.iconContainer.className = "icon hide";
      const a = Za(this._modelService, this._languageService, ce.from({ scheme: "fake", path: e.textLabel }), ii.FILE), l = Za(this._modelService, this._languageService, ce.from({ scheme: "fake", path: n.detail }), ii.FILE);
      s.extraClasses = a.length > l.length ? a : l;
    } else
      n.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons ? (i.icon.className = "icon hide", i.iconContainer.className = "icon hide", s.extraClasses = [
        Za(this._modelService, this._languageService, ce.from({ scheme: "fake", path: e.textLabel }), ii.FOLDER),
        Za(this._modelService, this._languageService, ce.from({ scheme: "fake", path: n.detail }), ii.FOLDER)
      ].flat()) : (i.icon.className = "icon hide", i.iconContainer.className = "", i.iconContainer.classList.add("suggest-icon", ...oe.asClassNameArray(_g.toIcon(n.kind))));
    n.tags && n.tags.indexOf(
      1
      /* CompletionItemTag.Deprecated */
    ) >= 0 && (s.extraClasses = (s.extraClasses || []).concat(["deprecated"]), s.matches = []), i.iconLabel.setLabel(e.textLabel, void 0, s), typeof n.label == "string" ? (i.parametersLabel.textContent = "", i.detailsLabel.textContent = zc(n.detail || ""), i.root.classList.add("string-label")) : (i.parametersLabel.textContent = zc(n.label.detail || ""), i.detailsLabel.textContent = zc(n.label.description || ""), i.root.classList.remove("string-label")), this._editor.getOption(
      118
      /* EditorOption.suggest */
    ).showInlineDetails ? Dt(i.detailsLabel) : ut(i.detailsLabel), np(e) ? (i.right.classList.add("can-expand-details"), Dt(i.readMore), i.readMore.onmousedown = (a) => {
      a.stopPropagation(), a.preventDefault();
    }, i.readMore.onclick = (a) => {
      a.stopPropagation(), a.preventDefault(), this._onDidToggleDetails.fire();
    }) : (i.right.classList.remove("can-expand-details"), ut(i.readMore), i.readMore.onmousedown = null, i.readMore.onclick = null);
  }
  disposeTemplate(e) {
    e.disposables.dispose();
  }
};
ru = wN([
  Uc(1, Ge),
  Uc(2, Et),
  Uc(3, Mt)
], ru);
function zc(r) {
  return r.replace(/\r\n|\r|\n/g, "");
}
var LN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Qa = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, xs;
W("editorSuggestWidget.background", { dark: Uo, light: Uo, hcDark: Uo, hcLight: Uo }, g("editorSuggestWidgetBackground", "Background color of the suggest widget."));
W("editorSuggestWidget.border", { dark: La, light: La, hcDark: La, hcLight: La }, g("editorSuggestWidgetBorder", "Border color of the suggest widget."));
const Ya = W("editorSuggestWidget.foreground", { dark: $i, light: $i, hcDark: $i, hcLight: $i }, g("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
W("editorSuggestWidget.selectedForeground", { dark: Ia, light: Ia, hcDark: Ia, hcLight: Ia }, g("editorSuggestWidgetSelectedForeground", "Foreground color of the selected entry in the suggest widget."));
W("editorSuggestWidget.selectedIconForeground", { dark: Da, light: Da, hcDark: Da, hcLight: Da }, g("editorSuggestWidgetSelectedIconForeground", "Icon foreground color of the selected entry in the suggest widget."));
const IN = W("editorSuggestWidget.selectedBackground", { dark: ka, light: ka, hcDark: ka, hcLight: ka }, g("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
W("editorSuggestWidget.highlightForeground", { dark: ji, light: ji, hcDark: ji, hcLight: ji }, g("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
W("editorSuggestWidget.focusHighlightForeground", { dark: Na, light: Na, hcDark: Na, hcLight: Na }, g("editorSuggestWidgetFocusHighlightForeground", "Color of the match highlights in the suggest widget when an item is focused."));
W("editorSuggestWidgetStatus.foreground", { dark: yt(Ya, 0.5), light: yt(Ya, 0.5), hcDark: yt(Ya, 0.5), hcLight: yt(Ya, 0.5) }, g("editorSuggestWidgetStatusForeground", "Foreground color of the suggest widget status."));
class DN {
  constructor(e, t) {
    this._service = e, this._key = `suggestWidget.size/${t.getEditorType()}/${t instanceof an}`;
  }
  restore() {
    var e;
    const t = (e = this._service.get(
      this._key,
      0
      /* StorageScope.PROFILE */
    )) !== null && e !== void 0 ? e : "";
    try {
      const i = JSON.parse(t);
      if (ae.is(i))
        return ae.lift(i);
    } catch {
    }
  }
  store(e) {
    this._service.store(
      this._key,
      JSON.stringify(e),
      0,
      1
      /* StorageTarget.MACHINE */
    );
  }
  reset() {
    this._service.remove(
      this._key,
      0
      /* StorageScope.PROFILE */
    );
  }
}
let Ar = xs = class {
  constructor(e, t, i, n, s) {
    this.editor = e, this._storageService = t, this._state = 0, this._isAuto = !1, this._pendingLayout = new ft(), this._pendingShowDetails = new ft(), this._ignoreFocusEvents = !1, this._forceRenderingAbove = !1, this._explainMode = !1, this._showTimeout = new Xr(), this._disposables = new M(), this._onDidSelect = new Bp(), this._onDidFocus = new Bp(), this._onDidHide = new G(), this._onDidShow = new G(), this.onDidSelect = this._onDidSelect.event, this.onDidFocus = this._onDidFocus.event, this.onDidHide = this._onDidHide.event, this.onDidShow = this._onDidShow.event, this._onDetailsKeydown = new G(), this.onDetailsKeyDown = this._onDetailsKeydown.event, this.element = new Wg(), this.element.domNode.classList.add("editor-widget", "suggest-widget"), this._contentWidget = new kN(this, e), this._persistedSize = new DN(t, e);
    class o {
      constructor(p, f, m = !1, _ = !1) {
        this.persistedSize = p, this.currentSize = f, this.persistHeight = m, this.persistWidth = _;
      }
    }
    let a;
    this._disposables.add(this.element.onDidWillResize(() => {
      this._contentWidget.lockPreference(), a = new o(this._persistedSize.restore(), this.element.size);
    })), this._disposables.add(this.element.onDidResize((u) => {
      var p, f, m, _;
      if (this._resize(u.dimension.width, u.dimension.height), a && (a.persistHeight = a.persistHeight || !!u.north || !!u.south, a.persistWidth = a.persistWidth || !!u.east || !!u.west), !!u.done) {
        if (a) {
          const { itemHeight: v, defaultSize: C } = this.getLayoutInfo(), w = Math.round(v / 2);
          let { width: y, height: I } = this.element.size;
          (!a.persistHeight || Math.abs(a.currentSize.height - I) <= w) && (I = (f = (p = a.persistedSize) === null || p === void 0 ? void 0 : p.height) !== null && f !== void 0 ? f : C.height), (!a.persistWidth || Math.abs(a.currentSize.width - y) <= w) && (y = (_ = (m = a.persistedSize) === null || m === void 0 ? void 0 : m.width) !== null && _ !== void 0 ? _ : C.width), this._persistedSize.store(new ae(y, I));
        }
        this._contentWidget.unlockPreference(), a = void 0;
      }
    })), this._messageElement = A(this.element.domNode, O(".message")), this._listElement = A(this.element.domNode, O(".tree"));
    const l = this._disposables.add(s.createInstance(ou, this.editor));
    l.onDidClose(this.toggleDetails, this, this._disposables), this._details = new bN(l, this.editor);
    const d = () => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(
      118
      /* EditorOption.suggest */
    ).showIcons);
    d();
    const c = s.createInstance(ru, this.editor);
    this._disposables.add(c), this._disposables.add(c.onDidToggleDetails(() => this.toggleDetails())), this._list = new tg("SuggestWidget", this._listElement, {
      getHeight: (u) => this.getLayoutInfo().itemHeight,
      getTemplateId: (u) => "suggestion"
    }, [c], {
      alwaysConsumeMouseWheel: !0,
      useShadows: !1,
      mouseSupport: !1,
      multipleSelectionSupport: !1,
      accessibilityProvider: {
        getRole: () => "option",
        getWidgetAriaLabel: () => g("suggest", "Suggest"),
        getWidgetRole: () => "listbox",
        getAriaLabel: (u) => {
          let p = u.textLabel;
          if (typeof u.completion.label != "string") {
            const { detail: v, description: C } = u.completion.label;
            v && C ? p = g("label.full", "{0} {1}, {2}", p, v, C) : v ? p = g("label.detail", "{0} {1}", p, v) : C && (p = g("label.desc", "{0}, {1}", p, C));
          }
          if (!u.isResolved || !this._isDetailsVisible())
            return p;
          const { documentation: f, detail: m } = u.completion, _ = fg("{0}{1}", m || "", f ? typeof f == "string" ? f : f.value : "");
          return g("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", p, _);
        }
      }
    }), this._list.style(zw({
      listInactiveFocusBackground: IN,
      listInactiveFocusOutline: Hn
    })), this._status = s.createInstance(su, this.element.domNode, tn);
    const h = () => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(
      118
      /* EditorOption.suggest */
    ).showStatusBar);
    h(), this._disposables.add(n.onDidColorThemeChange((u) => this._onThemeChange(u))), this._onThemeChange(n.getColorTheme()), this._disposables.add(this._list.onMouseDown((u) => this._onListMouseDownOrTap(u))), this._disposables.add(this._list.onTap((u) => this._onListMouseDownOrTap(u))), this._disposables.add(this._list.onDidChangeSelection((u) => this._onListSelection(u))), this._disposables.add(this._list.onDidChangeFocus((u) => this._onListFocus(u))), this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged())), this._disposables.add(this.editor.onDidChangeConfiguration((u) => {
      u.hasChanged(
        118
        /* EditorOption.suggest */
      ) && (h(), d()), this._completionModel && (u.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) || u.hasChanged(
        119
        /* EditorOption.suggestFontSize */
      ) || u.hasChanged(
        120
        /* EditorOption.suggestLineHeight */
      )) && this._list.splice(0, this._list.length, this._completionModel.items);
    })), this._ctxSuggestWidgetVisible = U.Visible.bindTo(i), this._ctxSuggestWidgetDetailsVisible = U.DetailsVisible.bindTo(i), this._ctxSuggestWidgetMultipleSuggestions = U.MultipleSuggestions.bindTo(i), this._ctxSuggestWidgetHasFocusedSuggestion = U.HasFocusedSuggestion.bindTo(i), this._disposables.add(Bn(this._details.widget.domNode, "keydown", (u) => {
      this._onDetailsKeydown.fire(u);
    })), this._disposables.add(this.editor.onMouseDown((u) => this._onEditorMouseDown(u)));
  }
  dispose() {
    var e;
    this._details.widget.dispose(), this._details.dispose(), this._list.dispose(), this._status.dispose(), this._disposables.dispose(), (e = this._loadingTimeout) === null || e === void 0 || e.dispose(), this._pendingLayout.dispose(), this._pendingShowDetails.dispose(), this._showTimeout.dispose(), this._contentWidget.dispose(), this.element.dispose();
  }
  _onEditorMouseDown(e) {
    this._details.widget.domNode.contains(e.target.element) ? this._details.widget.domNode.focus() : this.element.domNode.contains(e.target.element) && this.editor.focus();
  }
  _onCursorSelectionChanged() {
    this._state !== 0 && this._contentWidget.layout();
  }
  _onListMouseDownOrTap(e) {
    typeof e.element > "u" || typeof e.index > "u" || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation(), this._select(e.element, e.index));
  }
  _onListSelection(e) {
    e.elements.length && this._select(e.elements[0], e.indexes[0]);
  }
  _select(e, t) {
    const i = this._completionModel;
    i && (this._onDidSelect.fire({ item: e, index: t, model: i }), this.editor.focus());
  }
  _onThemeChange(e) {
    this._details.widget.borderWidth = gr(e.type) ? 2 : 1;
  }
  _onListFocus(e) {
    var t;
    if (this._ignoreFocusEvents)
      return;
    if (!e.elements.length) {
      this._currentSuggestionDetails && (this._currentSuggestionDetails.cancel(), this._currentSuggestionDetails = void 0, this._focusedItem = void 0), this.editor.setAriaOptions({ activeDescendant: void 0 }), this._ctxSuggestWidgetHasFocusedSuggestion.set(!1);
      return;
    }
    if (!this._completionModel)
      return;
    this._ctxSuggestWidgetHasFocusedSuggestion.set(!0);
    const i = e.elements[0], n = e.indexes[0];
    i !== this._focusedItem && ((t = this._currentSuggestionDetails) === null || t === void 0 || t.cancel(), this._currentSuggestionDetails = void 0, this._focusedItem = i, this._list.reveal(n), this._currentSuggestionDetails = Pe(async (s) => {
      const o = hr(() => {
        this._isDetailsVisible() && this.showDetails(!0);
      }, 250), a = s.onCancellationRequested(() => o.dispose());
      try {
        return await i.resolve(s);
      } finally {
        o.dispose(), a.dispose();
      }
    }), this._currentSuggestionDetails.then(() => {
      n >= this._list.length || i !== this._list.element(n) || (this._ignoreFocusEvents = !0, this._list.splice(n, 1, [i]), this._list.setFocus([n]), this._ignoreFocusEvents = !1, this._isDetailsVisible() ? this.showDetails(!1) : this.element.domNode.classList.remove("docs-side"), this.editor.setAriaOptions({ activeDescendant: eC(n) }));
    }).catch(re)), this._onDidFocus.fire({ item: i, index: n, model: this._completionModel });
  }
  _setState(e) {
    if (this._state !== e)
      switch (this._state = e, this.element.domNode.classList.toggle(
        "frozen",
        e === 4
        /* State.Frozen */
      ), this.element.domNode.classList.remove("message"), e) {
        case 0:
          ut(this._messageElement, this._listElement, this._status.element), this._details.hide(!0), this._status.hide(), this._contentWidget.hide(), this._ctxSuggestWidgetVisible.reset(), this._ctxSuggestWidgetMultipleSuggestions.reset(), this._ctxSuggestWidgetHasFocusedSuggestion.reset(), this._showTimeout.cancel(), this.element.domNode.classList.remove("visible"), this._list.splice(0, this._list.length), this._focusedItem = void 0, this._cappedHeight = void 0, this._explainMode = !1;
          break;
        case 1:
          this.element.domNode.classList.add("message"), this._messageElement.textContent = xs.LOADING_MESSAGE, ut(this._listElement, this._status.element), Dt(this._messageElement), this._details.hide(), this._show(), this._focusedItem = void 0, zs(xs.LOADING_MESSAGE);
          break;
        case 2:
          this.element.domNode.classList.add("message"), this._messageElement.textContent = xs.NO_SUGGESTIONS_MESSAGE, ut(this._listElement, this._status.element), Dt(this._messageElement), this._details.hide(), this._show(), this._focusedItem = void 0, zs(xs.NO_SUGGESTIONS_MESSAGE);
          break;
        case 3:
          ut(this._messageElement), Dt(this._listElement, this._status.element), this._show();
          break;
        case 4:
          ut(this._messageElement), Dt(this._listElement, this._status.element), this._show();
          break;
        case 5:
          ut(this._messageElement), Dt(this._listElement, this._status.element), this._details.show(), this._show();
          break;
      }
  }
  _show() {
    this._status.show(), this._contentWidget.show(), this._layout(this._persistedSize.restore()), this._ctxSuggestWidgetVisible.set(!0), this._showTimeout.cancelAndSet(() => {
      this.element.domNode.classList.add("visible"), this._onDidShow.fire(this);
    }, 100);
  }
  showTriggered(e, t) {
    this._state === 0 && (this._contentWidget.setPosition(this.editor.getPosition()), this._isAuto = !!e, this._isAuto || (this._loadingTimeout = hr(() => this._setState(
      1
      /* State.Loading */
    ), t)));
  }
  showSuggestions(e, t, i, n, s) {
    var o, a;
    if (this._contentWidget.setPosition(this.editor.getPosition()), (o = this._loadingTimeout) === null || o === void 0 || o.dispose(), (a = this._currentSuggestionDetails) === null || a === void 0 || a.cancel(), this._currentSuggestionDetails = void 0, this._completionModel !== e && (this._completionModel = e), i && this._state !== 2 && this._state !== 0) {
      this._setState(
        4
        /* State.Frozen */
      );
      return;
    }
    const l = this._completionModel.items.length, d = l === 0;
    if (this._ctxSuggestWidgetMultipleSuggestions.set(l > 1), d) {
      this._setState(
        n ? 0 : 2
        /* State.Empty */
      ), this._completionModel = void 0;
      return;
    }
    this._focusedItem = void 0, this._onDidFocus.pause(), this._onDidSelect.pause();
    try {
      this._list.splice(0, this._list.length, this._completionModel.items), this._setState(
        i ? 4 : 3
        /* State.Open */
      ), this._list.reveal(t, 0), this._list.setFocus(s ? [] : [t]);
    } finally {
      this._onDidFocus.resume(), this._onDidSelect.resume();
    }
    this._pendingLayout.value = Vp(En(this.element.domNode), () => {
      this._pendingLayout.clear(), this._layout(this.element.size), this._details.widget.domNode.classList.remove("focused");
    });
  }
  focusSelected() {
    this._list.length > 0 && this._list.setFocus([0]);
  }
  selectNextPage() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.pageDown(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusNextPage(), !0;
    }
  }
  selectNext() {
    switch (this._state) {
      case 0:
        return !1;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusNext(1, !0), !0;
    }
  }
  selectLast() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.scrollBottom(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusLast(), !0;
    }
  }
  selectPreviousPage() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.pageUp(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusPreviousPage(), !0;
    }
  }
  selectPrevious() {
    switch (this._state) {
      case 0:
        return !1;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusPrevious(1, !0), !1;
    }
  }
  selectFirst() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.scrollTop(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusFirst(), !0;
    }
  }
  getFocusedItem() {
    if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel && this._list.getFocus().length > 0)
      return {
        item: this._list.getFocusedElements()[0],
        index: this._list.getFocus()[0],
        model: this._completionModel
      };
  }
  toggleDetailsFocus() {
    this._state === 5 ? (this._setState(
      3
      /* State.Open */
    ), this._details.widget.domNode.classList.remove("focused")) : this._state === 3 && this._isDetailsVisible() && (this._setState(
      5
      /* State.Details */
    ), this._details.widget.domNode.classList.add("focused"));
  }
  toggleDetails() {
    this._isDetailsVisible() ? (this._pendingShowDetails.clear(), this._ctxSuggestWidgetDetailsVisible.set(!1), this._setDetailsVisible(!1), this._details.hide(), this.element.domNode.classList.remove("shows-details")) : (np(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4) && (this._ctxSuggestWidgetDetailsVisible.set(!0), this._setDetailsVisible(!0), this.showDetails(!1));
  }
  showDetails(e) {
    this._pendingShowDetails.value = Vp(En(this.element.domNode), () => {
      this._pendingShowDetails.clear(), this._details.show(), e ? this._details.widget.renderLoading() : this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode), this._details.widget.isEmpty ? this._details.hide() : (this._positionDetails(), this.element.domNode.classList.add("shows-details")), this.editor.focus();
    });
  }
  toggleExplainMode() {
    this._list.getFocusedElements()[0] && (this._explainMode = !this._explainMode, this._isDetailsVisible() ? this.showDetails(!1) : this.toggleDetails());
  }
  resetPersistedSize() {
    this._persistedSize.reset();
  }
  hideWidget() {
    var e;
    this._pendingLayout.clear(), this._pendingShowDetails.clear(), (e = this._loadingTimeout) === null || e === void 0 || e.dispose(), this._setState(
      0
      /* State.Hidden */
    ), this._onDidHide.fire(this), this.element.clearSashHoverState();
    const t = this._persistedSize.restore(), i = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
    t && t.height < i && this._persistedSize.store(t.with(void 0, i));
  }
  isFrozen() {
    return this._state === 4;
  }
  _afterRender(e) {
    if (e === null) {
      this._isDetailsVisible() && this._details.hide();
      return;
    }
    this._state === 2 || this._state === 1 || (this._isDetailsVisible() && !this._details.widget.isEmpty && this._details.show(), this._positionDetails());
  }
  _layout(e) {
    var t, i, n;
    if (!this.editor.hasModel() || !this.editor.getDomNode())
      return;
    const s = ia(this.element.domNode.ownerDocument.body), o = this.getLayoutInfo();
    e || (e = o.defaultSize);
    let a = e.height, l = e.width;
    if (this._status.element.style.height = `${o.itemHeight}px`, this._state === 2 || this._state === 1)
      a = o.itemHeight + o.borderHeight, l = o.defaultSize.width / 2, this.element.enableSashes(!1, !1, !1, !1), this.element.minSize = this.element.maxSize = new ae(l, a), this._contentWidget.setPreference(
        2
        /* ContentWidgetPositionPreference.BELOW */
      );
    else {
      const d = s.width - o.borderHeight - 2 * o.horizontalPadding;
      l > d && (l = d);
      const c = this._completionModel ? this._completionModel.stats.pLabelLen * o.typicalHalfwidthCharacterWidth : l, h = o.statusBarHeight + this._list.contentHeight + o.borderHeight, u = o.itemHeight + o.statusBarHeight, p = mt(this.editor.getDomNode()), f = this.editor.getScrolledVisiblePosition(this.editor.getPosition()), m = p.top + f.top + f.height, _ = Math.min(s.height - m - o.verticalPadding, h), v = p.top + f.top - o.verticalPadding, C = Math.min(v, h);
      let w = Math.min(Math.max(C, _) + o.borderHeight, h);
      a === ((t = this._cappedHeight) === null || t === void 0 ? void 0 : t.capped) && (a = this._cappedHeight.wanted), a < u && (a = u), a > w && (a = w), a > _ || this._forceRenderingAbove && v > 150 ? (this._contentWidget.setPreference(
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ), this.element.enableSashes(!0, !0, !1, !1), w = C) : (this._contentWidget.setPreference(
        2
        /* ContentWidgetPositionPreference.BELOW */
      ), this.element.enableSashes(!1, !0, !0, !1), w = _), this.element.preferredSize = new ae(c, o.defaultSize.height), this.element.maxSize = new ae(d, w), this.element.minSize = new ae(220, u), this._cappedHeight = a === h ? { wanted: (n = (i = this._cappedHeight) === null || i === void 0 ? void 0 : i.wanted) !== null && n !== void 0 ? n : e.height, capped: a } : void 0;
    }
    this._resize(l, a);
  }
  _resize(e, t) {
    const { width: i, height: n } = this.element.maxSize;
    e = Math.min(i, e), t = Math.min(n, t);
    const { statusBarHeight: s } = this.getLayoutInfo();
    this._list.layout(t - s, e), this._listElement.style.height = `${t - s}px`, this.element.layout(t, e), this._contentWidget.layout(), this._positionDetails();
  }
  _positionDetails() {
    var e;
    this._isDetailsVisible() && this._details.placeAtAnchor(
      this.element.domNode,
      ((e = this._contentWidget.getPosition()) === null || e === void 0 ? void 0 : e.preference[0]) === 2
      /* ContentWidgetPositionPreference.BELOW */
    );
  }
  getLayoutInfo() {
    const e = this.editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), t = $w(this.editor.getOption(
      120
      /* EditorOption.suggestLineHeight */
    ) || e.lineHeight, 8, 1e3), i = !this.editor.getOption(
      118
      /* EditorOption.suggest */
    ).showStatusBar || this._state === 2 || this._state === 1 ? 0 : t, n = this._details.widget.borderWidth, s = 2 * n;
    return {
      itemHeight: t,
      statusBarHeight: i,
      borderWidth: n,
      borderHeight: s,
      typicalHalfwidthCharacterWidth: e.typicalHalfwidthCharacterWidth,
      verticalPadding: 22,
      horizontalPadding: 14,
      defaultSize: new ae(430, i + 12 * t + s)
    };
  }
  _isDetailsVisible() {
    return this._storageService.getBoolean("expandSuggestionDocs", 0, !1);
  }
  _setDetailsVisible(e) {
    this._storageService.store(
      "expandSuggestionDocs",
      e,
      0,
      0
      /* StorageTarget.USER */
    );
  }
  forceRenderingAbove() {
    this._forceRenderingAbove || (this._forceRenderingAbove = !0, this._layout(this._persistedSize.restore()));
  }
  stopForceRenderingAbove() {
    this._forceRenderingAbove = !1;
  }
};
Ar.LOADING_MESSAGE = g("suggestWidget.loading", "Loading...");
Ar.NO_SUGGESTIONS_MESSAGE = g("suggestWidget.noSuggestions", "No suggestions.");
Ar = xs = LN([
  Qa(1, vn),
  Qa(2, ee),
  Qa(3, Mt),
  Qa(4, q)
], Ar);
class kN {
  constructor(e, t) {
    this._widget = e, this._editor = t, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._preferenceLocked = !1, this._added = !1, this._hidden = !1;
  }
  dispose() {
    this._added && (this._added = !1, this._editor.removeContentWidget(this));
  }
  getId() {
    return "editor.widget.suggestWidget";
  }
  getDomNode() {
    return this._widget.element.domNode;
  }
  show() {
    this._hidden = !1, this._added || (this._added = !0, this._editor.addContentWidget(this));
  }
  hide() {
    this._hidden || (this._hidden = !0, this.layout());
  }
  layout() {
    this._editor.layoutContentWidget(this);
  }
  getPosition() {
    return this._hidden || !this._position || !this._preference ? null : {
      position: this._position,
      preference: [this._preference]
    };
  }
  beforeRender() {
    const { height: e, width: t } = this._widget.element.size, { borderWidth: i, horizontalPadding: n } = this._widget.getLayoutInfo();
    return new ae(t + 2 * i + n, e + 2 * i);
  }
  afterRender(e) {
    this._widget._afterRender(e);
  }
  setPreference(e) {
    this._preferenceLocked || (this._preference = e);
  }
  lockPreference() {
    this._preferenceLocked = !0;
  }
  unlockPreference() {
    this._preferenceLocked = !1;
  }
  setPosition(e) {
    this._position = e;
  }
}
var NN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ms = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, au;
class RN {
  constructor(e, t) {
    if (this._model = e, this._position = t, this._decorationOptions = Y.register({
      description: "suggest-line-suffix",
      stickiness: 1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    }), e.getLineMaxColumn(t.lineNumber) !== t.column) {
      const n = e.getOffsetAt(t), s = e.getPositionAt(n + 1);
      e.changeDecorations((o) => {
        this._marker && o.removeDecoration(this._marker), this._marker = o.addDecoration(S.fromPositions(t, s), this._decorationOptions);
      });
    }
  }
  dispose() {
    this._marker && !this._model.isDisposed() && this._model.changeDecorations((e) => {
      e.removeDecoration(this._marker), this._marker = void 0;
    });
  }
  delta(e) {
    if (this._model.isDisposed() || this._position.lineNumber !== e.lineNumber)
      return 0;
    if (this._marker) {
      const t = this._model.getDecorationRange(this._marker);
      return this._model.getOffsetAt(t.getStartPosition()) - this._model.getOffsetAt(e);
    } else
      return this._model.getLineMaxColumn(e.lineNumber) - e.column;
  }
}
let kt = au = class {
  static get(e) {
    return e.getContribution(au.ID);
  }
  constructor(e, t, i, n, s, o, a) {
    this._memoryService = t, this._commandService = i, this._contextKeyService = n, this._instantiationService = s, this._logService = o, this._telemetryService = a, this._lineSuffix = new ft(), this._toDispose = new M(), this._selectors = new PN((h) => h.priority), this._onWillInsertSuggestItem = new G(), this.onWillInsertSuggestItem = this._onWillInsertSuggestItem.event, this.editor = e, this.model = s.createInstance(ql, this.editor), this._selectors.register({
      priority: 0,
      select: (h, u, p) => this._memoryService.select(h, u, p)
    });
    const l = U.InsertMode.bindTo(n);
    l.set(e.getOption(
      118
      /* EditorOption.suggest */
    ).insertMode), this._toDispose.add(this.model.onDidTrigger(() => l.set(e.getOption(
      118
      /* EditorOption.suggest */
    ).insertMode))), this.widget = this._toDispose.add(new vc(En(e.getDomNode()), () => {
      const h = this._instantiationService.createInstance(Ar, this.editor);
      this._toDispose.add(h), this._toDispose.add(h.onDidSelect((_) => this._insertSuggestion(
        _,
        0
        /* InsertFlags.None */
      ), this));
      const u = new hN(this.editor, h, this.model, (_) => this._insertSuggestion(
        _,
        2
        /* InsertFlags.NoAfterUndoStop */
      ));
      this._toDispose.add(u);
      const p = U.MakesTextEdit.bindTo(this._contextKeyService), f = U.HasInsertAndReplaceRange.bindTo(this._contextKeyService), m = U.CanResolve.bindTo(this._contextKeyService);
      return this._toDispose.add(pe(() => {
        p.reset(), f.reset(), m.reset();
      })), this._toDispose.add(h.onDidFocus(({ item: _ }) => {
        const v = this.editor.getPosition(), C = _.editStart.column, w = v.column;
        let y = !0;
        this.editor.getOption(
          1
          /* EditorOption.acceptSuggestionOnEnter */
        ) === "smart" && this.model.state === 2 && !_.completion.additionalTextEdits && !(_.completion.insertTextRules & 4) && w - C === _.completion.insertText.length && (y = this.editor.getModel().getValueInRange({
          startLineNumber: v.lineNumber,
          startColumn: C,
          endLineNumber: v.lineNumber,
          endColumn: w
        }) !== _.completion.insertText), p.set(y), f.set(!F.equals(_.editInsertEnd, _.editReplaceEnd)), m.set(!!_.provider.resolveCompletionItem || !!_.completion.documentation || _.completion.detail !== _.completion.label);
      })), this._toDispose.add(h.onDetailsKeyDown((_) => {
        if (_.toKeyCodeChord().equals(new Up(
          !0,
          !1,
          !1,
          !1,
          33
          /* KeyCode.KeyC */
        )) || si && _.toKeyCodeChord().equals(new Up(
          !1,
          !1,
          !1,
          !0,
          33
          /* KeyCode.KeyC */
        ))) {
          _.stopPropagation();
          return;
        }
        _.toKeyCodeChord().isModifierKey() || this.editor.focus();
      })), h;
    })), this._overtypingCapturer = this._toDispose.add(new vc(En(e.getDomNode()), () => this._toDispose.add(new jd(this.editor, this.model)))), this._alternatives = this._toDispose.add(new vc(En(e.getDomNode()), () => this._toDispose.add(new Xn(this.editor, this._contextKeyService)))), this._toDispose.add(s.createInstance(Tr, e)), this._toDispose.add(this.model.onDidTrigger((h) => {
      this.widget.value.showTriggered(h.auto, h.shy ? 250 : 50), this._lineSuffix.value = new RN(this.editor.getModel(), h.position);
    })), this._toDispose.add(this.model.onDidSuggest((h) => {
      if (h.triggerOptions.shy)
        return;
      let u = -1;
      for (const f of this._selectors.itemsOrderedByPriorityDesc)
        if (u = f.select(this.editor.getModel(), this.editor.getPosition(), h.completionModel.items), u !== -1)
          break;
      if (u === -1 && (u = 0), this.model.state === 0)
        return;
      let p = !1;
      if (h.triggerOptions.auto) {
        const f = this.editor.getOption(
          118
          /* EditorOption.suggest */
        );
        f.selectionMode === "never" || f.selectionMode === "always" ? p = f.selectionMode === "never" : f.selectionMode === "whenTriggerCharacter" ? p = h.triggerOptions.triggerKind !== 1 : f.selectionMode === "whenQuickSuggestion" && (p = h.triggerOptions.triggerKind === 1 && !h.triggerOptions.refilter);
      }
      this.widget.value.showSuggestions(h.completionModel, u, h.isFrozen, h.triggerOptions.auto, p);
    })), this._toDispose.add(this.model.onDidCancel((h) => {
      h.retrigger || this.widget.value.hideWidget();
    })), this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
      this.model.cancel(), this.model.clear();
    }));
    const d = U.AcceptSuggestionsOnEnter.bindTo(n), c = () => {
      const h = this.editor.getOption(
        1
        /* EditorOption.acceptSuggestionOnEnter */
      );
      d.set(h === "on" || h === "smart");
    };
    this._toDispose.add(this.editor.onDidChangeConfiguration(() => c())), c();
  }
  dispose() {
    this._alternatives.dispose(), this._toDispose.dispose(), this.widget.dispose(), this.model.dispose(), this._lineSuffix.dispose(), this._onWillInsertSuggestItem.dispose();
  }
  _insertSuggestion(e, t) {
    if (!e || !e.item) {
      this._alternatives.value.reset(), this.model.cancel(), this.model.clear();
      return;
    }
    if (!this.editor.hasModel())
      return;
    const i = Me.get(this.editor);
    if (!i)
      return;
    this._onWillInsertSuggestItem.fire({ item: e.item });
    const n = this.editor.getModel(), s = n.getAlternativeVersionId(), { item: o } = e, a = [], l = new Oe();
    t & 1 || this.editor.pushUndoStop();
    const d = this.getOverwriteInfo(o, !!(t & 8));
    this._memoryService.memorize(n, this.editor.getPosition(), o);
    const c = o.isResolved;
    let h = -1, u = -1;
    if (Array.isArray(o.completion.additionalTextEdits)) {
      this.model.cancel();
      const f = $s.capture(this.editor);
      this.editor.executeEdits("suggestController.additionalTextEdits.sync", o.completion.additionalTextEdits.map((m) => {
        let _ = S.lift(m.range);
        if (_.startLineNumber === o.position.lineNumber && _.startColumn > o.position.column) {
          const v = this.editor.getPosition().column - o.position.column, C = v, w = S.spansMultipleLines(_) ? 0 : v;
          _ = new S(_.startLineNumber, _.startColumn + C, _.endLineNumber, _.endColumn + w);
        }
        return ue.replaceMove(_, m.text);
      })), f.restoreRelativeVerticalPositionOfCursor(this.editor);
    } else if (!c) {
      const f = new Rt();
      let m;
      const _ = n.onDidChangeContent((y) => {
        if (y.isFlush) {
          l.cancel(), _.dispose();
          return;
        }
        for (const I of y.changes) {
          const k = S.getEndPosition(I.range);
          (!m || F.isBefore(k, m)) && (m = k);
        }
      }), v = t;
      t |= 2;
      let C = !1;
      const w = this.editor.onWillType(() => {
        w.dispose(), C = !0, v & 2 || this.editor.pushUndoStop();
      });
      a.push(o.resolve(l.token).then(() => {
        if (!o.completion.additionalTextEdits || l.token.isCancellationRequested)
          return;
        if (m && o.completion.additionalTextEdits.some((I) => F.isBefore(m, S.getStartPosition(I.range))))
          return !1;
        C && this.editor.pushUndoStop();
        const y = $s.capture(this.editor);
        return this.editor.executeEdits("suggestController.additionalTextEdits.async", o.completion.additionalTextEdits.map((I) => ue.replaceMove(S.lift(I.range), I.text))), y.restoreRelativeVerticalPositionOfCursor(this.editor), (C || !(v & 2)) && this.editor.pushUndoStop(), !0;
      }).then((y) => {
        this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", f.elapsed(), y), u = y === !0 ? 1 : y === !1 ? 0 : -2;
      }).finally(() => {
        _.dispose(), w.dispose();
      }));
    }
    let { insertText: p } = o.completion;
    if (o.completion.insertTextRules & 4 || (p = Un.escape(p)), this.model.cancel(), i.insert(p, {
      overwriteBefore: d.overwriteBefore,
      overwriteAfter: d.overwriteAfter,
      undoStopBefore: !1,
      undoStopAfter: !1,
      adjustWhitespace: !(o.completion.insertTextRules & 1),
      clipboardText: e.model.clipboardText,
      overtypingCapturer: this._overtypingCapturer.value
    }), t & 2 || this.editor.pushUndoStop(), o.completion.command)
      if (o.completion.command.id === ma.id)
        this.model.trigger({ auto: !0, retrigger: !0 });
      else {
        const f = new Rt();
        a.push(this._commandService.executeCommand(o.completion.command.id, ...o.completion.command.arguments ? [...o.completion.command.arguments] : []).catch((m) => {
          o.completion.extensionId ? Ie(m) : re(m);
        }).finally(() => {
          h = f.elapsed();
        }));
      }
    t & 4 && this._alternatives.value.set(e, (f) => {
      for (l.cancel(); n.canUndo(); ) {
        s !== n.getAlternativeVersionId() && n.undo(), this._insertSuggestion(f, 3 | (t & 8 ? 8 : 0));
        break;
      }
    }), this._alertCompletionItem(o), Promise.all(a).finally(() => {
      this._reportSuggestionAcceptedTelemetry(o, n, c, h, u), this.model.clear(), l.dispose();
    });
  }
  _reportSuggestionAcceptedTelemetry(e, t, i, n, s) {
    var o, a, l;
    Math.floor(Math.random() * 100) !== 0 && this._telemetryService.publicLog2("suggest.acceptedSuggestion", {
      extensionId: (a = (o = e.extensionId) === null || o === void 0 ? void 0 : o.value) !== null && a !== void 0 ? a : "unknown",
      providerId: (l = e.provider._debugDisplayName) !== null && l !== void 0 ? l : "unknown",
      kind: e.completion.kind,
      basenameHash: p_(oi(t.uri)).toString(16),
      languageId: t.getLanguageId(),
      fileExtension: jw(t.uri),
      resolveInfo: e.provider.resolveCompletionItem ? i ? 1 : 0 : -1,
      resolveDuration: e.resolveDuration,
      commandDuration: n,
      additionalEditsAsync: s
    });
  }
  getOverwriteInfo(e, t) {
    ie(this.editor.hasModel());
    let i = this.editor.getOption(
      118
      /* EditorOption.suggest */
    ).insertMode === "replace";
    t && (i = !i);
    const n = e.position.column - e.editStart.column, s = (i ? e.editReplaceEnd.column : e.editInsertEnd.column) - e.position.column, o = this.editor.getPosition().column - e.position.column, a = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
    return {
      overwriteBefore: n + o,
      overwriteAfter: s + a
    };
  }
  _alertCompletionItem(e) {
    if (nt(e.completion.additionalTextEdits)) {
      const t = g("aria.alert.snippet", "Accepting '{0}' made {1} additional edits", e.textLabel, e.completion.additionalTextEdits.length);
      xt(t);
    }
  }
  triggerSuggest(e, t, i) {
    this.editor.hasModel() && (this.model.trigger({
      auto: t ?? !1,
      completionOptions: { providerFilter: e, kindFilter: i ? /* @__PURE__ */ new Set() : void 0 }
    }), this.editor.revealPosition(
      this.editor.getPosition(),
      0
      /* ScrollType.Smooth */
    ), this.editor.focus());
  }
  triggerSuggestAndAcceptBest(e) {
    if (!this.editor.hasModel())
      return;
    const t = this.editor.getPosition(), i = () => {
      t.equals(this.editor.getPosition()) && this._commandService.executeCommand(e.fallback);
    }, n = (s) => {
      if (s.completion.insertTextRules & 4 || s.completion.additionalTextEdits)
        return !0;
      const o = this.editor.getPosition(), a = s.editStart.column, l = o.column;
      return l - a !== s.completion.insertText.length ? !0 : this.editor.getModel().getValueInRange({
        startLineNumber: o.lineNumber,
        startColumn: a,
        endLineNumber: o.lineNumber,
        endColumn: l
      }) !== s.completion.insertText;
    };
    De.once(this.model.onDidTrigger)((s) => {
      const o = [];
      De.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
        $e(o), i();
      }, void 0, o), this.model.onDidSuggest(({ completionModel: a }) => {
        if ($e(o), a.items.length === 0) {
          i();
          return;
        }
        const l = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), a.items), d = a.items[l];
        if (!n(d)) {
          i();
          return;
        }
        this.editor.pushUndoStop(), this._insertSuggestion(
          { index: l, item: d, model: a },
          7
          /* InsertFlags.NoAfterUndoStop */
        );
      }, void 0, o);
    }), this.model.trigger({ auto: !1, shy: !0 }), this.editor.revealPosition(
      t,
      0
      /* ScrollType.Smooth */
    ), this.editor.focus();
  }
  acceptSelectedSuggestion(e, t) {
    const i = this.widget.value.getFocusedItem();
    let n = 0;
    e && (n |= 4), t && (n |= 8), this._insertSuggestion(i, n);
  }
  acceptNextSuggestion() {
    this._alternatives.value.next();
  }
  acceptPrevSuggestion() {
    this._alternatives.value.prev();
  }
  cancelSuggestWidget() {
    this.model.cancel(), this.model.clear(), this.widget.value.hideWidget();
  }
  focusSuggestion() {
    this.widget.value.focusSelected();
  }
  selectNextSuggestion() {
    this.widget.value.selectNext();
  }
  selectNextPageSuggestion() {
    this.widget.value.selectNextPage();
  }
  selectLastSuggestion() {
    this.widget.value.selectLast();
  }
  selectPrevSuggestion() {
    this.widget.value.selectPrevious();
  }
  selectPrevPageSuggestion() {
    this.widget.value.selectPreviousPage();
  }
  selectFirstSuggestion() {
    this.widget.value.selectFirst();
  }
  toggleSuggestionDetails() {
    this.widget.value.toggleDetails();
  }
  toggleExplainMode() {
    this.widget.value.toggleExplainMode();
  }
  toggleSuggestionFocus() {
    this.widget.value.toggleDetailsFocus();
  }
  resetWidgetSize() {
    this.widget.value.resetPersistedSize();
  }
  forceRenderingAbove() {
    this.widget.value.forceRenderingAbove();
  }
  stopForceRenderingAbove() {
    this.widget.isInitialized && this.widget.value.stopForceRenderingAbove();
  }
  registerSelector(e) {
    return this._selectors.register(e);
  }
};
kt.ID = "editor.contrib.suggestController";
kt = au = NN([
  ms(1, $d),
  ms(2, Fe),
  ms(3, ee),
  ms(4, q),
  ms(5, fo),
  ms(6, ui)
], kt);
class PN {
  constructor(e) {
    this.prioritySelector = e, this._items = new Array();
  }
  register(e) {
    if (this._items.indexOf(e) !== -1)
      throw new Error("Value is already registered");
    return this._items.push(e), this._items.sort((t, i) => this.prioritySelector(i) - this.prioritySelector(t)), {
      dispose: () => {
        const t = this._items.indexOf(e);
        t >= 0 && this._items.splice(t, 1);
      }
    };
  }
  get itemsOrderedByPriorityDesc() {
    return this._items;
  }
}
class ma extends D {
  constructor() {
    super({
      id: ma.id,
      label: g("suggest.trigger.label", "Trigger Suggest"),
      alias: "Trigger Suggest",
      precondition: L.and(b.writable, b.hasCompletionItemProvider, U.Visible.toNegated()),
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 2058,
        secondary: [
          2087
          /* KeyCode.KeyI */
        ],
        mac: { primary: 266, secondary: [
          521,
          2087
          /* KeyCode.KeyI */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    const n = kt.get(t);
    if (!n)
      return;
    let s;
    i && typeof i == "object" && i.auto === !0 && (s = !0), n.triggerSuggest(void 0, s, void 0);
  }
}
ma.id = "editor.action.triggerSuggest";
Z(
  kt.ID,
  kt,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
x(ma);
const _t = 190, Ze = bt.bindToContribution(kt.get);
B(new Ze({
  id: "acceptSelectedSuggestion",
  precondition: L.and(U.Visible, U.HasFocusedSuggestion),
  handler(r) {
    r.acceptSelectedSuggestion(!0, !1);
  },
  kbOpts: [{
    // normal tab
    primary: 2,
    kbExpr: L.and(U.Visible, b.textInputFocus),
    weight: _t
  }, {
    // accept on enter has special rules
    primary: 3,
    kbExpr: L.and(U.Visible, b.textInputFocus, U.AcceptSuggestionsOnEnter, U.MakesTextEdit),
    weight: _t
  }],
  menuOpts: [{
    menuId: tn,
    title: g("accept.insert", "Insert"),
    group: "left",
    order: 1,
    when: U.HasInsertAndReplaceRange.toNegated()
  }, {
    menuId: tn,
    title: g("accept.insert", "Insert"),
    group: "left",
    order: 1,
    when: L.and(U.HasInsertAndReplaceRange, U.InsertMode.isEqualTo("insert"))
  }, {
    menuId: tn,
    title: g("accept.replace", "Replace"),
    group: "left",
    order: 1,
    when: L.and(U.HasInsertAndReplaceRange, U.InsertMode.isEqualTo("replace"))
  }]
}));
B(new Ze({
  id: "acceptAlternativeSelectedSuggestion",
  precondition: L.and(U.Visible, b.textInputFocus, U.HasFocusedSuggestion),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 1027,
    secondary: [
      1026
      /* KeyCode.Tab */
    ]
  },
  handler(r) {
    r.acceptSelectedSuggestion(!1, !0);
  },
  menuOpts: [{
    menuId: tn,
    group: "left",
    order: 2,
    when: L.and(U.HasInsertAndReplaceRange, U.InsertMode.isEqualTo("insert")),
    title: g("accept.replace", "Replace")
  }, {
    menuId: tn,
    group: "left",
    order: 2,
    when: L.and(U.HasInsertAndReplaceRange, U.InsertMode.isEqualTo("replace")),
    title: g("accept.insert", "Insert")
  }]
}));
de.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
B(new Ze({
  id: "hideSuggestWidget",
  precondition: U.Visible,
  handler: (r) => r.cancelSuggestWidget(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
B(new Ze({
  id: "selectNextSuggestion",
  precondition: L.and(U.Visible, L.or(U.MultipleSuggestions, U.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectNextSuggestion(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 18,
    secondary: [
      2066
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      2066,
      300
      /* KeyCode.KeyN */
    ] }
  }
}));
B(new Ze({
  id: "selectNextPageSuggestion",
  precondition: L.and(U.Visible, L.or(U.MultipleSuggestions, U.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectNextPageSuggestion(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 12,
    secondary: [
      2060
      /* KeyCode.PageDown */
    ]
  }
}));
B(new Ze({
  id: "selectLastSuggestion",
  precondition: L.and(U.Visible, L.or(U.MultipleSuggestions, U.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectLastSuggestion()
}));
B(new Ze({
  id: "selectPrevSuggestion",
  precondition: L.and(U.Visible, L.or(U.MultipleSuggestions, U.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectPrevSuggestion(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 16,
    secondary: [
      2064
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      2064,
      302
      /* KeyCode.KeyP */
    ] }
  }
}));
B(new Ze({
  id: "selectPrevPageSuggestion",
  precondition: L.and(U.Visible, L.or(U.MultipleSuggestions, U.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectPrevPageSuggestion(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 11,
    secondary: [
      2059
      /* KeyCode.PageUp */
    ]
  }
}));
B(new Ze({
  id: "selectFirstSuggestion",
  precondition: L.and(U.Visible, L.or(U.MultipleSuggestions, U.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectFirstSuggestion()
}));
B(new Ze({
  id: "focusSuggestion",
  precondition: L.and(U.Visible, U.HasFocusedSuggestion.negate()),
  handler: (r) => r.focusSuggestion(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 2058,
    secondary: [
      2087
      /* KeyCode.KeyI */
    ],
    mac: { primary: 266, secondary: [
      2087
      /* KeyCode.KeyI */
    ] }
  }
}));
B(new Ze({
  id: "focusAndAcceptSuggestion",
  precondition: L.and(U.Visible, U.HasFocusedSuggestion.negate()),
  handler: (r) => {
    r.focusSuggestion(), r.acceptSelectedSuggestion(!0, !1);
  }
}));
B(new Ze({
  id: "toggleSuggestionDetails",
  precondition: L.and(U.Visible, U.HasFocusedSuggestion),
  handler: (r) => r.toggleSuggestionDetails(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 2058,
    secondary: [
      2087
      /* KeyCode.KeyI */
    ],
    mac: { primary: 266, secondary: [
      2087
      /* KeyCode.KeyI */
    ] }
  },
  menuOpts: [{
    menuId: tn,
    group: "right",
    order: 1,
    when: L.and(U.DetailsVisible, U.CanResolve),
    title: g("detail.more", "show less")
  }, {
    menuId: tn,
    group: "right",
    order: 1,
    when: L.and(U.DetailsVisible.toNegated(), U.CanResolve),
    title: g("detail.less", "show more")
  }]
}));
B(new Ze({
  id: "toggleExplainMode",
  precondition: U.Visible,
  handler: (r) => r.toggleExplainMode(),
  kbOpts: {
    weight: 100,
    primary: 2138
  }
}));
B(new Ze({
  id: "toggleSuggestionFocus",
  precondition: U.Visible,
  handler: (r) => r.toggleSuggestionFocus(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 2570,
    mac: {
      primary: 778
      /* KeyCode.Space */
    }
  }
}));
B(new Ze({
  id: "insertBestCompletion",
  precondition: L.and(b.textInputFocus, L.equals("config.editor.tabCompletion", "on"), Tr.AtEnd, U.Visible.toNegated(), Xn.OtherSuggestions.toNegated(), Me.InSnippetMode.toNegated()),
  handler: (r, e) => {
    r.triggerSuggestAndAcceptBest(f_(e) ? { fallback: "tab", ...e } : { fallback: "tab" });
  },
  kbOpts: {
    weight: _t,
    primary: 2
    /* KeyCode.Tab */
  }
}));
B(new Ze({
  id: "insertNextSuggestion",
  precondition: L.and(b.textInputFocus, L.equals("config.editor.tabCompletion", "on"), Xn.OtherSuggestions, U.Visible.toNegated(), Me.InSnippetMode.toNegated()),
  handler: (r) => r.acceptNextSuggestion(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 2
    /* KeyCode.Tab */
  }
}));
B(new Ze({
  id: "insertPrevSuggestion",
  precondition: L.and(b.textInputFocus, L.equals("config.editor.tabCompletion", "on"), Xn.OtherSuggestions, U.Visible.toNegated(), Me.InSnippetMode.toNegated()),
  handler: (r) => r.acceptPrevSuggestion(),
  kbOpts: {
    weight: _t,
    kbExpr: b.textInputFocus,
    primary: 1026
    /* KeyCode.Tab */
  }
}));
x(class extends D {
  constructor() {
    super({
      id: "editor.action.resetSuggestSize",
      label: g("suggest.reset.label", "Reset Suggest Widget Size"),
      alias: "Reset Suggest Widget Size",
      precondition: void 0
    });
  }
  run(r, e) {
    var t;
    (t = kt.get(e)) === null || t === void 0 || t.resetWidgetSize();
  }
});
class MN extends P {
  get selectedItem() {
    return this._selectedItem;
  }
  constructor(e, t, i, n) {
    super(), this.editor = e, this.suggestControllerPreselector = t, this.checkModelVersion = i, this.onWillAccept = n, this.isSuggestWidgetVisible = !1, this.isShiftKeyPressed = !1, this._isActive = !1, this._currentSuggestItemInfo = void 0, this._selectedItem = ai(this, void 0), this._register(e.onKeyDown((o) => {
      o.shiftKey && !this.isShiftKeyPressed && (this.isShiftKeyPressed = !0, this.update(this._isActive));
    })), this._register(e.onKeyUp((o) => {
      o.shiftKey && this.isShiftKeyPressed && (this.isShiftKeyPressed = !1, this.update(this._isActive));
    }));
    const s = kt.get(this.editor);
    if (s) {
      this._register(s.registerSelector({
        priority: 100,
        select: (l, d, c) => {
          var h;
          ht((v) => this.checkModelVersion(v));
          const u = this.editor.getModel();
          if (!u)
            return -1;
          const p = (h = this.suggestControllerPreselector()) === null || h === void 0 ? void 0 : h.removeCommonPrefix(u);
          if (!p)
            return -1;
          const f = F.lift(d), m = c.map((v, C) => {
            const y = rr.fromSuggestion(s, u, f, v, this.isShiftKeyPressed).toSingleTextEdit().removeCommonPrefix(u), I = p.augments(y);
            return { index: C, valid: I, prefixLength: y.text.length, suggestItem: v };
          }).filter((v) => v && v.valid && v.prefixLength > 0), _ = qw(m, M_((v) => v.prefixLength, E_));
          return _ ? _.index : -1;
        }
      }));
      let o = !1;
      const a = () => {
        o || (o = !0, this._register(s.widget.value.onDidShow(() => {
          this.isSuggestWidgetVisible = !0, this.update(!0);
        })), this._register(s.widget.value.onDidHide(() => {
          this.isSuggestWidgetVisible = !1, this.update(!1);
        })), this._register(s.widget.value.onDidFocus(() => {
          this.isSuggestWidgetVisible = !0, this.update(!0);
        })));
      };
      this._register(De.once(s.model.onDidTrigger)((l) => {
        a();
      })), this._register(s.onWillInsertSuggestItem((l) => {
        const d = this.editor.getPosition(), c = this.editor.getModel();
        if (!d || !c)
          return;
        const h = rr.fromSuggestion(s, c, d, l.item, this.isShiftKeyPressed);
        this.onWillAccept(h);
      }));
    }
    this.update(this._isActive);
  }
  update(e) {
    const t = this.getSuggestItemInfo();
    (this._isActive !== e || !EN(this._currentSuggestItemInfo, t)) && (this._isActive = e, this._currentSuggestItemInfo = t, ht((i) => {
      this.checkModelVersion(i), this._selectedItem.set(this._isActive ? this._currentSuggestItemInfo : void 0, i);
    }));
  }
  getSuggestItemInfo() {
    const e = kt.get(this.editor);
    if (!e || !this.isSuggestWidgetVisible)
      return;
    const t = e.widget.value.getFocusedItem(), i = this.editor.getPosition(), n = this.editor.getModel();
    if (!(!t || !i || !n))
      return rr.fromSuggestion(e, n, i, t.item, this.isShiftKeyPressed);
  }
  stopForceRenderingAbove() {
    const e = kt.get(this.editor);
    e == null || e.stopForceRenderingAbove();
  }
  forceRenderingAbove() {
    const e = kt.get(this.editor);
    e == null || e.forceRenderingAbove();
  }
}
class rr {
  static fromSuggestion(e, t, i, n, s) {
    let { insertText: o } = n.completion, a = !1;
    if (n.completion.insertTextRules & 4) {
      const d = new Un().parse(o);
      d.children.length < 100 && jl.adjustWhitespace(t, i, !0, d), o = d.toString(), a = !0;
    }
    const l = e.getOverwriteInfo(n, s);
    return new rr(S.fromPositions(i.delta(0, -l.overwriteBefore), i.delta(0, Math.max(l.overwriteAfter, 0))), o, n.completion.kind, a);
  }
  constructor(e, t, i, n) {
    this.range = e, this.insertText = t, this.completionItemKind = i, this.isSnippetText = n;
  }
  equals(e) {
    return this.range.equalsRange(e.range) && this.insertText === e.insertText && this.completionItemKind === e.completionItemKind && this.isSnippetText === e.isSnippetText;
  }
  toSelectedSuggestionInfo() {
    return new Kw(this.range, this.insertText, this.completionItemKind, this.isSnippetText);
  }
  toSingleTextEdit() {
    return new gn(this.range, this.insertText);
  }
}
function EN(r, e) {
  return r === e ? !0 : !r || !e ? !1 : r.equals(e);
}
var TN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Hi = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, lu;
let vt = lu = class extends P {
  static get(e) {
    return e.getContribution(lu.ID);
  }
  constructor(e, t, i, n, s, o, a, l, d) {
    super(), this.editor = e, this._instantiationService = t, this._contextKeyService = i, this._configurationService = n, this._commandService = s, this._debounceService = o, this._languageFeaturesService = a, this._accessibilitySignalService = l, this._keybindingService = d, this.model = this._register(Ll("inlineCompletionModel", void 0)), this._textModelVersionId = ai(this, -1), this._positions = ai(this, [new F(1, 1)]), this._suggestWidgetAdaptor = this._register(new MN(this.editor, () => {
      var p, f;
      return (f = (p = this.model.get()) === null || p === void 0 ? void 0 : p.selectedInlineCompletion.get()) === null || f === void 0 ? void 0 : f.toSingleTextEdit(void 0);
    }, (p) => this.updateObservables(p, dt.Other), (p) => {
      ht((f) => {
        var m;
        this.updateObservables(f, dt.Other), (m = this.model.get()) === null || m === void 0 || m.handleSuggestAccepted(p);
      });
    })), this._enabled = it(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).enabled), this._fontFamily = it(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).fontFamily), this._ghostTexts = Xe(this, (p) => {
      var f;
      const m = this.model.read(p);
      return (f = m == null ? void 0 : m.ghostTexts.read(p)) !== null && f !== void 0 ? f : [];
    }), this._stablizedGhostTexts = AN(this._ghostTexts, this._store), this._ghostTextWidgets = Gw(this, this._stablizedGhostTexts, (p, f) => f.add(this._instantiationService.createInstance(Jh, this.editor, {
      ghostText: p,
      minReservedLineCount: Nn(0),
      targetTextModel: this.model.map((m) => m == null ? void 0 : m.textModel)
    }))).recomputeInitiallyAndOnChange(this._store), this._debounceValue = this._debounceService.for(this._languageFeaturesService.inlineCompletionsProvider, "InlineCompletionsDebounce", { min: 50, max: 50 }), this._playAccessibilitySignal = k_(this), this._isReadonly = it(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      91
      /* EditorOption.readOnly */
    )), this._textModel = it(this.editor.onDidChangeModel, () => this.editor.getModel()), this._textModelIfWritable = Xe((p) => this._isReadonly.read(p) ? void 0 : this._textModel.read(p)), this._register(new ke(this._contextKeyService, this.model)), this._register(Ne((p) => {
      const f = this._textModelIfWritable.read(p);
      ht((m) => {
        if (this.model.set(void 0, m), this.updateObservables(m, dt.Other), f) {
          const _ = t.createInstance(tu, f, this._suggestWidgetAdaptor.selectedItem, this._textModelVersionId, this._positions, this._debounceValue, it(e.onDidChangeConfiguration, () => e.getOption(
            118
            /* EditorOption.suggest */
          ).preview), it(e.onDidChangeConfiguration, () => e.getOption(
            118
            /* EditorOption.suggest */
          ).previewMode), it(e.onDidChangeConfiguration, () => e.getOption(
            62
            /* EditorOption.inlineSuggest */
          ).mode), this._enabled);
          this.model.set(_, m);
        }
      });
    }));
    const c = this._register(T_());
    this._register(Ne((p) => {
      const f = this._fontFamily.read(p);
      c.setStyle(f === "" || f === "default" ? "" : `
.monaco-editor .ghost-text-decoration,
.monaco-editor .ghost-text-decoration-preview,
.monaco-editor .ghost-text {
	font-family: ${f};
}`);
    }));
    const h = (p) => {
      var f;
      return p.isUndoing ? dt.Undo : p.isRedoing ? dt.Redo : !((f = this.model.get()) === null || f === void 0) && f.isAcceptingPartially ? dt.AcceptWord : dt.Other;
    };
    this._register(e.onDidChangeModelContent((p) => ht((f) => (
      /** @description InlineCompletionsController.onDidChangeModelContent */
      this.updateObservables(f, h(p))
    )))), this._register(e.onDidChangeCursorPosition((p) => ht((f) => {
      var m;
      this.updateObservables(f, dt.Other), (p.reason === 3 || p.source === "api") && ((m = this.model.get()) === null || m === void 0 || m.stop(f));
    }))), this._register(e.onDidType(() => ht((p) => {
      var f;
      this.updateObservables(p, dt.Other), this._enabled.get() && ((f = this.model.get()) === null || f === void 0 || f.trigger(p));
    }))), this._register(this._commandService.onDidExecuteCommand((p) => {
      (/* @__PURE__ */ new Set([
        al.Tab.id,
        al.DeleteLeft.id,
        al.DeleteRight.id,
        bb,
        "acceptSelectedSuggestion"
      ])).has(p.commandId) && e.hasTextFocus() && this._enabled.get() && ht((m) => {
        var _;
        (_ = this.model.get()) === null || _ === void 0 || _.trigger(m);
      });
    })), this._register(this.editor.onDidBlurEditorWidget(() => {
      this._contextKeyService.getContextKeyValue("accessibleViewIsShown") || this._configurationService.getValue("editor.inlineSuggest.keepOnBlur") || e.getOption(
        62
        /* EditorOption.inlineSuggest */
      ).keepOnBlur || hn.dropDownVisible || ht((p) => {
        var f;
        (f = this.model.get()) === null || f === void 0 || f.stop(p);
      });
    })), this._register(Ne((p) => {
      var f;
      const m = (f = this.model.read(p)) === null || f === void 0 ? void 0 : f.state.read(p);
      m != null && m.suggestItem ? m.primaryGhostText.lineCount >= 2 && this._suggestWidgetAdaptor.forceRenderingAbove() : this._suggestWidgetAdaptor.stopForceRenderingAbove();
    })), this._register(pe(() => {
      this._suggestWidgetAdaptor.stopForceRenderingAbove();
    }));
    let u;
    this._register(Zw({
      handleChange: (p, f) => (p.didChange(this._playAccessibilitySignal) && (u = void 0), !0)
    }, async (p) => {
      this._playAccessibilitySignal.read(p);
      const f = this.model.read(p), m = f == null ? void 0 : f.state.read(p);
      if (!f || !m || !m.inlineCompletion) {
        u = void 0;
        return;
      }
      if (m.inlineCompletion.semanticId !== u) {
        u = m.inlineCompletion.semanticId;
        const _ = f.textModel.getLineContent(m.primaryGhostText.lineNumber);
        this._accessibilitySignalService.playSignal(v_.inlineSuggestion).then(() => {
          this.editor.getOption(
            8
            /* EditorOption.screenReaderAnnounceInlineSuggestion */
          ) && this.provideScreenReaderUpdate(m.primaryGhostText.renderForScreenReader(_));
        });
      }
    })), this._register(new Ah(this.editor, this.model, this._instantiationService)), this._register(this._configurationService.onDidChangeConfiguration((p) => {
      p.affectsConfiguration("accessibility.verbosity.inlineCompletions") && this.editor.updateOptions({ inlineCompletionsAccessibilityVerbose: this._configurationService.getValue("accessibility.verbosity.inlineCompletions") });
    })), this.editor.updateOptions({ inlineCompletionsAccessibilityVerbose: this._configurationService.getValue("accessibility.verbosity.inlineCompletions") });
  }
  playAccessibilitySignal(e) {
    this._playAccessibilitySignal.trigger(e);
  }
  provideScreenReaderUpdate(e) {
    const t = this._contextKeyService.getContextKeyValue("accessibleViewIsShown"), i = this._keybindingService.lookupKeybinding("editor.action.accessibleView");
    let n;
    !t && i && this.editor.getOption(
      148
      /* EditorOption.inlineCompletionsAccessibilityVerbose */
    ) && (n = g("showAccessibleViewHint", "Inspect this in the accessible view ({0})", i.getAriaLabel())), n ? xt(e + ", " + n) : xt(e);
  }
  /**
   * Copies over the relevant state from the text model to observables.
   * This solves all kind of eventing issues, as we make sure we always operate on the latest state,
   * regardless of who calls into us.
   */
  updateObservables(e, t) {
    var i, n, s;
    const o = this.editor.getModel();
    this._textModelVersionId.set((i = o == null ? void 0 : o.getVersionId()) !== null && i !== void 0 ? i : -1, e, t), this._positions.set((s = (n = this.editor.getSelections()) === null || n === void 0 ? void 0 : n.map((a) => a.getPosition())) !== null && s !== void 0 ? s : [new F(1, 1)], e);
  }
  shouldShowHoverAt(e) {
    var t;
    const i = (t = this.model.get()) === null || t === void 0 ? void 0 : t.primaryGhostText.get();
    return i ? i.parts.some((n) => e.containsPosition(new F(i.lineNumber, n.column))) : !1;
  }
  shouldShowHoverAtViewZone(e) {
    var t, i;
    return (i = (t = this._ghostTextWidgets.get()[0]) === null || t === void 0 ? void 0 : t.ownsViewZone(e)) !== null && i !== void 0 ? i : !1;
  }
};
vt.ID = "editor.contrib.inlineCompletionsController";
vt = lu = TN([
  Hi(1, q),
  Hi(2, ee),
  Hi(3, he),
  Hi(4, Fe),
  Hi(5, Pt),
  Hi(6, V),
  Hi(7, __),
  Hi(8, xe)
], vt);
function AN(r, e) {
  const t = ai("result", []), i = [];
  return e.add(Ne((n) => {
    const s = r.read(n);
    ht((o) => {
      if (s.length !== i.length) {
        i.length = s.length;
        for (let a = 0; a < i.length; a++)
          i[a] || (i[a] = ai("item", s[a]));
        t.set([...i], o);
      }
      i.forEach((a, l) => a.set(s[l], o));
    });
  })), t;
}
class qd extends D {
  constructor() {
    super({
      id: qd.ID,
      label: g("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
      alias: "Show Next Inline Suggestion",
      precondition: L.and(b.writable, ke.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 606
      }
    });
  }
  async run(e, t) {
    var i;
    const n = vt.get(t);
    (i = n == null ? void 0 : n.model.get()) === null || i === void 0 || i.next();
  }
}
qd.ID = Sb;
class Kd extends D {
  constructor() {
    super({
      id: Kd.ID,
      label: g("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
      alias: "Show Previous Inline Suggestion",
      precondition: L.and(b.writable, ke.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 604
      }
    });
  }
  async run(e, t) {
    var i;
    const n = vt.get(t);
    (i = n == null ? void 0 : n.model.get()) === null || i === void 0 || i.previous();
  }
}
Kd.ID = Cb;
class ON extends D {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.trigger",
      label: g("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
      alias: "Trigger Inline Suggestion",
      precondition: b.writable
    });
  }
  async run(e, t) {
    const i = vt.get(t);
    await Xw(async (n) => {
      var s;
      await ((s = i == null ? void 0 : i.model.get()) === null || s === void 0 ? void 0 : s.triggerExplicitly(n)), i == null || i.playAccessibilitySignal(n);
    });
  }
}
class FN extends D {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextWord",
      label: g("action.inlineSuggest.acceptNextWord", "Accept Next Word Of Inline Suggestion"),
      alias: "Accept Next Word Of Inline Suggestion",
      precondition: L.and(b.writable, ke.inlineSuggestionVisible),
      kbOpts: {
        weight: 101,
        primary: 2065,
        kbExpr: L.and(b.writable, ke.inlineSuggestionVisible)
      },
      menuOpts: [{
        menuId: E.InlineSuggestionToolbar,
        title: g("acceptWord", "Accept Word"),
        group: "primary",
        order: 2
      }]
    });
  }
  async run(e, t) {
    var i;
    const n = vt.get(t);
    await ((i = n == null ? void 0 : n.model.get()) === null || i === void 0 ? void 0 : i.acceptNextWord(n.editor));
  }
}
class WN extends D {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextLine",
      label: g("action.inlineSuggest.acceptNextLine", "Accept Next Line Of Inline Suggestion"),
      alias: "Accept Next Line Of Inline Suggestion",
      precondition: L.and(b.writable, ke.inlineSuggestionVisible),
      kbOpts: {
        weight: 101
      },
      menuOpts: [{
        menuId: E.InlineSuggestionToolbar,
        title: g("acceptLine", "Accept Line"),
        group: "secondary",
        order: 2
      }]
    });
  }
  async run(e, t) {
    var i;
    const n = vt.get(t);
    await ((i = n == null ? void 0 : n.model.get()) === null || i === void 0 ? void 0 : i.acceptNextLine(n.editor));
  }
}
class HN extends D {
  constructor() {
    super({
      id: bb,
      label: g("action.inlineSuggest.accept", "Accept Inline Suggestion"),
      alias: "Accept Inline Suggestion",
      precondition: ke.inlineSuggestionVisible,
      menuOpts: [{
        menuId: E.InlineSuggestionToolbar,
        title: g("accept", "Accept"),
        group: "primary",
        order: 1
      }],
      kbOpts: {
        primary: 2,
        weight: 200,
        kbExpr: L.and(ke.inlineSuggestionVisible, b.tabMovesFocus.toNegated(), ke.inlineSuggestionHasIndentationLessThanTabSize, U.Visible.toNegated(), b.hoverFocused.toNegated())
      }
    });
  }
  async run(e, t) {
    var i;
    const n = vt.get(t);
    n && ((i = n.model.get()) === null || i === void 0 || i.accept(n.editor), n.editor.focus());
  }
}
class Gd extends D {
  constructor() {
    super({
      id: Gd.ID,
      label: g("action.inlineSuggest.hide", "Hide Inline Suggestion"),
      alias: "Hide Inline Suggestion",
      precondition: ke.inlineSuggestionVisible,
      kbOpts: {
        weight: 100,
        primary: 9
      }
    });
  }
  async run(e, t) {
    const i = vt.get(t);
    ht((n) => {
      var s;
      (s = i == null ? void 0 : i.model.get()) === null || s === void 0 || s.stop(n);
    });
  }
}
Gd.ID = "editor.action.inlineSuggest.hide";
class Zd extends rt {
  constructor() {
    super({
      id: Zd.ID,
      title: g("action.inlineSuggest.alwaysShowToolbar", "Always Show Toolbar"),
      f1: !1,
      precondition: void 0,
      menu: [{
        id: E.InlineSuggestionToolbar,
        group: "secondary",
        order: 10
      }],
      toggled: L.equals("config.editor.inlineSuggest.showToolbar", "always")
    });
  }
  async run(e, t) {
    const i = e.get(he), s = i.getValue("editor.inlineSuggest.showToolbar") === "always" ? "onHover" : "always";
    i.updateValue("editor.inlineSuggest.showToolbar", s);
  }
}
Zd.ID = "editor.action.inlineSuggest.toggleAlwaysShowToolbar";
var BN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Wo = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class VN {
  constructor(e, t, i) {
    this.owner = e, this.range = t, this.controller = i;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let du = class {
  constructor(e, t, i, n, s, o) {
    this._editor = e, this._languageService = t, this._openerService = i, this.accessibilityService = n, this._instantiationService = s, this._telemetryService = o, this.hoverOrdinal = 4;
  }
  suggestHoverAnchor(e) {
    const t = vt.get(this._editor);
    if (!t)
      return null;
    const i = e.target;
    if (i.type === 8) {
      const n = i.detail;
      if (t.shouldShowHoverAtViewZone(n.viewZoneId))
        return new An(1e3, this, S.fromPositions(this._editor.getModel().validatePosition(n.positionBefore || n.position)), e.event.posx, e.event.posy, !1);
    }
    return i.type === 7 && t.shouldShowHoverAt(i.range) ? new An(1e3, this, i.range, e.event.posx, e.event.posy, !1) : i.type === 6 && i.detail.mightBeForeignElement && t.shouldShowHoverAt(i.range) ? new An(1e3, this, i.range, e.event.posx, e.event.posy, !1) : null;
  }
  computeSync(e, t) {
    if (this._editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).showToolbar !== "onHover")
      return [];
    const i = vt.get(this._editor);
    return i && i.shouldShowHoverAt(e.range) ? [new VN(this, e.range, i)] : [];
  }
  renderHoverParts(e, t) {
    const i = new M(), n = t[0];
    this._telemetryService.publicLog2("inlineCompletionHover.shown"), this.accessibilityService.isScreenReaderOptimized() && !this._editor.getOption(
      8
      /* EditorOption.screenReaderAnnounceInlineSuggestion */
    ) && this.renderScreenReaderText(e, n, i);
    const s = n.controller.model.get(), o = this._instantiationService.createInstance(hn, this._editor, !1, Nn(null), s.selectedInlineCompletionIndex, s.inlineCompletionsCount, s.selectedInlineCompletion.map((a) => {
      var l;
      return (l = a == null ? void 0 : a.inlineCompletion.source.inlineCompletions.commands) !== null && l !== void 0 ? l : [];
    }));
    return e.fragment.appendChild(o.getDomNode()), s.triggerExplicitly(), i.add(o), i;
  }
  renderScreenReaderText(e, t, i) {
    const n = O, s = n("div.hover-row.markdown-hover"), o = A(s, n("div.hover-contents", { "aria-live": "assertive" })), a = i.add(new po({ editor: this._editor }, this._languageService, this._openerService)), l = (d) => {
      i.add(a.onDidRenderAsync(() => {
        o.className = "hover-contents code-hover-contents", e.onContentsChanged();
      }));
      const c = g("inlineSuggestionFollows", "Suggestion:"), h = i.add(a.render(new Ue().appendText(c).appendCodeblock("text", d)));
      o.replaceChildren(h.element);
    };
    i.add(Ne((d) => {
      var c;
      const h = (c = t.controller.model.read(d)) === null || c === void 0 ? void 0 : c.primaryGhostText.read(d);
      if (h) {
        const u = this._editor.getModel().getLineContent(h.lineNumber);
        l(h.renderForScreenReader(u));
      } else
        Cl(o);
    })), e.fragment.appendChild(s);
  }
};
du = BN([
  Wo(1, Et),
  Wo(2, Gt),
  Wo(3, og),
  Wo(4, q),
  Wo(5, ui)
], du);
Z(
  vt.ID,
  vt,
  3
  /* EditorContributionInstantiation.Eventually */
);
x(ON);
x(qd);
x(Kd);
x(FN);
x(WN);
x(HN);
x(Gd);
ne(Zd);
bn.register(du);
function tt(r, e) {
  let t = 0;
  for (let i = 0; i < r.length; i++)
    r.charAt(i) === "	" ? t += e : t++;
  return t;
}
function ar(r, e, t) {
  r = r < 0 ? 0 : r;
  let i = "";
  if (!t) {
    const n = Math.floor(r / e);
    r = r % e;
    for (let s = 0; s < n; s++)
      i += "	";
  }
  for (let n = 0; n < r; n++)
    i += " ";
  return i;
}
var UN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, zN = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
function tC(r, e, t, i, n) {
  if (r.getLineCount() === 1 && r.getLineMaxColumn(1) === 1)
    return [];
  const s = e.getLanguageConfiguration(r.getLanguageId()).indentationRules;
  if (!s)
    return [];
  for (i = Math.min(i, r.getLineCount()); t <= i && s.unIndentedLinePattern; ) {
    const _ = r.getLineContent(t);
    if (!s.unIndentedLinePattern.test(_))
      break;
    t++;
  }
  if (t > i - 1)
    return [];
  const { tabSize: o, indentSize: a, insertSpaces: l } = r.getOptions(), d = (_, v) => (v = v || 1, Xs.shiftIndent(_, _.length + v, o, a, l)), c = (_, v) => (v = v || 1, Xs.unshiftIndent(_, _.length + v, o, a, l)), h = [];
  let u;
  const p = r.getLineContent(t);
  let f = p;
  if (n != null) {
    u = n;
    const _ = Ee(p);
    f = u + p.substring(_.length), s.decreaseIndentPattern && s.decreaseIndentPattern.test(f) && (u = c(u), f = u + p.substring(_.length)), p !== f && h.push(ue.replaceMove(new z(t, 1, t, _.length + 1), zp(u, a, l)));
  } else
    u = Ee(p);
  let m = u;
  s.increaseIndentPattern && s.increaseIndentPattern.test(f) ? (m = d(m), u = d(u)) : s.indentNextLinePattern && s.indentNextLinePattern.test(f) && (m = d(m)), t++;
  for (let _ = t; _ <= i; _++) {
    const v = r.getLineContent(_), C = Ee(v), w = m + v.substring(C.length);
    s.decreaseIndentPattern && s.decreaseIndentPattern.test(w) && (m = c(m), u = c(u)), C !== m && h.push(ue.replaceMove(new z(_, 1, _, C.length + 1), zp(m, a, l))), !(s.unIndentedLinePattern && s.unIndentedLinePattern.test(v)) && (s.increaseIndentPattern && s.increaseIndentPattern.test(w) ? (u = d(u), m = u) : s.indentNextLinePattern && s.indentNextLinePattern.test(w) ? m = d(m) : m = u);
  }
  return h;
}
class Xd extends D {
  constructor() {
    super({
      id: Xd.ID,
      label: g("indentationToSpaces", "Convert Indentation to Spaces"),
      alias: "Convert Indentation to Spaces",
      precondition: b.writable
    });
  }
  run(e, t) {
    const i = t.getModel();
    if (!i)
      return;
    const n = i.getOptions(), s = t.getSelection();
    if (!s)
      return;
    const o = new KN(s, n.tabSize);
    t.pushUndoStop(), t.executeCommands(this.id, [o]), t.pushUndoStop(), i.updateOptions({
      insertSpaces: !0
    });
  }
}
Xd.ID = "editor.action.indentationToSpaces";
class Qd extends D {
  constructor() {
    super({
      id: Qd.ID,
      label: g("indentationToTabs", "Convert Indentation to Tabs"),
      alias: "Convert Indentation to Tabs",
      precondition: b.writable
    });
  }
  run(e, t) {
    const i = t.getModel();
    if (!i)
      return;
    const n = i.getOptions(), s = t.getSelection();
    if (!s)
      return;
    const o = new GN(s, n.tabSize);
    t.pushUndoStop(), t.executeCommands(this.id, [o]), t.pushUndoStop(), i.updateOptions({
      insertSpaces: !1
    });
  }
}
Qd.ID = "editor.action.indentationToTabs";
class sp extends D {
  constructor(e, t, i) {
    super(i), this.insertSpaces = e, this.displaySizeOnly = t;
  }
  run(e, t) {
    const i = e.get(Ei), n = e.get(Ge), s = t.getModel();
    if (!s)
      return;
    const o = n.getCreationOptions(s.getLanguageId(), s.uri, s.isForSimpleWidget), a = s.getOptions(), l = [1, 2, 3, 4, 5, 6, 7, 8].map((c) => ({
      id: c.toString(),
      label: c.toString(),
      // add description for tabSize value set in the configuration
      description: c === o.tabSize && c === a.tabSize ? g("configuredTabSize", "Configured Tab Size") : c === o.tabSize ? g("defaultTabSize", "Default Tab Size") : c === a.tabSize ? g("currentTabSize", "Current Tab Size") : void 0
    })), d = Math.min(s.getOptions().tabSize - 1, 7);
    setTimeout(
      () => {
        i.pick(l, { placeHolder: g({ key: "selectTabWidth", comment: ["Tab corresponds to the tab key"] }, "Select Tab Size for Current File"), activeItem: l[d] }).then((c) => {
          if (c && s && !s.isDisposed()) {
            const h = parseInt(c.label, 10);
            this.displaySizeOnly ? s.updateOptions({
              tabSize: h
            }) : s.updateOptions({
              tabSize: h,
              indentSize: h,
              insertSpaces: this.insertSpaces
            });
          }
        });
      },
      50
      /* quick input is sensitive to being opened so soon after another */
    );
  }
}
class Yd extends sp {
  constructor() {
    super(!1, !1, {
      id: Yd.ID,
      label: g("indentUsingTabs", "Indent Using Tabs"),
      alias: "Indent Using Tabs",
      precondition: void 0
    });
  }
}
Yd.ID = "editor.action.indentUsingTabs";
class Jd extends sp {
  constructor() {
    super(!0, !1, {
      id: Jd.ID,
      label: g("indentUsingSpaces", "Indent Using Spaces"),
      alias: "Indent Using Spaces",
      precondition: void 0
    });
  }
}
Jd.ID = "editor.action.indentUsingSpaces";
class ec extends sp {
  constructor() {
    super(!0, !0, {
      id: ec.ID,
      label: g("changeTabDisplaySize", "Change Tab Display Size"),
      alias: "Change Tab Display Size",
      precondition: void 0
    });
  }
}
ec.ID = "editor.action.changeTabDisplaySize";
class tc extends D {
  constructor() {
    super({
      id: tc.ID,
      label: g("detectIndentation", "Detect Indentation from Content"),
      alias: "Detect Indentation from Content",
      precondition: void 0
    });
  }
  run(e, t) {
    const i = e.get(Ge), n = t.getModel();
    if (!n)
      return;
    const s = i.getCreationOptions(n.getLanguageId(), n.uri, n.isForSimpleWidget);
    n.detectIndentation(s.insertSpaces, s.tabSize);
  }
}
tc.ID = "editor.action.detectIndentation";
class $N extends D {
  constructor() {
    super({
      id: "editor.action.reindentlines",
      label: g("editor.reindentlines", "Reindent Lines"),
      alias: "Reindent Lines",
      precondition: b.writable
    });
  }
  run(e, t) {
    const i = e.get(fe), n = t.getModel();
    if (!n)
      return;
    const s = tC(n, i, 1, n.getLineCount());
    s.length > 0 && (t.pushUndoStop(), t.executeEdits(this.id, s), t.pushUndoStop());
  }
}
class jN extends D {
  constructor() {
    super({
      id: "editor.action.reindentselectedlines",
      label: g("editor.reindentselectedlines", "Reindent Selected Lines"),
      alias: "Reindent Selected Lines",
      precondition: b.writable
    });
  }
  run(e, t) {
    const i = e.get(fe), n = t.getModel();
    if (!n)
      return;
    const s = t.getSelections();
    if (s === null)
      return;
    const o = [];
    for (const a of s) {
      let l = a.startLineNumber, d = a.endLineNumber;
      if (l !== d && a.endColumn === 1 && d--, l === 1) {
        if (l === d)
          continue;
      } else
        l--;
      const c = tC(n, i, l, d);
      o.push(...c);
    }
    o.length > 0 && (t.pushUndoStop(), t.executeEdits(this.id, o), t.pushUndoStop());
  }
}
class qN {
  constructor(e, t) {
    this._initialSelection = t, this._edits = [], this._selectionId = null;
    for (const i of e)
      i.range && typeof i.text == "string" && this._edits.push(i);
  }
  getEditOperations(e, t) {
    for (const n of this._edits)
      t.addEditOperation(S.lift(n.range), n.text);
    let i = !1;
    Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty() && (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber ? (i = !0, this._selectionId = t.trackSelection(this._initialSelection, !0)) : this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber && (i = !0, this._selectionId = t.trackSelection(this._initialSelection, !1))), i || (this._selectionId = t.trackSelection(this._initialSelection));
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
let Or = class {
  constructor(e, t) {
    this.editor = e, this._languageConfigurationService = t, this.callOnDispose = new M(), this.callOnModel = new M(), this.callOnDispose.add(e.onDidChangeConfiguration(() => this.update())), this.callOnDispose.add(e.onDidChangeModel(() => this.update())), this.callOnDispose.add(e.onDidChangeModelLanguage(() => this.update()));
  }
  update() {
    this.callOnModel.clear(), !(this.editor.getOption(
      12
      /* EditorOption.autoIndent */
    ) < 4 || this.editor.getOption(
      55
      /* EditorOption.formatOnPaste */
    )) && this.editor.hasModel() && this.callOnModel.add(this.editor.onDidPaste(({ range: e }) => {
      this.trigger(e);
    }));
  }
  trigger(e) {
    const t = this.editor.getSelections();
    if (t === null || t.length > 1)
      return;
    const i = this.editor.getModel();
    if (!i || !i.tokenization.isCheapToTokenize(e.getStartPosition().lineNumber))
      return;
    const n = this.editor.getOption(
      12
      /* EditorOption.autoIndent */
    ), { tabSize: s, indentSize: o, insertSpaces: a } = i.getOptions(), l = [], d = {
      shiftIndent: (p) => Xs.shiftIndent(p, p.length + 1, s, o, a),
      unshiftIndent: (p) => Xs.unshiftIndent(p, p.length + 1, s, o, a)
    };
    let c = e.startLineNumber;
    for (; c <= e.endLineNumber; ) {
      if (this.shouldIgnoreLine(i, c)) {
        c++;
        continue;
      }
      break;
    }
    if (c > e.endLineNumber)
      return;
    let h = i.getLineContent(c);
    if (!/\S/.test(h.substring(0, e.startColumn - 1))) {
      const p = Jo(n, i, i.getLanguageId(), c, d, this._languageConfigurationService);
      if (p !== null) {
        const f = Ee(h), m = tt(p, s), _ = tt(f, s);
        if (m !== _) {
          const v = ar(m, s, a);
          l.push({
            range: new S(c, 1, c, f.length + 1),
            text: v
          }), h = v + h.substr(f.length);
        } else {
          const v = A_(i, c, this._languageConfigurationService);
          if (v === 0 || v === 8)
            return;
        }
      }
    }
    const u = c;
    for (; c < e.endLineNumber; ) {
      if (!/\S/.test(i.getLineContent(c + 1))) {
        c++;
        continue;
      }
      break;
    }
    if (c !== e.endLineNumber) {
      const f = Jo(n, {
        tokenization: {
          getLineTokens: (m) => i.tokenization.getLineTokens(m),
          getLanguageId: () => i.getLanguageId(),
          getLanguageIdAtPosition: (m, _) => i.getLanguageIdAtPosition(m, _)
        },
        getLineContent: (m) => m === u ? h : i.getLineContent(m)
      }, i.getLanguageId(), c + 1, d, this._languageConfigurationService);
      if (f !== null) {
        const m = tt(f, s), _ = tt(Ee(i.getLineContent(c + 1)), s);
        if (m !== _) {
          const v = m - _;
          for (let C = c + 1; C <= e.endLineNumber; C++) {
            const w = i.getLineContent(C), y = Ee(w), k = tt(y, s) + v, N = ar(k, s, a);
            N !== y && l.push({
              range: new S(C, 1, C, y.length + 1),
              text: N
            });
          }
        }
      }
    }
    if (l.length > 0) {
      this.editor.pushUndoStop();
      const p = new qN(l, this.editor.getSelection());
      this.editor.executeCommand("autoIndentOnPaste", p), this.editor.pushUndoStop();
    }
  }
  shouldIgnoreLine(e, t) {
    e.tokenization.forceTokenization(t);
    const i = e.getLineFirstNonWhitespaceColumn(t);
    if (i === 0)
      return !0;
    const n = e.tokenization.getLineTokens(t);
    if (n.getCount() > 0) {
      const s = n.findTokenIndexAtOffset(i);
      if (s >= 0 && n.getStandardTokenType(s) === 1)
        return !0;
    }
    return !1;
  }
  dispose() {
    this.callOnDispose.dispose(), this.callOnModel.dispose();
  }
};
Or.ID = "editor.contrib.autoIndentOnPaste";
Or = UN([
  zN(1, fe)
], Or);
function iC(r, e, t, i) {
  if (r.getLineCount() === 1 && r.getLineMaxColumn(1) === 1)
    return;
  let n = "";
  for (let o = 0; o < t; o++)
    n += " ";
  const s = new RegExp(n, "gi");
  for (let o = 1, a = r.getLineCount(); o <= a; o++) {
    let l = r.getLineFirstNonWhitespaceColumn(o);
    if (l === 0 && (l = r.getLineMaxColumn(o)), l === 1)
      continue;
    const d = new S(o, 1, o, l), c = r.getValueInRange(d), h = i ? c.replace(/\t/ig, n) : c.replace(s, "	");
    e.addEditOperation(d, h);
  }
}
class KN {
  constructor(e, t) {
    this.selection = e, this.tabSize = t, this.selectionId = null;
  }
  getEditOperations(e, t) {
    this.selectionId = t.trackSelection(this.selection), iC(e, t, this.tabSize, !0);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this.selectionId);
  }
}
class GN {
  constructor(e, t) {
    this.selection = e, this.tabSize = t, this.selectionId = null;
  }
  getEditOperations(e, t) {
    this.selectionId = t.trackSelection(this.selection), iC(e, t, this.tabSize, !1);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this.selectionId);
  }
}
Z(
  Or.ID,
  Or,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
x(Xd);
x(Qd);
x(Yd);
x(Jd);
x(ec);
x(tc);
x($N);
x(jN);
class nC {
  constructor(e, t) {
    this.range = e, this.direction = t;
  }
}
class op {
  constructor(e, t, i) {
    this.hint = e, this.anchor = t, this.provider = i, this._isResolved = !1;
  }
  with(e) {
    const t = new op(this.hint, e.anchor, this.provider);
    return t._isResolved = this._isResolved, t._currentResolve = this._currentResolve, t;
  }
  async resolve(e) {
    if (typeof this.provider.resolveInlayHint == "function") {
      if (this._currentResolve)
        return await this._currentResolve, e.isCancellationRequested ? void 0 : this.resolve(e);
      this._isResolved || (this._currentResolve = this._doResolve(e).finally(() => this._currentResolve = void 0)), await this._currentResolve;
    }
  }
  async _doResolve(e) {
    var t, i, n;
    try {
      const s = await Promise.resolve(this.provider.resolveInlayHint(this.hint, e));
      this.hint.tooltip = (t = s == null ? void 0 : s.tooltip) !== null && t !== void 0 ? t : this.hint.tooltip, this.hint.label = (i = s == null ? void 0 : s.label) !== null && i !== void 0 ? i : this.hint.label, this.hint.textEdits = (n = s == null ? void 0 : s.textEdits) !== null && n !== void 0 ? n : this.hint.textEdits, this._isResolved = !0;
    } catch (s) {
      Ie(s), this._isResolved = !1;
    }
  }
}
class Wn {
  static async create(e, t, i, n) {
    const s = [], o = e.ordered(t).reverse().map((a) => i.map(async (l) => {
      try {
        const d = await a.provideInlayHints(t, l, n);
        (d != null && d.hints.length || a.onDidChangeInlayHints) && s.push([d ?? Wn._emptyInlayHintList, a]);
      } catch (d) {
        Ie(d);
      }
    }));
    if (await Promise.all(o.flat()), n.isCancellationRequested || t.isDisposed())
      throw new I_();
    return new Wn(i, s, t);
  }
  constructor(e, t, i) {
    this._disposables = new M(), this.ranges = e, this.provider = /* @__PURE__ */ new Set();
    const n = [];
    for (const [s, o] of t) {
      this._disposables.add(s), this.provider.add(o);
      for (const a of s.hints) {
        const l = i.validatePosition(a.position);
        let d = "before";
        const c = Wn._getRangeAtPosition(i, l);
        let h;
        c.getStartPosition().isBefore(l) ? (h = S.fromPositions(c.getStartPosition(), l), d = "after") : (h = S.fromPositions(l, c.getEndPosition()), d = "before"), n.push(new op(a, new nC(h, d), o));
      }
    }
    this.items = n.sort((s, o) => F.compare(s.hint.position, o.hint.position));
  }
  dispose() {
    this._disposables.dispose();
  }
  static _getRangeAtPosition(e, t) {
    const i = t.lineNumber, n = e.getWordAtPosition(t);
    if (n)
      return new S(i, n.startColumn, i, n.endColumn);
    e.tokenization.tokenizeIfCheap(i);
    const s = e.tokenization.getLineTokens(i), o = t.column - 1, a = s.findTokenIndexAtOffset(o);
    let l = s.getStartOffset(a), d = s.getEndOffset(a);
    return d - l === 1 && (l === o && a > 1 ? (l = s.getStartOffset(a - 1), d = s.getEndOffset(a - 1)) : d === o && a < s.getCount() - 1 && (l = s.getStartOffset(a + 1), d = s.getEndOffset(a + 1))), new S(i, l + 1, i, d + 1);
  }
}
Wn._emptyInlayHintList = Object.freeze({ dispose() {
}, hints: [] });
function ZN(r) {
  return ce.from({
    scheme: wt.command,
    path: r.id,
    query: r.arguments && encodeURIComponent(JSON.stringify(r.arguments))
  }).toString();
}
async function XN(r, e, t, i) {
  var n;
  const s = r.get(Zt), o = r.get(co), a = r.get(Fe), l = r.get(q), d = r.get(Je);
  if (await i.item.resolve(X.None), !i.part.location)
    return;
  const c = i.part.location, h = [], u = new Set(qt.getMenuItems(E.EditorContext).map((f) => Qw(f) ? f.command.id : wd()));
  for (const f of Be.all())
    u.has(f.desc.id) && h.push(new qs(f.desc.id, Gs.label(f.desc, { renderShortTitle: !0 }), void 0, !0, async () => {
      const m = await s.createModelReference(c.uri);
      try {
        const _ = new Js(m.object.textEditorModel, S.getStartPosition(c.range)), v = i.item.anchor.range;
        await l.invokeFunction(f.runEditorCommand.bind(f), e, _, v);
      } finally {
        m.dispose();
      }
    }));
  if (i.part.command) {
    const { command: f } = i.part;
    h.push(new vr()), h.push(new qs(f.id, f.title, void 0, !0, async () => {
      var m;
      try {
        await a.executeCommand(f.id, ...(m = f.arguments) !== null && m !== void 0 ? m : []);
      } catch (_) {
        d.notify({
          severity: mg.Error,
          source: i.item.provider.displayName,
          message: _
        });
      }
    }));
  }
  const p = e.getOption(
    127
    /* EditorOption.useShadowDOM */
  );
  o.showContextMenu({
    domForShadowRoot: p && (n = e.getDomNode()) !== null && n !== void 0 ? n : void 0,
    getAnchor: () => {
      const f = mt(t);
      return { x: f.left, y: f.top + f.height + 8 };
    },
    getActions: () => h,
    onHide: () => {
      e.focus();
    },
    autoSelectFirstItem: !0
  });
}
async function sC(r, e, t, i) {
  const s = await r.get(Zt).createModelReference(i.uri);
  await t.invokeWithinContext(async (o) => {
    const a = e.hasSideBySideModifier, l = o.get(ee), d = Qe.inPeekEditor.getValue(l), c = !a && t.getOption(
      88
      /* EditorOption.definitionLinkOpensInPeek */
    ) && !d;
    return new pa({ openToSide: a, openInPeek: c, muteMessage: !0 }, { title: { value: "", original: "" }, id: "", precondition: void 0 }).run(o, new Js(s.object.textEditorModel, S.getStartPosition(i.range)), S.lift(i.range));
  }), s.dispose();
}
var QN = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, _s = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Ls;
class Kl {
  constructor() {
    this._entries = new Yr(50);
  }
  get(e) {
    const t = Kl._key(e);
    return this._entries.get(t);
  }
  set(e, t) {
    const i = Kl._key(e);
    this._entries.set(i, t);
  }
  static _key(e) {
    return `${e.uri.toString()}/${e.getVersionId()}`;
  }
}
const oC = Ti("IInlayHintsCache");
Ai(
  oC,
  Kl,
  1
  /* InstantiationType.Delayed */
);
class cu {
  constructor(e, t) {
    this.item = e, this.index = t;
  }
  get part() {
    const e = this.item.hint.label;
    return typeof e == "string" ? { label: e } : e[this.index];
  }
}
class YN {
  constructor(e, t) {
    this.part = e, this.hasTriggerModifier = t;
  }
}
let pn = Ls = class {
  static get(e) {
    var t;
    return (t = e.getContribution(Ls.ID)) !== null && t !== void 0 ? t : void 0;
  }
  constructor(e, t, i, n, s, o, a) {
    this._editor = e, this._languageFeaturesService = t, this._inlayHintsCache = n, this._commandService = s, this._notificationService = o, this._instaService = a, this._disposables = new M(), this._sessionDisposables = new M(), this._decorationsMetadata = /* @__PURE__ */ new Map(), this._ruleFactory = new Um(this._editor), this._activeRenderMode = 0, this._debounceInfo = i.for(t.inlayHintsProvider, "InlayHint", { min: 25 }), this._disposables.add(t.inlayHintsProvider.onDidChange(() => this._update())), this._disposables.add(e.onDidChangeModel(() => this._update())), this._disposables.add(e.onDidChangeModelLanguage(() => this._update())), this._disposables.add(e.onDidChangeConfiguration((l) => {
      l.hasChanged(
        140
        /* EditorOption.inlayHints */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._sessionDisposables.dispose(), this._removeAllDecorations(), this._disposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear(), this._removeAllDecorations();
    const e = this._editor.getOption(
      140
      /* EditorOption.inlayHints */
    );
    if (e.enabled === "off")
      return;
    const t = this._editor.getModel();
    if (!t || !this._languageFeaturesService.inlayHintsProvider.has(t))
      return;
    if (e.enabled === "on")
      this._activeRenderMode = 0;
    else {
      let a, l;
      e.enabled === "onUnlessPressed" ? (a = 0, l = 1) : (a = 1, l = 0), this._activeRenderMode = a, this._sessionDisposables.add(Yw.getInstance().event((d) => {
        if (!this._editor.hasModel())
          return;
        const c = d.altKey && d.ctrlKey && !(d.shiftKey || d.metaKey) ? l : a;
        if (c !== this._activeRenderMode) {
          this._activeRenderMode = c;
          const h = this._editor.getModel(), u = this._copyInlayHintsWithCurrentAnchor(h);
          this._updateHintsDecorators([h.getFullModelRange()], u), o.schedule(0);
        }
      }));
    }
    const i = this._inlayHintsCache.get(t);
    i && this._updateHintsDecorators([t.getFullModelRange()], i), this._sessionDisposables.add(pe(() => {
      t.isDisposed() || this._cacheHintsForFastRestore(t);
    }));
    let n;
    const s = /* @__PURE__ */ new Set(), o = new Re(async () => {
      const a = Date.now();
      n == null || n.dispose(!0), n = new Oe();
      const l = t.onWillDispose(() => n == null ? void 0 : n.cancel());
      try {
        const d = n.token, c = await Wn.create(this._languageFeaturesService.inlayHintsProvider, t, this._getHintsRanges(), d);
        if (o.delay = this._debounceInfo.update(t, Date.now() - a), d.isCancellationRequested) {
          c.dispose();
          return;
        }
        for (const h of c.provider)
          typeof h.onDidChangeInlayHints == "function" && !s.has(h) && (s.add(h), this._sessionDisposables.add(h.onDidChangeInlayHints(() => {
            o.isScheduled() || o.schedule();
          })));
        this._sessionDisposables.add(c), this._updateHintsDecorators(c.ranges, c.items), this._cacheHintsForFastRestore(t);
      } catch (d) {
        re(d);
      } finally {
        n.dispose(), l.dispose();
      }
    }, this._debounceInfo.get(t));
    this._sessionDisposables.add(o), this._sessionDisposables.add(pe(() => n == null ? void 0 : n.dispose(!0))), o.schedule(0), this._sessionDisposables.add(this._editor.onDidScrollChange((a) => {
      (a.scrollTopChanged || !o.isScheduled()) && o.schedule();
    })), this._sessionDisposables.add(this._editor.onDidChangeModelContent((a) => {
      n == null || n.cancel();
      const l = Math.max(o.delay, 1250);
      o.schedule(l);
    })), this._sessionDisposables.add(this._installDblClickGesture(() => o.schedule(0))), this._sessionDisposables.add(this._installLinkGesture()), this._sessionDisposables.add(this._installContextMenu());
  }
  _installLinkGesture() {
    const e = new M(), t = e.add(new Ld(this._editor)), i = new M();
    return e.add(i), e.add(t.onMouseMoveOrRelevantKeyDown((n) => {
      const [s] = n, o = this._getInlayHintLabelPart(s), a = this._editor.getModel();
      if (!o || !a) {
        i.clear();
        return;
      }
      const l = new Oe();
      i.add(pe(() => l.dispose(!0))), o.item.resolve(l.token), this._activeInlayHintPart = o.part.command || o.part.location ? new YN(o, s.hasTriggerModifier) : void 0;
      const d = a.validatePosition(o.item.hint.position).lineNumber, c = new S(d, 1, d, a.getLineMaxColumn(d)), h = this._getInlineHintsForRange(c);
      this._updateHintsDecorators([c], h), i.add(pe(() => {
        this._activeInlayHintPart = void 0, this._updateHintsDecorators([c], h);
      }));
    })), e.add(t.onCancel(() => i.clear())), e.add(t.onExecute(async (n) => {
      const s = this._getInlayHintLabelPart(n);
      if (s) {
        const o = s.part;
        o.location ? this._instaService.invokeFunction(sC, n, this._editor, o.location) : Jw.is(o.command) && await this._invokeCommand(o.command, s.item);
      }
    })), e;
  }
  _getInlineHintsForRange(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of this._decorationsMetadata.values())
      e.containsRange(i.item.anchor.range) && t.add(i.item);
    return Array.from(t);
  }
  _installDblClickGesture(e) {
    return this._editor.onMouseUp(async (t) => {
      if (t.event.detail !== 2)
        return;
      const i = this._getInlayHintLabelPart(t);
      if (i && (t.event.preventDefault(), await i.item.resolve(X.None), nt(i.item.hint.textEdits))) {
        const n = i.item.hint.textEdits.map((s) => ue.replace(S.lift(s.range), s.text));
        this._editor.executeEdits("inlayHint.default", n), e();
      }
    });
  }
  _installContextMenu() {
    return this._editor.onContextMenu(async (e) => {
      if (!(e.event.target instanceof HTMLElement))
        return;
      const t = this._getInlayHintLabelPart(e);
      t && await this._instaService.invokeFunction(XN, this._editor, e.event.target, t);
    });
  }
  _getInlayHintLabelPart(e) {
    var t;
    if (e.target.type !== 6)
      return;
    const i = (t = e.target.detail.injectedText) === null || t === void 0 ? void 0 : t.options;
    if (i instanceof dg && (i == null ? void 0 : i.attachedData) instanceof cu)
      return i.attachedData;
  }
  async _invokeCommand(e, t) {
    var i;
    try {
      await this._commandService.executeCommand(e.id, ...(i = e.arguments) !== null && i !== void 0 ? i : []);
    } catch (n) {
      this._notificationService.notify({
        severity: mg.Error,
        source: t.provider.displayName,
        message: n
      });
    }
  }
  _cacheHintsForFastRestore(e) {
    const t = this._copyInlayHintsWithCurrentAnchor(e);
    this._inlayHintsCache.set(e, t);
  }
  // return inlay hints but with an anchor that reflects "updates"
  // that happened after receiving them, e.g adding new lines before a hint
  _copyInlayHintsWithCurrentAnchor(e) {
    const t = /* @__PURE__ */ new Map();
    for (const [i, n] of this._decorationsMetadata) {
      if (t.has(n.item))
        continue;
      const s = e.getDecorationRange(i);
      if (s) {
        const o = new nC(s, n.item.anchor.direction), a = n.item.with({ anchor: o });
        t.set(n.item, a);
      }
    }
    return Array.from(t.values());
  }
  _getHintsRanges() {
    const t = this._editor.getModel(), i = this._editor.getVisibleRangesPlusViewportAboveBelow(), n = [];
    for (const s of i.sort(S.compareRangesUsingStarts)) {
      const o = t.validateRange(new S(s.startLineNumber - 30, s.startColumn, s.endLineNumber + 30, s.endColumn));
      n.length === 0 || !S.areIntersectingOrTouching(n[n.length - 1], o) ? n.push(o) : n[n.length - 1] = S.plusRange(n[n.length - 1], o);
    }
    return n;
  }
  _updateHintsDecorators(e, t) {
    var i, n;
    const s = [], o = (_, v, C, w, y) => {
      const I = {
        content: C,
        inlineClassNameAffectsLetterSpacing: !0,
        inlineClassName: v.className,
        cursorStops: w,
        attachedData: y
      };
      s.push({
        item: _,
        classNameRef: v,
        decoration: {
          range: _.anchor.range,
          options: {
            // className: "rangeHighlight", // DEBUG highlight to see to what range a hint is attached
            description: "InlayHint",
            showIfCollapsed: _.anchor.range.isEmpty(),
            // "original" range is empty
            collapseOnReplaceEdit: !_.anchor.range.isEmpty(),
            stickiness: 0,
            [_.anchor.direction]: this._activeRenderMode === 0 ? I : void 0
          }
        }
      });
    }, a = (_, v) => {
      const C = this._ruleFactory.createClassNameRef({
        width: `${l / 3 | 0}px`,
        display: "inline-block"
      });
      o(_, C, "", v ? Rs.Right : Rs.None);
    }, { fontSize: l, fontFamily: d, padding: c, isUniform: h } = this._getLayoutInfo(), u = "--code-editorInlayHintsFontFamily";
    this._editor.getContainerDomNode().style.setProperty(u, d);
    let p = { line: 0, totalLen: 0 };
    for (const _ of t) {
      if (p.line !== _.anchor.range.startLineNumber && (p = { line: _.anchor.range.startLineNumber, totalLen: 0 }), p.totalLen > Ls._MAX_LABEL_LEN)
        continue;
      _.hint.paddingLeft && a(_, !1);
      const v = typeof _.hint.label == "string" ? [{ label: _.hint.label }] : _.hint.label;
      for (let C = 0; C < v.length; C++) {
        const w = v[C], y = C === 0, I = C === v.length - 1, k = {
          fontSize: `${l}px`,
          fontFamily: `var(${u}), ${Vm.fontFamily}`,
          verticalAlign: h ? "baseline" : "middle",
          unicodeBidi: "isolate"
        };
        nt(_.hint.textEdits) && (k.cursor = "default"), this._fillInColors(k, _.hint), (w.command || w.location) && ((i = this._activeInlayHintPart) === null || i === void 0 ? void 0 : i.part.item) === _ && this._activeInlayHintPart.part.index === C && (k.textDecoration = "underline", this._activeInlayHintPart.hasTriggerModifier && (k.color = Se(ey), k.cursor = "pointer")), c && (y && I ? (k.padding = `1px ${Math.max(1, l / 4) | 0}px`, k.borderRadius = `${l / 4 | 0}px`) : y ? (k.padding = `1px 0 1px ${Math.max(1, l / 4) | 0}px`, k.borderRadius = `${l / 4 | 0}px 0 0 ${l / 4 | 0}px`) : I ? (k.padding = `1px ${Math.max(1, l / 4) | 0}px 1px 0`, k.borderRadius = `0 ${l / 4 | 0}px ${l / 4 | 0}px 0`) : k.padding = "1px 0 1px 0");
        let N = w.label;
        p.totalLen += N.length;
        let J = !1;
        const te = p.totalLen - Ls._MAX_LABEL_LEN;
        if (te > 0 && (N = N.slice(0, -te) + "", J = !0), o(_, this._ruleFactory.createClassNameRef(k), JN(N), I && !_.hint.paddingRight ? Rs.Right : Rs.None, new cu(_, C)), J)
          break;
      }
      if (_.hint.paddingRight && a(_, !0), s.length > Ls._MAX_DECORATORS)
        break;
    }
    const f = [];
    for (const [_, v] of this._decorationsMetadata) {
      const C = (n = this._editor.getModel()) === null || n === void 0 ? void 0 : n.getDecorationRange(_);
      C && e.some((w) => w.containsRange(C)) && (f.push(_), v.classNameRef.dispose(), this._decorationsMetadata.delete(_));
    }
    const m = $s.capture(this._editor);
    this._editor.changeDecorations((_) => {
      const v = _.deltaDecorations(f, s.map((C) => C.decoration));
      for (let C = 0; C < v.length; C++) {
        const w = s[C];
        this._decorationsMetadata.set(v[C], w);
      }
    }), m.restore(this._editor);
  }
  _fillInColors(e, t) {
    t.kind === $p.Parameter ? (e.backgroundColor = Se(ty), e.color = Se(iy)) : t.kind === $p.Type ? (e.backgroundColor = Se(ny), e.color = Se(sy)) : (e.backgroundColor = Se(oy), e.color = Se(ry));
  }
  _getLayoutInfo() {
    const e = this._editor.getOption(
      140
      /* EditorOption.inlayHints */
    ), t = e.padding, i = this._editor.getOption(
      52
      /* EditorOption.fontSize */
    ), n = this._editor.getOption(
      49
      /* EditorOption.fontFamily */
    );
    let s = e.fontSize;
    (!s || s < 5 || s > i) && (s = i);
    const o = e.fontFamily || n;
    return { fontSize: s, fontFamily: o, padding: t, isUniform: !t && o === n && s === i };
  }
  _removeAllDecorations() {
    this._editor.removeDecorations(Array.from(this._decorationsMetadata.keys()));
    for (const e of this._decorationsMetadata.values())
      e.classNameRef.dispose();
    this._decorationsMetadata.clear();
  }
};
pn.ID = "editor.contrib.InlayHints";
pn._MAX_DECORATORS = 1500;
pn._MAX_LABEL_LEN = 43;
pn = Ls = QN([
  _s(1, V),
  _s(2, Pt),
  _s(3, oC),
  _s(4, Fe),
  _s(5, Je),
  _s(6, q)
], pn);
function JN(r) {
  return r.replace(/[ \t]/g, "");
}
de.registerCommand("_executeInlayHintProvider", async (r, ...e) => {
  const [t, i] = e;
  ie(ce.isUri(t)), ie(S.isIRange(i));
  const { inlayHintsProvider: n } = r.get(V), s = await r.get(Zt).createModelReference(t);
  try {
    const o = await Wn.create(n, s.object.textEditorModel, [S.lift(i)], X.None), a = o.items.map((l) => l.hint);
    return setTimeout(() => o.dispose(), 0), a;
  } finally {
    s.dispose();
  }
});
var eR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ho = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class um extends An {
  constructor(e, t, i, n) {
    super(10, t, e.item.anchor.range, i, n, !0), this.part = e;
  }
}
let hu = class extends Fl {
  constructor(e, t, i, n, s, o) {
    super(e, t, i, n, o), this._resolverService = s, this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(e) {
    var t;
    if (!pn.get(this._editor) || e.target.type !== 6)
      return null;
    const n = (t = e.target.detail.injectedText) === null || t === void 0 ? void 0 : t.options;
    return n instanceof dg && n.attachedData instanceof cu ? new um(n.attachedData, this, e.event.posx, e.event.posy) : null;
  }
  computeSync() {
    return [];
  }
  computeAsync(e, t, i) {
    return e instanceof um ? new zt(async (n) => {
      const { part: s } = e;
      if (await s.item.resolve(i), i.isCancellationRequested)
        return;
      let o;
      typeof s.item.hint.tooltip == "string" ? o = new Ue().appendText(s.item.hint.tooltip) : s.item.hint.tooltip && (o = s.item.hint.tooltip), o && n.emitOne(new Vt(this, e.range, [o], !1, 0)), nt(s.item.hint.textEdits) && n.emitOne(new Vt(this, e.range, [new Ue().appendText(g("hint.dbl", "Double-click to insert"))], !1, 10001));
      let a;
      if (typeof s.part.tooltip == "string" ? a = new Ue().appendText(s.part.tooltip) : s.part.tooltip && (a = s.part.tooltip), a && n.emitOne(new Vt(this, e.range, [a], !1, 1)), s.part.location || s.part.command) {
        let d;
        const h = this._editor.getOption(
          78
          /* EditorOption.multiCursorModifier */
        ) === "altKey" ? si ? g("links.navigate.kb.meta.mac", "cmd + click") : g("links.navigate.kb.meta", "ctrl + click") : si ? g("links.navigate.kb.alt.mac", "option + click") : g("links.navigate.kb.alt", "alt + click");
        s.part.location && s.part.command ? d = new Ue().appendText(g("hint.defAndCommand", "Go to Definition ({0}), right click for more", h)) : s.part.location ? d = new Ue().appendText(g("hint.def", "Go to Definition ({0})", h)) : s.part.command && (d = new Ue(`[${g("hint.cmd", "Execute Command")}](${ZN(s.part.command)} "${s.part.command.title}") (${h})`, { isTrusted: !0 })), d && n.emitOne(new Vt(this, e.range, [d], !1, 1e4));
      }
      const l = await this._resolveInlayHintLabelPartHover(s, i);
      for await (const d of l)
        n.emitOne(d);
    }) : zt.EMPTY;
  }
  async _resolveInlayHintLabelPartHover(e, t) {
    if (!e.part.location)
      return zt.EMPTY;
    const { uri: i, range: n } = e.part.location, s = await this._resolverService.createModelReference(i);
    try {
      const o = s.object.textEditorModel;
      return this._languageFeaturesService.hoverProvider.has(o) ? Bg(this._languageFeaturesService.hoverProvider, o, new F(n.startLineNumber, n.startColumn), t).filter((a) => !_r(a.hover.contents)).map((a) => new Vt(this, e.item.anchor.range, a.hover.contents, !1, 2 + a.ordinal)) : zt.EMPTY;
    } finally {
      s.dispose();
    }
  }
};
hu = eR([
  Ho(1, Et),
  Ho(2, Gt),
  Ho(3, he),
  Ho(4, Zt),
  Ho(5, V)
], hu);
Z(
  pn.ID,
  pn,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
bn.register(hu);
class tR {
  constructor(e, t, i) {
    this._editRange = e, this._originalSelection = t, this._text = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._editRange, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return this._originalSelection.isEmpty() ? new z(n.endLineNumber, Math.min(this._originalSelection.positionColumn, n.endColumn), n.endLineNumber, Math.min(this._originalSelection.positionColumn, n.endColumn)) : new z(n.endLineNumber, n.endColumn - this._text.length, n.endLineNumber, n.endColumn);
  }
}
var iR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, nR = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, fl;
let fn = fl = class {
  static get(e) {
    return e.getContribution(fl.ID);
  }
  constructor(e, t) {
    this.editor = e, this.editorWorkerService = t, this.decorations = this.editor.createDecorationsCollection();
  }
  dispose() {
  }
  run(e, t) {
    var i;
    (i = this.currentRequest) === null || i === void 0 || i.cancel();
    const n = this.editor.getSelection(), s = this.editor.getModel();
    if (!s || !n)
      return;
    let o = n;
    if (o.startLineNumber !== o.endLineNumber)
      return;
    const a = new Ym(
      this.editor,
      5
      /* CodeEditorStateFlag.Position */
    ), l = s.uri;
    return this.editorWorkerService.canNavigateValueSet(l) ? (this.currentRequest = Pe((d) => this.editorWorkerService.navigateValueSet(l, o, t)), this.currentRequest.then((d) => {
      var c;
      if (!d || !d.range || !d.value || !a.validate(this.editor))
        return;
      const h = S.lift(d.range);
      let u = d.range;
      const p = d.value.length - (o.endColumn - o.startColumn);
      u = {
        startLineNumber: u.startLineNumber,
        startColumn: u.startColumn,
        endLineNumber: u.endLineNumber,
        endColumn: u.startColumn + d.value.length
      }, p > 1 && (o = new z(o.startLineNumber, o.startColumn, o.endLineNumber, o.endColumn + p - 1));
      const f = new tR(h, o, d.value);
      this.editor.pushUndoStop(), this.editor.executeCommand(e, f), this.editor.pushUndoStop(), this.decorations.set([{
        range: u,
        options: fl.DECORATION
      }]), (c = this.decorationRemover) === null || c === void 0 || c.cancel(), this.decorationRemover = vg(350), this.decorationRemover.then(() => this.decorations.clear()).catch(re);
    }).catch(re)) : Promise.resolve(void 0);
  }
};
fn.ID = "editor.contrib.inPlaceReplaceController";
fn.DECORATION = Y.register({
  description: "in-place-replace",
  className: "valueSetReplacement"
});
fn = fl = iR([
  nR(1, sa)
], fn);
class sR extends D {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.up",
      label: g("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
      alias: "Replace with Previous Value",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 3159,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = fn.get(t);
    return i ? i.run(this.id, !1) : Promise.resolve(void 0);
  }
}
class oR extends D {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.down",
      label: g("InPlaceReplaceAction.next.label", "Replace with Next Value"),
      alias: "Replace with Next Value",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 3161,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = fn.get(t);
    return i ? i.run(this.id, !0) : Promise.resolve(void 0);
  }
}
Z(
  fn.ID,
  fn,
  4
  /* EditorContributionInstantiation.Lazy */
);
x(sR);
x(oR);
class rR extends D {
  constructor() {
    super({
      id: "expandLineSelection",
      label: g("expandLineSelection", "Expand Line Selection"),
      alias: "Expand Line Selection",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        kbExpr: b.textInputFocus,
        primary: 2090
        /* KeyCode.KeyL */
      }
    });
  }
  run(e, t, i) {
    if (i = i || {}, !t.hasModel())
      return;
    const n = t._getViewModel();
    n.model.pushStackElement(), n.setCursorStates(i.source, 3, bg.expandLineSelection(n, n.getCursorStates())), n.revealPrimaryCursor(i.source, !0);
  }
}
x(rR);
class aR {
  constructor(e, t) {
    this._selection = e, this._cursors = t, this._selectionId = null;
  }
  getEditOperations(e, t) {
    const i = lR(e, this._cursors);
    for (let n = 0, s = i.length; n < s; n++) {
      const o = i[n];
      t.addEditOperation(o.range, o.text);
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
function lR(r, e) {
  e.sort((o, a) => o.lineNumber === a.lineNumber ? o.column - a.column : o.lineNumber - a.lineNumber);
  for (let o = e.length - 2; o >= 0; o--)
    e[o].lineNumber === e[o + 1].lineNumber && e.splice(o, 1);
  const t = [];
  let i = 0, n = 0;
  const s = e.length;
  for (let o = 1, a = r.getLineCount(); o <= a; o++) {
    const l = r.getLineContent(o), d = l.length + 1;
    let c = 0;
    if (n < s && e[n].lineNumber === o && (c = e[n].column, n++, c === d) || l.length === 0)
      continue;
    const h = ll(l);
    let u = 0;
    if (h === -1)
      u = 1;
    else if (h !== l.length - 1)
      u = h + 2;
    else
      continue;
    u = Math.max(c, u), t[i++] = ue.delete(new S(o, u, o, d));
  }
  return t;
}
class rC {
  constructor(e, t, i) {
    this._selection = e, this._isCopyingDown = t, this._noop = i || !1, this._selectionDirection = 0, this._selectionId = null, this._startLineNumberDelta = 0, this._endLineNumberDelta = 0;
  }
  getEditOperations(e, t) {
    let i = this._selection;
    this._startLineNumberDelta = 0, this._endLineNumberDelta = 0, i.startLineNumber < i.endLineNumber && i.endColumn === 1 && (this._endLineNumberDelta = 1, i = i.setEndPosition(i.endLineNumber - 1, e.getLineMaxColumn(i.endLineNumber - 1)));
    const n = [];
    for (let o = i.startLineNumber; o <= i.endLineNumber; o++)
      n.push(e.getLineContent(o));
    const s = n.join(`
`);
    s === "" && this._isCopyingDown && (this._startLineNumberDelta++, this._endLineNumberDelta++), this._noop ? t.addEditOperation(new S(i.endLineNumber, e.getLineMaxColumn(i.endLineNumber), i.endLineNumber + 1, 1), i.endLineNumber === e.getLineCount() ? "" : `
`) : this._isCopyingDown ? t.addEditOperation(new S(i.startLineNumber, 1, i.startLineNumber, 1), s + `
`) : t.addEditOperation(new S(i.endLineNumber, e.getLineMaxColumn(i.endLineNumber), i.endLineNumber, e.getLineMaxColumn(i.endLineNumber)), `
` + s), this._selectionId = t.trackSelection(i), this._selectionDirection = this._selection.getDirection();
  }
  computeCursorState(e, t) {
    let i = t.getTrackedSelection(this._selectionId);
    if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
      let n = i.startLineNumber, s = i.startColumn, o = i.endLineNumber, a = i.endColumn;
      this._startLineNumberDelta !== 0 && (n = n + this._startLineNumberDelta, s = 1), this._endLineNumberDelta !== 0 && (o = o + this._endLineNumberDelta, a = 1), i = z.createWithDirection(n, s, o, a, this._selectionDirection);
    }
    return i;
  }
}
var dR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, cR = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let uu = class {
  constructor(e, t, i, n) {
    this._languageConfigurationService = n, this._selection = e, this._isMovingDown = t, this._autoIndent = i, this._selectionId = null, this._moveEndLineSelectionShrink = !1;
  }
  getEditOperations(e, t) {
    const i = e.getLineCount();
    if (this._isMovingDown && this._selection.endLineNumber === i) {
      this._selectionId = t.trackSelection(this._selection);
      return;
    }
    if (!this._isMovingDown && this._selection.startLineNumber === 1) {
      this._selectionId = t.trackSelection(this._selection);
      return;
    }
    this._moveEndPositionDown = !1;
    let n = this._selection;
    n.startLineNumber < n.endLineNumber && n.endColumn === 1 && (this._moveEndPositionDown = !0, n = n.setEndPosition(n.endLineNumber - 1, e.getLineMaxColumn(n.endLineNumber - 1)));
    const { tabSize: s, indentSize: o, insertSpaces: a } = e.getOptions(), l = this.buildIndentConverter(s, o, a), d = {
      tokenization: {
        getLineTokens: (c) => e.tokenization.getLineTokens(c),
        getLanguageId: () => e.getLanguageId(),
        getLanguageIdAtPosition: (c, h) => e.getLanguageIdAtPosition(c, h)
      },
      getLineContent: null
    };
    if (n.startLineNumber === n.endLineNumber && e.getLineMaxColumn(n.startLineNumber) === 1) {
      const c = n.startLineNumber, h = this._isMovingDown ? c + 1 : c - 1;
      e.getLineMaxColumn(h) === 1 ? t.addEditOperation(new S(1, 1, 1, 1), null) : (t.addEditOperation(new S(c, 1, c, 1), e.getLineContent(h)), t.addEditOperation(new S(h, 1, h, e.getLineMaxColumn(h)), null)), n = new z(h, 1, h, 1);
    } else {
      let c, h;
      if (this._isMovingDown) {
        c = n.endLineNumber + 1, h = e.getLineContent(c), t.addEditOperation(new S(c - 1, e.getLineMaxColumn(c - 1), c, e.getLineMaxColumn(c)), null);
        let u = h;
        if (this.shouldAutoIndent(e, n)) {
          const p = this.matchEnterRule(e, l, s, c, n.startLineNumber - 1);
          if (p !== null) {
            const m = Ee(e.getLineContent(c)), _ = p + tt(m, s);
            u = ar(_, s, a) + this.trimStart(h);
          } else {
            d.getLineContent = (_) => _ === n.startLineNumber ? e.getLineContent(c) : e.getLineContent(_);
            const m = Jo(this._autoIndent, d, e.getLanguageIdAtPosition(c, 1), n.startLineNumber, l, this._languageConfigurationService);
            if (m !== null) {
              const _ = Ee(e.getLineContent(c)), v = tt(m, s), C = tt(_, s);
              v !== C && (u = ar(v, s, a) + this.trimStart(h));
            }
          }
          t.addEditOperation(new S(n.startLineNumber, 1, n.startLineNumber, 1), u + `
`);
          const f = this.matchEnterRuleMovingDown(e, l, s, n.startLineNumber, c, u);
          if (f !== null)
            f !== 0 && this.getIndentEditsOfMovingBlock(e, t, n, s, a, f);
          else {
            d.getLineContent = (_) => _ === n.startLineNumber ? u : _ >= n.startLineNumber + 1 && _ <= n.endLineNumber + 1 ? e.getLineContent(_ - 1) : e.getLineContent(_);
            const m = Jo(this._autoIndent, d, e.getLanguageIdAtPosition(c, 1), n.startLineNumber + 1, l, this._languageConfigurationService);
            if (m !== null) {
              const _ = Ee(e.getLineContent(n.startLineNumber)), v = tt(m, s), C = tt(_, s);
              if (v !== C) {
                const w = v - C;
                this.getIndentEditsOfMovingBlock(e, t, n, s, a, w);
              }
            }
          }
        } else
          t.addEditOperation(new S(n.startLineNumber, 1, n.startLineNumber, 1), u + `
`);
      } else if (c = n.startLineNumber - 1, h = e.getLineContent(c), t.addEditOperation(new S(c, 1, c + 1, 1), null), t.addEditOperation(new S(n.endLineNumber, e.getLineMaxColumn(n.endLineNumber), n.endLineNumber, e.getLineMaxColumn(n.endLineNumber)), `
` + h), this.shouldAutoIndent(e, n)) {
        d.getLineContent = (p) => p === c ? e.getLineContent(n.startLineNumber) : e.getLineContent(p);
        const u = this.matchEnterRule(e, l, s, n.startLineNumber, n.startLineNumber - 2);
        if (u !== null)
          u !== 0 && this.getIndentEditsOfMovingBlock(e, t, n, s, a, u);
        else {
          const p = Jo(this._autoIndent, d, e.getLanguageIdAtPosition(n.startLineNumber, 1), c, l, this._languageConfigurationService);
          if (p !== null) {
            const f = Ee(e.getLineContent(n.startLineNumber)), m = tt(p, s), _ = tt(f, s);
            if (m !== _) {
              const v = m - _;
              this.getIndentEditsOfMovingBlock(e, t, n, s, a, v);
            }
          }
        }
      }
    }
    this._selectionId = t.trackSelection(n);
  }
  buildIndentConverter(e, t, i) {
    return {
      shiftIndent: (n) => Xs.shiftIndent(n, n.length + 1, e, t, i),
      unshiftIndent: (n) => Xs.unshiftIndent(n, n.length + 1, e, t, i)
    };
  }
  parseEnterResult(e, t, i, n, s) {
    if (s) {
      let o = s.indentation;
      s.indentAction === Ra.None || s.indentAction === Ra.Indent ? o = s.indentation + s.appendText : s.indentAction === Ra.IndentOutdent ? o = s.indentation : s.indentAction === Ra.Outdent && (o = t.unshiftIndent(s.indentation) + s.appendText);
      const a = e.getLineContent(n);
      if (this.trimStart(a).indexOf(this.trimStart(o)) >= 0) {
        const l = Ee(e.getLineContent(n));
        let d = Ee(o);
        const c = A_(e, n, this._languageConfigurationService);
        c !== null && c & 2 && (d = t.unshiftIndent(d));
        const h = tt(d, i), u = tt(l, i);
        return h - u;
      }
    }
    return null;
  }
  /**
   *
   * @param model
   * @param indentConverter
   * @param tabSize
   * @param line the line moving down
   * @param futureAboveLineNumber the line which will be at the `line` position
   * @param futureAboveLineText
   */
  matchEnterRuleMovingDown(e, t, i, n, s, o) {
    if (ll(o) >= 0) {
      const a = e.getLineMaxColumn(s), l = bc(this._autoIndent, e, new S(s, a, s, a), this._languageConfigurationService);
      return this.parseEnterResult(e, t, i, n, l);
    } else {
      let a = n - 1;
      for (; a >= 1; ) {
        const c = e.getLineContent(a);
        if (ll(c) >= 0)
          break;
        a--;
      }
      if (a < 1 || n > e.getLineCount())
        return null;
      const l = e.getLineMaxColumn(a), d = bc(this._autoIndent, e, new S(a, l, a, l), this._languageConfigurationService);
      return this.parseEnterResult(e, t, i, n, d);
    }
  }
  matchEnterRule(e, t, i, n, s, o) {
    let a = s;
    for (; a >= 1; ) {
      let c;
      if (a === s && o !== void 0 ? c = o : c = e.getLineContent(a), ll(c) >= 0)
        break;
      a--;
    }
    if (a < 1 || n > e.getLineCount())
      return null;
    const l = e.getLineMaxColumn(a), d = bc(this._autoIndent, e, new S(a, l, a, l), this._languageConfigurationService);
    return this.parseEnterResult(e, t, i, n, d);
  }
  trimStart(e) {
    return e.replace(/^\s+/, "");
  }
  shouldAutoIndent(e, t) {
    if (this._autoIndent < 4 || !e.tokenization.isCheapToTokenize(t.startLineNumber))
      return !1;
    const i = e.getLanguageIdAtPosition(t.startLineNumber, 1), n = e.getLanguageIdAtPosition(t.endLineNumber, 1);
    return !(i !== n || this._languageConfigurationService.getLanguageConfiguration(i).indentRulesSupport === null);
  }
  getIndentEditsOfMovingBlock(e, t, i, n, s, o) {
    for (let a = i.startLineNumber; a <= i.endLineNumber; a++) {
      const l = e.getLineContent(a), d = Ee(l), h = tt(d, n) + o, u = ar(h, n, s);
      u !== d && (t.addEditOperation(new S(a, 1, a, d.length + 1), u), a === i.endLineNumber && i.endColumn <= d.length + 1 && u === "" && (this._moveEndLineSelectionShrink = !0));
    }
  }
  computeCursorState(e, t) {
    let i = t.getTrackedSelection(this._selectionId);
    return this._moveEndPositionDown && (i = i.setEndPosition(i.endLineNumber + 1, 1)), this._moveEndLineSelectionShrink && i.startLineNumber < i.endLineNumber && (i = i.setEndPosition(i.endLineNumber, 2)), i;
  }
};
uu = dR([
  cR(3, fe)
], uu);
class nn {
  static getCollator() {
    return nn._COLLATOR || (nn._COLLATOR = new Intl.Collator()), nn._COLLATOR;
  }
  constructor(e, t) {
    this.selection = e, this.descending = t, this.selectionId = null;
  }
  getEditOperations(e, t) {
    const i = hR(e, this.selection, this.descending);
    i && t.addEditOperation(i.range, i.text), this.selectionId = t.trackSelection(this.selection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this.selectionId);
  }
  static canRun(e, t, i) {
    if (e === null)
      return !1;
    const n = aC(e, t, i);
    if (!n)
      return !1;
    for (let s = 0, o = n.before.length; s < o; s++)
      if (n.before[s] !== n.after[s])
        return !0;
    return !1;
  }
}
nn._COLLATOR = null;
function aC(r, e, t) {
  const i = e.startLineNumber;
  let n = e.endLineNumber;
  if (e.endColumn === 1 && n--, i >= n)
    return null;
  const s = [];
  for (let a = i; a <= n; a++)
    s.push(r.getLineContent(a));
  let o = s.slice(0);
  return o.sort(nn.getCollator().compare), t === !0 && (o = o.reverse()), {
    startLineNumber: i,
    endLineNumber: n,
    before: s,
    after: o
  };
}
function hR(r, e, t) {
  const i = aC(r, e, t);
  return i ? ue.replace(new S(i.startLineNumber, 1, i.endLineNumber, r.getLineMaxColumn(i.endLineNumber)), i.after.join(`
`)) : null;
}
class lC extends D {
  constructor(e, t) {
    super(t), this.down = e;
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getSelections().map((o, a) => ({ selection: o, index: a, ignore: !1 }));
    i.sort((o, a) => S.compareRangesUsingStarts(o.selection, a.selection));
    let n = i[0];
    for (let o = 1; o < i.length; o++) {
      const a = i[o];
      n.selection.endLineNumber === a.selection.startLineNumber && (n.index < a.index ? a.ignore = !0 : (n.ignore = !0, n = a));
    }
    const s = [];
    for (const o of i)
      s.push(new rC(o.selection, this.down, o.ignore));
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
class uR extends lC {
  constructor() {
    super(!1, {
      id: "editor.action.copyLinesUpAction",
      label: g("lines.copyUp", "Copy Line Up"),
      alias: "Copy Line Up",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 1552,
        linux: {
          primary: 3600
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "2_line",
        title: g({ key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"] }, "&&Copy Line Up"),
        order: 1
      }
    });
  }
}
class gR extends lC {
  constructor() {
    super(!0, {
      id: "editor.action.copyLinesDownAction",
      label: g("lines.copyDown", "Copy Line Down"),
      alias: "Copy Line Down",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 1554,
        linux: {
          primary: 3602
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "2_line",
        title: g({ key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"] }, "Co&&py Line Down"),
        order: 2
      }
    });
  }
}
class pR extends D {
  constructor() {
    super({
      id: "editor.action.duplicateSelection",
      label: g("duplicateSelection", "Duplicate Selection"),
      alias: "Duplicate Selection",
      precondition: b.writable,
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "2_line",
        title: g({ key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"] }, "&&Duplicate Selection"),
        order: 5
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = [], s = t.getSelections(), o = t.getModel();
    for (const a of s)
      if (a.isEmpty())
        n.push(new rC(a, !0));
      else {
        const l = new z(a.endLineNumber, a.endColumn, a.endLineNumber, a.endColumn);
        n.push(new ay(l, o.getValueInRange(a)));
      }
    t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop();
  }
}
class dC extends D {
  constructor(e, t) {
    super(t), this.down = e;
  }
  run(e, t) {
    const i = e.get(fe), n = [], s = t.getSelections() || [], o = t.getOption(
      12
      /* EditorOption.autoIndent */
    );
    for (const a of s)
      n.push(new uu(a, this.down, o, i));
    t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop();
  }
}
class fR extends dC {
  constructor() {
    super(!1, {
      id: "editor.action.moveLinesUpAction",
      label: g("lines.moveUp", "Move Line Up"),
      alias: "Move Line Up",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 528,
        linux: {
          primary: 528
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "2_line",
        title: g({ key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"] }, "Mo&&ve Line Up"),
        order: 3
      }
    });
  }
}
class mR extends dC {
  constructor() {
    super(!0, {
      id: "editor.action.moveLinesDownAction",
      label: g("lines.moveDown", "Move Line Down"),
      alias: "Move Line Down",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 530,
        linux: {
          primary: 530
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "2_line",
        title: g({ key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"] }, "Move &&Line Down"),
        order: 4
      }
    });
  }
}
class cC extends D {
  constructor(e, t) {
    super(t), this.descending = e;
  }
  run(e, t) {
    const i = t.getSelections() || [];
    for (const s of i)
      if (!nn.canRun(t.getModel(), s, this.descending))
        return;
    const n = [];
    for (let s = 0, o = i.length; s < o; s++)
      n[s] = new nn(i[s], this.descending);
    t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop();
  }
}
class _R extends cC {
  constructor() {
    super(!1, {
      id: "editor.action.sortLinesAscending",
      label: g("lines.sortAscending", "Sort Lines Ascending"),
      alias: "Sort Lines Ascending",
      precondition: b.writable
    });
  }
}
class vR extends cC {
  constructor() {
    super(!0, {
      id: "editor.action.sortLinesDescending",
      label: g("lines.sortDescending", "Sort Lines Descending"),
      alias: "Sort Lines Descending",
      precondition: b.writable
    });
  }
}
class bR extends D {
  constructor() {
    super({
      id: "editor.action.removeDuplicateLines",
      label: g("lines.deleteDuplicates", "Delete Duplicate Lines"),
      alias: "Delete Duplicate Lines",
      precondition: b.writable
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel();
    if (i.getLineCount() === 1 && i.getLineMaxColumn(1) === 1)
      return;
    const n = [], s = [];
    let o = 0;
    for (const a of t.getSelections()) {
      const l = /* @__PURE__ */ new Set(), d = [];
      for (let p = a.startLineNumber; p <= a.endLineNumber; p++) {
        const f = i.getLineContent(p);
        l.has(f) || (d.push(f), l.add(f));
      }
      const c = new z(a.startLineNumber, 1, a.endLineNumber, i.getLineMaxColumn(a.endLineNumber)), h = a.startLineNumber - o, u = new z(h, 1, h + d.length - 1, d[d.length - 1].length);
      n.push(ue.replace(c, d.join(`
`))), s.push(u), o += a.endLineNumber - a.startLineNumber + 1 - d.length;
    }
    t.pushUndoStop(), t.executeEdits(this.id, n, s), t.pushUndoStop();
  }
}
class ic extends D {
  constructor() {
    super({
      id: ic.ID,
      label: g("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
      alias: "Trim Trailing Whitespace",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: ye(
          2089,
          2102
          /* KeyCode.KeyX */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    let n = [];
    i.reason === "auto-save" && (n = (t.getSelections() || []).map((a) => new F(a.positionLineNumber, a.positionColumn)));
    const s = t.getSelection();
    if (s === null)
      return;
    const o = new aR(s, n);
    t.pushUndoStop(), t.executeCommands(this.id, [o]), t.pushUndoStop();
  }
}
ic.ID = "editor.action.trimTrailingWhitespace";
class CR extends D {
  constructor() {
    super({
      id: "editor.action.deleteLines",
      label: g("lines.delete", "Delete Line"),
      alias: "Delete Line",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 3113,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = this._getLinesToRemove(t), n = t.getModel();
    if (n.getLineCount() === 1 && n.getLineMaxColumn(1) === 1)
      return;
    let s = 0;
    const o = [], a = [];
    for (let l = 0, d = i.length; l < d; l++) {
      const c = i[l];
      let h = c.startLineNumber, u = c.endLineNumber, p = 1, f = n.getLineMaxColumn(u);
      u < n.getLineCount() ? (u += 1, f = 1) : h > 1 && (h -= 1, p = n.getLineMaxColumn(h)), o.push(ue.replace(new z(h, p, u, f), "")), a.push(new z(h - s, c.positionColumn, h - s, c.positionColumn)), s += c.endLineNumber - c.startLineNumber + 1;
    }
    t.pushUndoStop(), t.executeEdits(this.id, o, a), t.pushUndoStop();
  }
  _getLinesToRemove(e) {
    const t = e.getSelections().map((s) => {
      let o = s.endLineNumber;
      return s.startLineNumber < s.endLineNumber && s.endColumn === 1 && (o -= 1), {
        startLineNumber: s.startLineNumber,
        selectionStartColumn: s.selectionStartColumn,
        endLineNumber: o,
        positionColumn: s.positionColumn
      };
    });
    t.sort((s, o) => s.startLineNumber === o.startLineNumber ? s.endLineNumber - o.endLineNumber : s.startLineNumber - o.startLineNumber);
    const i = [];
    let n = t[0];
    for (let s = 1; s < t.length; s++)
      n.endLineNumber + 1 >= t[s].startLineNumber ? n.endLineNumber = t[s].endLineNumber : (i.push(n), n = t[s]);
    return i.push(n), i;
  }
}
class SR extends D {
  constructor() {
    super({
      id: "editor.action.indentLines",
      label: g("lines.indent", "Indent Line"),
      alias: "Indent Line",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 2142,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = t._getViewModel();
    i && (t.pushUndoStop(), t.executeCommands(this.id, Cg.indent(i.cursorConfig, t.getModel(), t.getSelections())), t.pushUndoStop());
  }
}
class wR extends D {
  constructor() {
    super({
      id: "editor.action.outdentLines",
      label: g("lines.outdent", "Outdent Line"),
      alias: "Outdent Line",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 2140,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    al.Outdent.runEditorCommand(e, t, null);
  }
}
class yR extends D {
  constructor() {
    super({
      id: "editor.action.insertLineBefore",
      label: g("lines.insertBefore", "Insert Line Above"),
      alias: "Insert Line Above",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 3075,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = t._getViewModel();
    i && (t.pushUndoStop(), t.executeCommands(this.id, Cg.lineInsertBefore(i.cursorConfig, t.getModel(), t.getSelections())));
  }
}
class xR extends D {
  constructor() {
    super({
      id: "editor.action.insertLineAfter",
      label: g("lines.insertAfter", "Insert Line Below"),
      alias: "Insert Line Below",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 2051,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = t._getViewModel();
    i && (t.pushUndoStop(), t.executeCommands(this.id, Cg.lineInsertAfter(i.cursorConfig, t.getModel(), t.getSelections())));
  }
}
class hC extends D {
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getSelection(), n = this._getRangesToDelete(t), s = [];
    for (let l = 0, d = n.length - 1; l < d; l++) {
      const c = n[l], h = n[l + 1];
      S.intersectRanges(c, h) === null ? s.push(c) : n[l + 1] = S.plusRange(c, h);
    }
    s.push(n[n.length - 1]);
    const o = this._getEndCursorState(i, s), a = s.map((l) => ue.replace(l, ""));
    t.pushUndoStop(), t.executeEdits(this.id, a, o), t.pushUndoStop();
  }
}
class LR extends hC {
  constructor() {
    super({
      id: "deleteAllLeft",
      label: g("lines.deleteAllLeft", "Delete All Left"),
      alias: "Delete All Left",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: {
          primary: 2049
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(e, t) {
    let i = null;
    const n = [];
    let s = 0;
    return t.forEach((o) => {
      let a;
      if (o.endColumn === 1 && s > 0) {
        const l = o.startLineNumber - s;
        a = new z(l, o.startColumn, l, o.startColumn);
      } else
        a = new z(o.startLineNumber, o.startColumn, o.startLineNumber, o.startColumn);
      s += o.endLineNumber - o.startLineNumber, o.intersectRanges(e) ? i = a : n.push(a);
    }), i && n.unshift(i), n;
  }
  _getRangesToDelete(e) {
    const t = e.getSelections();
    if (t === null)
      return [];
    let i = t;
    const n = e.getModel();
    return n === null ? [] : (i.sort(S.compareRangesUsingStarts), i = i.map((s) => {
      if (s.isEmpty())
        if (s.startColumn === 1) {
          const o = Math.max(1, s.startLineNumber - 1), a = s.startLineNumber === 1 ? 1 : n.getLineLength(o) + 1;
          return new S(o, a, s.startLineNumber, 1);
        } else
          return new S(s.startLineNumber, 1, s.startLineNumber, s.startColumn);
      else
        return new S(s.startLineNumber, 1, s.endLineNumber, s.endColumn);
    }), i);
  }
}
class IR extends hC {
  constructor() {
    super({
      id: "deleteAllRight",
      label: g("lines.deleteAllRight", "Delete All Right"),
      alias: "Delete All Right",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: { primary: 297, secondary: [
          2068
          /* KeyCode.Delete */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(e, t) {
    let i = null;
    const n = [];
    for (let s = 0, o = t.length, a = 0; s < o; s++) {
      const l = t[s], d = new z(l.startLineNumber - a, l.startColumn, l.startLineNumber - a, l.startColumn);
      l.intersectRanges(e) ? i = d : n.push(d);
    }
    return i && n.unshift(i), n;
  }
  _getRangesToDelete(e) {
    const t = e.getModel();
    if (t === null)
      return [];
    const i = e.getSelections();
    if (i === null)
      return [];
    const n = i.map((s) => {
      if (s.isEmpty()) {
        const o = t.getLineMaxColumn(s.startLineNumber);
        return s.startColumn === o ? new S(s.startLineNumber, s.startColumn, s.startLineNumber + 1, 1) : new S(s.startLineNumber, s.startColumn, s.startLineNumber, o);
      }
      return s;
    });
    return n.sort(S.compareRangesUsingStarts), n;
  }
}
class DR extends D {
  constructor() {
    super({
      id: "editor.action.joinLines",
      label: g("lines.joinLines", "Join Lines"),
      alias: "Join Lines",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 0,
        mac: {
          primary: 296
          /* KeyCode.KeyJ */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = t.getSelections();
    if (i === null)
      return;
    let n = t.getSelection();
    if (n === null)
      return;
    i.sort(S.compareRangesUsingStarts);
    const s = [], o = i.reduce((u, p) => u.isEmpty() ? u.endLineNumber === p.startLineNumber ? (n.equalsSelection(u) && (n = p), p) : p.startLineNumber > u.endLineNumber + 1 ? (s.push(u), p) : new z(u.startLineNumber, u.startColumn, p.endLineNumber, p.endColumn) : p.startLineNumber > u.endLineNumber ? (s.push(u), p) : new z(u.startLineNumber, u.startColumn, p.endLineNumber, p.endColumn));
    s.push(o);
    const a = t.getModel();
    if (a === null)
      return;
    const l = [], d = [];
    let c = n, h = 0;
    for (let u = 0, p = s.length; u < p; u++) {
      const f = s[u], m = f.startLineNumber, _ = 1;
      let v = 0, C, w;
      const y = a.getLineLength(f.endLineNumber) - f.endColumn;
      if (f.isEmpty() || f.startLineNumber === f.endLineNumber) {
        const N = f.getStartPosition();
        N.lineNumber < a.getLineCount() ? (C = m + 1, w = a.getLineMaxColumn(C)) : (C = N.lineNumber, w = a.getLineMaxColumn(N.lineNumber));
      } else
        C = f.endLineNumber, w = a.getLineMaxColumn(C);
      let I = a.getLineContent(m);
      for (let N = m + 1; N <= C; N++) {
        const J = a.getLineContent(N), te = a.getLineFirstNonWhitespaceColumn(N);
        if (te >= 1) {
          let ve = !0;
          I === "" && (ve = !1), ve && (I.charAt(I.length - 1) === " " || I.charAt(I.length - 1) === "	") && (ve = !1, I = I.replace(/[\s\uFEFF\xA0]+$/g, " "));
          const be = J.substr(te - 1);
          I += (ve ? " " : "") + be, ve ? v = be.length + 1 : v = be.length;
        } else
          v = 0;
      }
      const k = new S(m, _, C, w);
      if (!k.isEmpty()) {
        let N;
        f.isEmpty() ? (l.push(ue.replace(k, I)), N = new z(k.startLineNumber - h, I.length - v + 1, m - h, I.length - v + 1)) : f.startLineNumber === f.endLineNumber ? (l.push(ue.replace(k, I)), N = new z(f.startLineNumber - h, f.startColumn, f.endLineNumber - h, f.endColumn)) : (l.push(ue.replace(k, I)), N = new z(f.startLineNumber - h, f.startColumn, f.startLineNumber - h, I.length - y)), S.intersectRanges(k, n) !== null ? c = N : d.push(N);
      }
      h += k.endLineNumber - k.startLineNumber;
    }
    d.unshift(c), t.pushUndoStop(), t.executeEdits(this.id, l, d), t.pushUndoStop();
  }
}
class kR extends D {
  constructor() {
    super({
      id: "editor.action.transpose",
      label: g("editor.transpose", "Transpose Characters around the Cursor"),
      alias: "Transpose Characters around the Cursor",
      precondition: b.writable
    });
  }
  run(e, t) {
    const i = t.getSelections();
    if (i === null)
      return;
    const n = t.getModel();
    if (n === null)
      return;
    const s = [];
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      if (!l.isEmpty())
        continue;
      const d = l.getStartPosition(), c = n.getLineMaxColumn(d.lineNumber);
      if (d.column >= c) {
        if (d.lineNumber === n.getLineCount())
          continue;
        const h = new S(d.lineNumber, Math.max(1, d.column - 1), d.lineNumber + 1, 1), u = n.getValueInRange(h).split("").reverse().join("");
        s.push(new Gr(new z(d.lineNumber, Math.max(1, d.column - 1), d.lineNumber + 1, 1), u));
      } else {
        const h = new S(d.lineNumber, Math.max(1, d.column - 1), d.lineNumber, d.column + 1), u = n.getValueInRange(h).split("").reverse().join("");
        s.push(new r_(h, u, new z(d.lineNumber, d.column + 1, d.lineNumber, d.column + 1)));
      }
    }
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
class yo extends D {
  run(e, t) {
    const i = t.getSelections();
    if (i === null)
      return;
    const n = t.getModel();
    if (n === null)
      return;
    const s = t.getOption(
      130
      /* EditorOption.wordSeparators */
    ), o = [];
    for (const a of i)
      if (a.isEmpty()) {
        const l = a.getStartPosition(), d = t.getConfiguredWordAtPosition(l);
        if (!d)
          continue;
        const c = new S(l.lineNumber, d.startColumn, l.lineNumber, d.endColumn), h = n.getValueInRange(c);
        o.push(ue.replace(c, this._modifyText(h, s)));
      } else {
        const l = n.getValueInRange(a);
        o.push(ue.replace(a, this._modifyText(l, s)));
      }
    t.pushUndoStop(), t.executeEdits(this.id, o), t.pushUndoStop();
  }
}
class NR extends yo {
  constructor() {
    super({
      id: "editor.action.transformToUppercase",
      label: g("editor.transformToUppercase", "Transform to Uppercase"),
      alias: "Transform to Uppercase",
      precondition: b.writable
    });
  }
  _modifyText(e, t) {
    return e.toLocaleUpperCase();
  }
}
class RR extends yo {
  constructor() {
    super({
      id: "editor.action.transformToLowercase",
      label: g("editor.transformToLowercase", "Transform to Lowercase"),
      alias: "Transform to Lowercase",
      precondition: b.writable
    });
  }
  _modifyText(e, t) {
    return e.toLocaleLowerCase();
  }
}
class ds {
  constructor(e, t) {
    this._pattern = e, this._flags = t, this._actual = null, this._evaluated = !1;
  }
  get() {
    if (!this._evaluated) {
      this._evaluated = !0;
      try {
        this._actual = new RegExp(this._pattern, this._flags);
      } catch {
      }
    }
    return this._actual;
  }
  isSupported() {
    return this.get() !== null;
  }
}
class Fr extends yo {
  constructor() {
    super({
      id: "editor.action.transformToTitlecase",
      label: g("editor.transformToTitlecase", "Transform to Title Case"),
      alias: "Transform to Title Case",
      precondition: b.writable
    });
  }
  _modifyText(e, t) {
    const i = Fr.titleBoundary.get();
    return i ? e.toLocaleLowerCase().replace(i, (n) => n.toLocaleUpperCase()) : e;
  }
}
Fr.titleBoundary = new ds("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
class sn extends yo {
  constructor() {
    super({
      id: "editor.action.transformToSnakecase",
      label: g("editor.transformToSnakecase", "Transform to Snake Case"),
      alias: "Transform to Snake Case",
      precondition: b.writable
    });
  }
  _modifyText(e, t) {
    const i = sn.caseBoundary.get(), n = sn.singleLetters.get();
    return !i || !n ? e : e.replace(i, "$1_$2").replace(n, "$1_$2$3").toLocaleLowerCase();
  }
}
sn.caseBoundary = new ds("(\\p{Ll})(\\p{Lu})", "gmu");
sn.singleLetters = new ds("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
class Wr extends yo {
  constructor() {
    super({
      id: "editor.action.transformToCamelcase",
      label: g("editor.transformToCamelcase", "Transform to Camel Case"),
      alias: "Transform to Camel Case",
      precondition: b.writable
    });
  }
  _modifyText(e, t) {
    const i = Wr.wordBoundary.get();
    if (!i)
      return e;
    const n = e.split(i);
    return n.shift() + n.map((o) => o.substring(0, 1).toLocaleUpperCase() + o.substring(1)).join("");
  }
}
Wr.wordBoundary = new ds("[_\\s-]", "gm");
class Li extends yo {
  static isSupported() {
    return [
      this.caseBoundary,
      this.singleLetters,
      this.underscoreBoundary
    ].every((t) => t.isSupported());
  }
  constructor() {
    super({
      id: "editor.action.transformToKebabcase",
      label: g("editor.transformToKebabcase", "Transform to Kebab Case"),
      alias: "Transform to Kebab Case",
      precondition: b.writable
    });
  }
  _modifyText(e, t) {
    const i = Li.caseBoundary.get(), n = Li.singleLetters.get(), s = Li.underscoreBoundary.get();
    return !i || !n || !s ? e : e.replace(s, "$1-$3").replace(i, "$1-$2").replace(n, "$1-$2").toLocaleLowerCase();
  }
}
Li.caseBoundary = new ds("(\\p{Ll})(\\p{Lu})", "gmu");
Li.singleLetters = new ds("(\\p{Lu}|\\p{N})(\\p{Lu}\\p{Ll})", "gmu");
Li.underscoreBoundary = new ds("(\\S)(_)(\\S)", "gm");
x(uR);
x(gR);
x(pR);
x(fR);
x(mR);
x(_R);
x(vR);
x(bR);
x(ic);
x(CR);
x(SR);
x(wR);
x(yR);
x(xR);
x(LR);
x(IR);
x(DR);
x(kR);
x(NR);
x(RR);
sn.caseBoundary.isSupported() && sn.singleLetters.isSupported() && x(sn);
Wr.wordBoundary.isSupported() && x(Wr);
Fr.titleBoundary.isSupported() && x(Fr);
Li.isSupported() && x(Li);
var PR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ja = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, ml;
const uC = new Q("LinkedEditingInputVisible", !1), MR = "linked-editing-decoration";
let mn = ml = class extends P {
  static get(e) {
    return e.getContribution(ml.ID);
  }
  constructor(e, t, i, n, s) {
    super(), this.languageConfigurationService = n, this._syncRangesToken = 0, this._localToDispose = this._register(new M()), this._editor = e, this._providers = i.linkedEditingRangeProvider, this._enabled = !1, this._visibleContextKey = uC.bindTo(t), this._debounceInformation = s.for(this._providers, "Linked Editing", { max: 200 }), this._currentDecorations = this._editor.createDecorationsCollection(), this._languageWordPattern = null, this._currentWordPattern = null, this._ignoreChangeEvent = !1, this._localToDispose = this._register(new M()), this._rangeUpdateTriggerPromise = null, this._rangeSyncTriggerPromise = null, this._currentRequestCts = null, this._currentRequestPosition = null, this._currentRequestModelVersion = null, this._register(this._editor.onDidChangeModel(() => this.reinitialize(!0))), this._register(this._editor.onDidChangeConfiguration((o) => {
      (o.hasChanged(
        70
        /* EditorOption.linkedEditing */
      ) || o.hasChanged(
        93
        /* EditorOption.renameOnType */
      )) && this.reinitialize(!1);
    })), this._register(this._providers.onDidChange(() => this.reinitialize(!1))), this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(!0))), this.reinitialize(!0);
  }
  reinitialize(e) {
    const t = this._editor.getModel(), i = t !== null && (this._editor.getOption(
      70
      /* EditorOption.linkedEditing */
    ) || this._editor.getOption(
      93
      /* EditorOption.renameOnType */
    )) && this._providers.has(t);
    if (i === this._enabled && !e || (this._enabled = i, this.clearRanges(), this._localToDispose.clear(), !i || t === null))
      return;
    this._localToDispose.add(De.runAndSubscribe(t.onDidChangeLanguageConfiguration, () => {
      this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(t.getLanguageId()).getWordDefinition();
    }));
    const n = new Vn(this._debounceInformation.get(t)), s = () => {
      var l;
      this._rangeUpdateTriggerPromise = n.trigger(() => this.updateRanges(), (l = this._debounceDuration) !== null && l !== void 0 ? l : this._debounceInformation.get(t));
    }, o = new Vn(0), a = (l) => {
      this._rangeSyncTriggerPromise = o.trigger(() => this._syncRanges(l));
    };
    this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
      s();
    })), this._localToDispose.add(this._editor.onDidChangeModelContent((l) => {
      if (!this._ignoreChangeEvent && this._currentDecorations.length > 0) {
        const d = this._currentDecorations.getRange(0);
        if (d && l.changes.every((c) => d.intersectRanges(c.range))) {
          a(this._syncRangesToken);
          return;
        }
      }
      s();
    })), this._localToDispose.add({
      dispose: () => {
        n.dispose(), o.dispose();
      }
    }), this.updateRanges();
  }
  _syncRanges(e) {
    if (!this._editor.hasModel() || e !== this._syncRangesToken || this._currentDecorations.length === 0)
      return;
    const t = this._editor.getModel(), i = this._currentDecorations.getRange(0);
    if (!i || i.startLineNumber !== i.endLineNumber)
      return this.clearRanges();
    const n = t.getValueInRange(i);
    if (this._currentWordPattern) {
      const o = n.match(this._currentWordPattern);
      if ((o ? o[0].length : 0) !== n.length)
        return this.clearRanges();
    }
    const s = [];
    for (let o = 1, a = this._currentDecorations.length; o < a; o++) {
      const l = this._currentDecorations.getRange(o);
      if (l)
        if (l.startLineNumber !== l.endLineNumber)
          s.push({
            range: l,
            text: n
          });
        else {
          let d = t.getValueInRange(l), c = n, h = l.startColumn, u = l.endColumn;
          const p = ta(d, c);
          h += p, d = d.substr(p), c = c.substr(p);
          const f = ly(d, c);
          u -= f, d = d.substr(0, d.length - f), c = c.substr(0, c.length - f), (h !== u || c.length !== 0) && s.push({
            range: new S(l.startLineNumber, h, l.endLineNumber, u),
            text: c
          });
        }
    }
    if (s.length !== 0)
      try {
        this._editor.popUndoStop(), this._ignoreChangeEvent = !0;
        const o = this._editor._getViewModel().getPrevEditOperationType();
        this._editor.executeEdits("linkedEditing", s), this._editor._getViewModel().setPrevEditOperationType(o);
      } finally {
        this._ignoreChangeEvent = !1;
      }
  }
  dispose() {
    this.clearRanges(), super.dispose();
  }
  clearRanges() {
    this._visibleContextKey.set(!1), this._currentDecorations.clear(), this._currentRequestCts && (this._currentRequestCts.cancel(), this._currentRequestCts = null, this._currentRequestPosition = null);
  }
  async updateRanges(e = !1) {
    if (!this._editor.hasModel()) {
      this.clearRanges();
      return;
    }
    const t = this._editor.getPosition();
    if (!this._enabled && !e || this._editor.getSelections().length > 1) {
      this.clearRanges();
      return;
    }
    const i = this._editor.getModel(), n = i.getVersionId();
    if (this._currentRequestPosition && this._currentRequestModelVersion === n) {
      if (t.equals(this._currentRequestPosition))
        return;
      if (this._currentDecorations.length > 0) {
        const o = this._currentDecorations.getRange(0);
        if (o && o.containsPosition(t))
          return;
      }
    }
    this.clearRanges(), this._currentRequestPosition = t, this._currentRequestModelVersion = n;
    const s = this._currentRequestCts = new Oe();
    try {
      const o = new Rt(!1), a = await gC(this._providers, i, t, s.token);
      if (this._debounceInformation.update(i, o.elapsed()), s !== this._currentRequestCts || (this._currentRequestCts = null, n !== i.getVersionId()))
        return;
      let l = [];
      a != null && a.ranges && (l = a.ranges), this._currentWordPattern = (a == null ? void 0 : a.wordPattern) || this._languageWordPattern;
      let d = !1;
      for (let h = 0, u = l.length; h < u; h++)
        if (S.containsPosition(l[h], t)) {
          if (d = !0, h !== 0) {
            const p = l[h];
            l.splice(h, 1), l.unshift(p);
          }
          break;
        }
      if (!d) {
        this.clearRanges();
        return;
      }
      const c = l.map((h) => ({ range: h, options: ml.DECORATION }));
      this._visibleContextKey.set(!0), this._currentDecorations.set(c), this._syncRangesToken++;
    } catch (o) {
      go(o) || re(o), (this._currentRequestCts === s || !this._currentRequestCts) && this.clearRanges();
    }
  }
};
mn.ID = "editor.contrib.linkedEditing";
mn.DECORATION = Y.register({
  description: "linked-editing",
  stickiness: 0,
  className: MR
});
mn = ml = PR([
  Ja(1, ee),
  Ja(2, V),
  Ja(3, fe),
  Ja(4, Pt)
], mn);
class ER extends D {
  constructor() {
    super({
      id: "editor.action.linkedEditing",
      label: g("linkedEditing.label", "Start Linked Editing"),
      alias: "Start Linked Editing",
      precondition: L.and(b.writable, b.hasRenameProvider),
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 3132,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  runCommand(e, t) {
    const i = e.get(_e), [n, s] = Array.isArray(t) && t || [void 0, void 0];
    return ce.isUri(n) && F.isIPosition(s) ? i.openCodeEditor({ resource: n }, i.getActiveCodeEditor()).then((o) => {
      o && (o.setPosition(s), o.invokeWithinContext((a) => (this.reportTelemetry(a, o), this.run(a, o))));
    }, re) : super.runCommand(e, t);
  }
  run(e, t) {
    const i = mn.get(t);
    return i ? Promise.resolve(i.updateRanges(!0)) : Promise.resolve();
  }
}
const TR = bt.bindToContribution(mn.get);
B(new TR({
  id: "cancelLinkedEditingInput",
  precondition: uC,
  handler: (r) => r.clearRanges(),
  kbOpts: {
    kbExpr: b.editorTextFocus,
    weight: 199,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
function gC(r, e, t, i) {
  const n = r.ordered(e);
  return Sg(n.map((s) => async () => {
    try {
      return await s.provideLinkedEditingRanges(e, t, i);
    } catch (o) {
      Ie(o);
      return;
    }
  }), (s) => !!s && nt(s == null ? void 0 : s.ranges));
}
W("editor.linkedEditingBackground", { dark: K.fromHex("#f00").transparent(0.3), light: K.fromHex("#f00").transparent(0.3), hcDark: K.fromHex("#f00").transparent(0.3), hcLight: K.white }, g("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
pi("_executeLinkedEditingProvider", (r, e, t) => {
  const { linkedEditingRangeProvider: i } = r.get(V);
  return gC(i, e, t, X.None);
});
Z(
  mn.ID,
  mn,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
x(ER);
let AR = class {
  constructor(e, t) {
    this._link = e, this._provider = t;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  async resolve(e) {
    return this._link.url ? this._link.url : typeof this._provider.resolveLink == "function" ? Promise.resolve(this._provider.resolveLink(this._link, e)).then((t) => (this._link = t || this._link, this._link.url ? this.resolve(e) : Promise.reject(new Error("missing")))) : Promise.reject(new Error("missing"));
  }
};
class Gl {
  constructor(e) {
    this._disposables = new M();
    let t = [];
    for (const [i, n] of e) {
      const s = i.links.map((o) => new AR(o, n));
      t = Gl._union(t, s), D_(i) && this._disposables.add(i);
    }
    this.links = t;
  }
  dispose() {
    this._disposables.dispose(), this.links.length = 0;
  }
  static _union(e, t) {
    const i = [];
    let n, s, o, a;
    for (n = 0, o = 0, s = e.length, a = t.length; n < s && o < a; ) {
      const l = e[n], d = t[o];
      if (S.areIntersectingOrTouching(l.range, d.range)) {
        n++;
        continue;
      }
      S.compareRangesUsingStarts(l.range, d.range) < 0 ? (i.push(l), n++) : (i.push(d), o++);
    }
    for (; n < s; n++)
      i.push(e[n]);
    for (; o < a; o++)
      i.push(t[o]);
    return i;
  }
}
function pC(r, e, t) {
  const i = [], n = r.ordered(e).reverse().map((s, o) => Promise.resolve(s.provideLinks(e, t)).then((a) => {
    a && (i[o] = [a, s]);
  }, Ie));
  return Promise.all(n).then(() => {
    const s = new Gl(Ii(i));
    return t.isCancellationRequested ? (s.dispose(), new Gl([])) : s;
  });
}
de.registerCommand("_executeLinkProvider", async (r, ...e) => {
  let [t, i] = e;
  ie(t instanceof ce), typeof i != "number" && (i = 0);
  const { linkProvider: n } = r.get(V), s = r.get(Ge).getModel(t);
  if (!s)
    return [];
  const o = await pC(n, s, X.None);
  if (!o)
    return [];
  for (let l = 0; l < Math.min(i, o.links.length); l++)
    await o.links[l].resolve(X.None);
  const a = o.links.slice(0);
  return o.dispose(), a;
});
var OR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, el = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, gu;
let so = gu = class extends P {
  static get(e) {
    return e.getContribution(gu.ID);
  }
  constructor(e, t, i, n, s) {
    super(), this.editor = e, this.openerService = t, this.notificationService = i, this.languageFeaturesService = n, this.providers = this.languageFeaturesService.linkProvider, this.debounceInformation = s.for(this.providers, "Links", { min: 1e3, max: 4e3 }), this.computeLinks = this._register(new Re(() => this.computeLinksNow(), 1e3)), this.computePromise = null, this.activeLinksList = null, this.currentOccurrences = {}, this.activeLinkDecorationId = null;
    const o = this._register(new Ld(e));
    this._register(o.onMouseMoveOrRelevantKeyDown(([a, l]) => {
      this._onEditorMouseMove(a, l);
    })), this._register(o.onExecute((a) => {
      this.onEditorMouseUp(a);
    })), this._register(o.onCancel((a) => {
      this.cleanUpActiveLinkDecoration();
    })), this._register(e.onDidChangeConfiguration((a) => {
      a.hasChanged(
        71
        /* EditorOption.links */
      ) && (this.updateDecorations([]), this.stop(), this.computeLinks.schedule(0));
    })), this._register(e.onDidChangeModelContent((a) => {
      this.editor.hasModel() && this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
    })), this._register(e.onDidChangeModel((a) => {
      this.currentOccurrences = {}, this.activeLinkDecorationId = null, this.stop(), this.computeLinks.schedule(0);
    })), this._register(e.onDidChangeModelLanguage((a) => {
      this.stop(), this.computeLinks.schedule(0);
    })), this._register(this.providers.onDidChange((a) => {
      this.stop(), this.computeLinks.schedule(0);
    })), this.computeLinks.schedule(0);
  }
  async computeLinksNow() {
    if (!this.editor.hasModel() || !this.editor.getOption(
      71
      /* EditorOption.links */
    ))
      return;
    const e = this.editor.getModel();
    if (!e.isTooLargeForSyncing() && this.providers.has(e)) {
      this.activeLinksList && (this.activeLinksList.dispose(), this.activeLinksList = null), this.computePromise = Pe((t) => pC(this.providers, e, t));
      try {
        const t = new Rt(!1);
        if (this.activeLinksList = await this.computePromise, this.debounceInformation.update(e, t.elapsed()), e.isDisposed())
          return;
        this.updateDecorations(this.activeLinksList.links);
      } catch (t) {
        re(t);
      } finally {
        this.computePromise = null;
      }
    }
  }
  updateDecorations(e) {
    const t = this.editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    ) === "altKey", i = [], n = Object.keys(this.currentOccurrences);
    for (const o of n) {
      const a = this.currentOccurrences[o];
      i.push(a.decorationId);
    }
    const s = [];
    if (e)
      for (const o of e)
        s.push(Ws.decoration(o, t));
    this.editor.changeDecorations((o) => {
      const a = o.deltaDecorations(i, s);
      this.currentOccurrences = {}, this.activeLinkDecorationId = null;
      for (let l = 0, d = a.length; l < d; l++) {
        const c = new Ws(e[l], a[l]);
        this.currentOccurrences[c.decorationId] = c;
      }
    });
  }
  _onEditorMouseMove(e, t) {
    const i = this.editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.isEnabled(e, t)) {
      this.cleanUpActiveLinkDecoration();
      const n = this.getLinkOccurrence(e.target.position);
      n && this.editor.changeDecorations((s) => {
        n.activate(s, i), this.activeLinkDecorationId = n.decorationId;
      });
    } else
      this.cleanUpActiveLinkDecoration();
  }
  cleanUpActiveLinkDecoration() {
    const e = this.editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.activeLinkDecorationId) {
      const t = this.currentOccurrences[this.activeLinkDecorationId];
      t && this.editor.changeDecorations((i) => {
        t.deactivate(i, e);
      }), this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(e) {
    if (!this.isEnabled(e))
      return;
    const t = this.getLinkOccurrence(e.target.position);
    t && this.openLinkOccurrence(
      t,
      e.hasSideBySideModifier,
      !0
      /* from user gesture */
    );
  }
  openLinkOccurrence(e, t, i = !1) {
    if (!this.openerService)
      return;
    const { link: n } = e;
    n.resolve(X.None).then((s) => {
      if (typeof s == "string" && this.editor.hasModel()) {
        const o = this.editor.getModel().uri;
        if (o.scheme === wt.file && s.startsWith(`${wt.file}:`)) {
          const a = ce.parse(s);
          if (a.scheme === wt.file) {
            const l = dy(a);
            let d = null;
            l.startsWith("/./") ? d = `.${l.substr(1)}` : l.startsWith("//./") && (d = `.${l.substr(2)}`), d && (s = cy(o, d));
          }
        }
      }
      return this.openerService.open(s, { openToSide: t, fromUserGesture: i, allowContributedOpeners: !0, allowCommands: !0, fromWorkspace: !0 });
    }, (s) => {
      const o = s instanceof Error ? s.message : s;
      o === "invalid" ? this.notificationService.warn(g("invalid.url", "Failed to open this link because it is not well-formed: {0}", n.url.toString())) : o === "missing" ? this.notificationService.warn(g("missing.url", "Failed to open this link because its target is missing.")) : re(s);
    });
  }
  getLinkOccurrence(e) {
    if (!this.editor.hasModel() || !e)
      return null;
    const t = this.editor.getModel().getDecorationsInRange({
      startLineNumber: e.lineNumber,
      startColumn: e.column,
      endLineNumber: e.lineNumber,
      endColumn: e.column
    }, 0, !0);
    for (const i of t) {
      const n = this.currentOccurrences[i.id];
      if (n)
        return n;
    }
    return null;
  }
  isEnabled(e, t) {
    return !!(e.target.type === 6 && (e.hasTriggerModifier || t && t.keyCodeIsTriggerKey));
  }
  stop() {
    var e;
    this.computeLinks.cancel(), this.activeLinksList && ((e = this.activeLinksList) === null || e === void 0 || e.dispose(), this.activeLinksList = null), this.computePromise && (this.computePromise.cancel(), this.computePromise = null);
  }
  dispose() {
    super.dispose(), this.stop();
  }
};
so.ID = "editor.linkDetector";
so = gu = OR([
  el(1, Gt),
  el(2, Je),
  el(3, V),
  el(4, Pt)
], so);
const gm = {
  general: Y.register({
    description: "detected-link",
    stickiness: 1,
    collapseOnReplaceEdit: !0,
    inlineClassName: "detected-link"
  }),
  active: Y.register({
    description: "detected-link-active",
    stickiness: 1,
    collapseOnReplaceEdit: !0,
    inlineClassName: "detected-link-active"
  })
};
class Ws {
  static decoration(e, t) {
    return {
      range: e.range,
      options: Ws._getOptions(e, t, !1)
    };
  }
  static _getOptions(e, t, i) {
    const n = { ...i ? gm.active : gm.general };
    return n.hoverMessage = FR(e, t), n;
  }
  constructor(e, t) {
    this.link = e, this.decorationId = t;
  }
  activate(e, t) {
    e.changeDecorationOptions(this.decorationId, Ws._getOptions(this.link, t, !0));
  }
  deactivate(e, t) {
    e.changeDecorationOptions(this.decorationId, Ws._getOptions(this.link, t, !1));
  }
}
function FR(r, e) {
  const t = r.url && /^command:/i.test(r.url.toString()), i = r.tooltip ? r.tooltip : t ? g("links.navigate.executeCmd", "Execute command") : g("links.navigate.follow", "Follow link"), n = e ? si ? g("links.navigate.kb.meta.mac", "cmd + click") : g("links.navigate.kb.meta", "ctrl + click") : si ? g("links.navigate.kb.alt.mac", "option + click") : g("links.navigate.kb.alt", "alt + click");
  if (r.url) {
    let s = "";
    if (/^command:/i.test(r.url.toString())) {
      const a = r.url.toString().match(/^command:([^?#]+)/);
      if (a) {
        const l = a[1];
        s = g("tooltip.explanation", "Execute command {0}", l);
      }
    }
    return new Ue("", !0).appendLink(r.url.toString(!0).replace(/ /g, "%20"), i, s).appendMarkdown(` (${n})`);
  } else
    return new Ue().appendText(`${i} (${n})`);
}
class WR extends D {
  constructor() {
    super({
      id: "editor.action.openLink",
      label: g("label", "Open Link"),
      alias: "Open Link",
      precondition: void 0
    });
  }
  run(e, t) {
    const i = so.get(t);
    if (!i || !t.hasModel())
      return;
    const n = t.getSelections();
    for (const s of n) {
      const o = i.getLinkOccurrence(s.getEndPosition());
      o && i.openLinkOccurrence(o, !1);
    }
  }
}
Z(
  so.ID,
  so,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
x(WR);
class pu extends P {
  constructor(e) {
    super(), this._editor = e, this._register(this._editor.onMouseDown((t) => {
      const i = this._editor.getOption(
        117
        /* EditorOption.stopRenderingLineAfter */
      );
      i >= 0 && t.target.type === 6 && t.target.position.column >= i && this._editor.updateOptions({
        stopRenderingLineAfter: -1
      });
    }));
  }
}
pu.ID = "editor.contrib.longLinesHelper";
Z(
  pu.ID,
  pu,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
const tl = W("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hcDark: null, hcLight: null }, g("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), !0);
W("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hcDark: null, hcLight: null }, g("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), !0);
W("editor.wordHighlightTextBackground", { light: tl, dark: tl, hcDark: tl, hcLight: tl }, g("wordHighlightText", "Background color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), !0);
const il = W("editor.wordHighlightBorder", { light: null, dark: null, hcDark: Hn, hcLight: Hn }, g("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
W("editor.wordHighlightStrongBorder", { light: null, dark: null, hcDark: Hn, hcLight: Hn }, g("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
W("editor.wordHighlightTextBorder", { light: il, dark: il, hcDark: il, hcLight: il }, g("wordHighlightTextBorder", "Border color of a textual occurrence for a symbol."));
const HR = W("editorOverviewRuler.wordHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hcDark: "#A0A0A0CC", hcLight: "#A0A0A0CC" }, g("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), !0), BR = W("editorOverviewRuler.wordHighlightStrongForeground", { dark: "#C0A0C0CC", light: "#C0A0C0CC", hcDark: "#C0A0C0CC", hcLight: "#C0A0C0CC" }, g("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), !0), VR = W("editorOverviewRuler.wordHighlightTextForeground", { dark: zo, light: zo, hcDark: zo, hcLight: zo }, g("overviewRulerWordHighlightTextForeground", "Overview ruler marker color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), !0), UR = Y.register({
  description: "word-highlight-strong",
  stickiness: 1,
  className: "wordHighlightStrong",
  overviewRuler: {
    color: Se(BR),
    position: ci.Center
  },
  minimap: {
    color: Se(cd),
    position: ns.Inline
  }
}), zR = Y.register({
  description: "word-highlight-text",
  stickiness: 1,
  className: "wordHighlightText",
  overviewRuler: {
    color: Se(VR),
    position: ci.Center
  },
  minimap: {
    color: Se(cd),
    position: ns.Inline
  }
}), $R = Y.register({
  description: "selection-highlight-overview",
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: Se(zo),
    position: ci.Center
  },
  minimap: {
    color: Se(cd),
    position: ns.Inline
  }
}), jR = Y.register({
  description: "selection-highlight",
  stickiness: 1,
  className: "selectionHighlight"
}), qR = Y.register({
  description: "word-highlight",
  stickiness: 1,
  className: "wordHighlight",
  overviewRuler: {
    color: Se(HR),
    position: ci.Center
  },
  minimap: {
    color: Se(cd),
    position: ns.Inline
  }
});
function KR(r) {
  return r === oh.Write ? UR : r === oh.Text ? zR : qR;
}
function GR(r) {
  return r ? jR : $R;
}
od((r, e) => {
  const t = r.getColor(hy);
  t && e.addRule(`.monaco-editor .selectionHighlight { background-color: ${t.transparent(0.5)}; }`);
});
var ZR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, XR = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, fu;
function Cn(r, e) {
  const t = e.filter((i) => !r.find((n) => n.equals(i)));
  if (t.length >= 1) {
    const i = t.map((s) => `line ${s.viewState.position.lineNumber} column ${s.viewState.position.column}`).join(", "), n = t.length === 1 ? g("cursorAdded", "Cursor added: {0}", i) : g("cursorsAdded", "Cursors added: {0}", i);
    zs(n);
  }
}
class QR extends D {
  constructor() {
    super({
      id: "editor.action.insertCursorAbove",
      label: g("mutlicursor.insertAbove", "Add Cursor Above"),
      alias: "Add Cursor Above",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 2576,
        linux: {
          primary: 1552,
          secondary: [
            3088
            /* KeyCode.UpArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "3_multi",
        title: g({ key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"] }, "&&Add Cursor Above"),
        order: 2
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    let n = !0;
    i && i.logicalLine === !1 && (n = !1);
    const s = t._getViewModel();
    if (s.cursorConfig.readOnly)
      return;
    s.model.pushStackElement();
    const o = s.getCursorStates();
    s.setCursorStates(i.source, 3, bg.addCursorUp(s, o, n)), s.revealTopMostCursor(i.source), Cn(o, s.getCursorStates());
  }
}
class YR extends D {
  constructor() {
    super({
      id: "editor.action.insertCursorBelow",
      label: g("mutlicursor.insertBelow", "Add Cursor Below"),
      alias: "Add Cursor Below",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 2578,
        linux: {
          primary: 1554,
          secondary: [
            3090
            /* KeyCode.DownArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "3_multi",
        title: g({ key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"] }, "A&&dd Cursor Below"),
        order: 3
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    let n = !0;
    i && i.logicalLine === !1 && (n = !1);
    const s = t._getViewModel();
    if (s.cursorConfig.readOnly)
      return;
    s.model.pushStackElement();
    const o = s.getCursorStates();
    s.setCursorStates(i.source, 3, bg.addCursorDown(s, o, n)), s.revealBottomMostCursor(i.source), Cn(o, s.getCursorStates());
  }
}
class JR extends D {
  constructor() {
    super({
      id: "editor.action.insertCursorAtEndOfEachLineSelected",
      label: g("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
      alias: "Add Cursors to Line Ends",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 1575,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "3_multi",
        title: g({ key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"] }, "Add C&&ursors to Line Ends"),
        order: 4
      }
    });
  }
  getCursorsForSelection(e, t, i) {
    if (!e.isEmpty()) {
      for (let n = e.startLineNumber; n < e.endLineNumber; n++) {
        const s = t.getLineMaxColumn(n);
        i.push(new z(n, s, n, s));
      }
      e.endColumn > 1 && i.push(new z(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn));
    }
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel(), n = t.getSelections(), s = t._getViewModel(), o = s.getCursorStates(), a = [];
    n.forEach((l) => this.getCursorsForSelection(l, i, a)), a.length > 0 && t.setSelections(a), Cn(o, s.getCursorStates());
  }
}
class eP extends D {
  constructor() {
    super({
      id: "editor.action.addCursorsToBottom",
      label: g("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
      alias: "Add Cursors To Bottom",
      precondition: void 0
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getSelections(), n = t.getModel().getLineCount(), s = [];
    for (let l = i[0].startLineNumber; l <= n; l++)
      s.push(new z(l, i[0].startColumn, l, i[0].endColumn));
    const o = t._getViewModel(), a = o.getCursorStates();
    s.length > 0 && t.setSelections(s), Cn(a, o.getCursorStates());
  }
}
class tP extends D {
  constructor() {
    super({
      id: "editor.action.addCursorsToTop",
      label: g("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
      alias: "Add Cursors To Top",
      precondition: void 0
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getSelections(), n = [];
    for (let a = i[0].startLineNumber; a >= 1; a--)
      n.push(new z(a, i[0].startColumn, a, i[0].endColumn));
    const s = t._getViewModel(), o = s.getCursorStates();
    n.length > 0 && t.setSelections(n), Cn(o, s.getCursorStates());
  }
}
class nl {
  constructor(e, t, i) {
    this.selections = e, this.revealRange = t, this.revealScrollType = i;
  }
}
class Hr {
  static create(e, t) {
    if (!e.hasModel())
      return null;
    const i = t.getState();
    if (!e.hasTextFocus() && i.isRevealed && i.searchString.length > 0)
      return new Hr(e, t, !1, i.searchString, i.wholeWord, i.matchCase, null);
    let n = !1, s, o;
    const a = e.getSelections();
    a.length === 1 && a[0].isEmpty() ? (n = !0, s = !0, o = !0) : (s = i.wholeWord, o = i.matchCase);
    const l = e.getSelection();
    let d, c = null;
    if (l.isEmpty()) {
      const h = e.getConfiguredWordAtPosition(l.getStartPosition());
      if (!h)
        return null;
      d = h.word, c = new z(l.startLineNumber, h.startColumn, l.startLineNumber, h.endColumn);
    } else
      d = e.getModel().getValueInRange(l).replace(/\r\n/g, `
`);
    return new Hr(e, t, n, d, s, o, c);
  }
  constructor(e, t, i, n, s, o, a) {
    this._editor = e, this.findController = t, this.isDisconnectedFromFindController = i, this.searchText = n, this.wholeWord = s, this.matchCase = o, this.currentMatch = a;
  }
  addSelectionToNextFindMatch() {
    if (!this._editor.hasModel())
      return null;
    const e = this._getNextMatch();
    if (!e)
      return null;
    const t = this._editor.getSelections();
    return new nl(
      t.concat(e),
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToNextFindMatch() {
    if (!this._editor.hasModel())
      return null;
    const e = this._getNextMatch();
    if (!e)
      return null;
    const t = this._editor.getSelections();
    return new nl(
      t.slice(0, t.length - 1).concat(e),
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  _getNextMatch() {
    if (!this._editor.hasModel())
      return null;
    if (this.currentMatch) {
      const n = this.currentMatch;
      return this.currentMatch = null, n;
    }
    this.findController.highlightFindOptions();
    const e = this._editor.getSelections(), t = e[e.length - 1], i = this._editor.getModel().findNextMatch(this.searchText, t.getEndPosition(), !1, this.matchCase, this.wholeWord ? this._editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null, !1);
    return i ? new z(i.range.startLineNumber, i.range.startColumn, i.range.endLineNumber, i.range.endColumn) : null;
  }
  addSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel())
      return null;
    const e = this._getPreviousMatch();
    if (!e)
      return null;
    const t = this._editor.getSelections();
    return new nl(
      t.concat(e),
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel())
      return null;
    const e = this._getPreviousMatch();
    if (!e)
      return null;
    const t = this._editor.getSelections();
    return new nl(
      t.slice(0, t.length - 1).concat(e),
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  _getPreviousMatch() {
    if (!this._editor.hasModel())
      return null;
    if (this.currentMatch) {
      const n = this.currentMatch;
      return this.currentMatch = null, n;
    }
    this.findController.highlightFindOptions();
    const e = this._editor.getSelections(), t = e[e.length - 1], i = this._editor.getModel().findPreviousMatch(this.searchText, t.getStartPosition(), !1, this.matchCase, this.wholeWord ? this._editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null, !1);
    return i ? new z(i.range.startLineNumber, i.range.startColumn, i.range.endLineNumber, i.range.endColumn) : null;
  }
  selectAll(e) {
    if (!this._editor.hasModel())
      return [];
    this.findController.highlightFindOptions();
    const t = this._editor.getModel();
    return e ? t.findMatches(
      this.searchText,
      e,
      !1,
      this.matchCase,
      this.wholeWord ? this._editor.getOption(
        130
        /* EditorOption.wordSeparators */
      ) : null,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ) : t.findMatches(
      this.searchText,
      !0,
      !1,
      this.matchCase,
      this.wholeWord ? this._editor.getOption(
        130
        /* EditorOption.wordSeparators */
      ) : null,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
  }
}
class Qn extends P {
  static get(e) {
    return e.getContribution(Qn.ID);
  }
  constructor(e) {
    super(), this._sessionDispose = this._register(new M()), this._editor = e, this._ignoreSelectionChange = !1, this._session = null;
  }
  dispose() {
    this._endSession(), super.dispose();
  }
  _beginSessionIfNeeded(e) {
    if (!this._session) {
      const t = Hr.create(this._editor, e);
      if (!t)
        return;
      this._session = t;
      const i = { searchString: this._session.searchText };
      this._session.isDisconnectedFromFindController && (i.wholeWordOverride = 1, i.matchCaseOverride = 1, i.isRegexOverride = 2), e.getState().change(i, !1), this._sessionDispose.add(this._editor.onDidChangeCursorSelection((n) => {
        this._ignoreSelectionChange || this._endSession();
      })), this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
        this._endSession();
      })), this._sessionDispose.add(e.getState().onFindReplaceStateChange((n) => {
        (n.matchCase || n.wholeWord) && this._endSession();
      }));
    }
  }
  _endSession() {
    if (this._sessionDispose.clear(), this._session && this._session.isDisconnectedFromFindController) {
      const e = {
        wholeWordOverride: 0,
        matchCaseOverride: 0,
        isRegexOverride: 0
      };
      this._session.findController.getState().change(e, !1);
    }
    this._session = null;
  }
  _setSelections(e) {
    this._ignoreSelectionChange = !0, this._editor.setSelections(e), this._ignoreSelectionChange = !1;
  }
  _expandEmptyToWord(e, t) {
    if (!t.isEmpty())
      return t;
    const i = this._editor.getConfiguredWordAtPosition(t.getStartPosition());
    return i ? new z(t.startLineNumber, i.startColumn, t.startLineNumber, i.endColumn) : t;
  }
  _applySessionResult(e) {
    e && (this._setSelections(e.selections), e.revealRange && this._editor.revealRangeInCenterIfOutsideViewport(e.revealRange, e.revealScrollType));
  }
  getSession(e) {
    return this._session;
  }
  addSelectionToNextFindMatch(e) {
    if (this._editor.hasModel()) {
      if (!this._session) {
        const t = this._editor.getSelections();
        if (t.length > 1) {
          const n = e.getState().matchCase;
          if (!fC(this._editor.getModel(), t, n)) {
            const o = this._editor.getModel(), a = [];
            for (let l = 0, d = t.length; l < d; l++)
              a[l] = this._expandEmptyToWord(o, t[l]);
            this._editor.setSelections(a);
            return;
          }
        }
      }
      this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.addSelectionToNextFindMatch());
    }
  }
  addSelectionToPreviousFindMatch(e) {
    this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
  }
  moveSelectionToNextFindMatch(e) {
    this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.moveSelectionToNextFindMatch());
  }
  moveSelectionToPreviousFindMatch(e) {
    this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
  }
  selectAll(e) {
    if (!this._editor.hasModel())
      return;
    let t = null;
    const i = e.getState();
    if (i.isRevealed && i.searchString.length > 0 && i.isRegex) {
      const n = this._editor.getModel();
      i.searchScope ? t = n.findMatches(
        i.searchString,
        i.searchScope,
        i.isRegex,
        i.matchCase,
        i.wholeWord ? this._editor.getOption(
          130
          /* EditorOption.wordSeparators */
        ) : null,
        !1,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ) : t = n.findMatches(
        i.searchString,
        !0,
        i.isRegex,
        i.matchCase,
        i.wholeWord ? this._editor.getOption(
          130
          /* EditorOption.wordSeparators */
        ) : null,
        !1,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      );
    } else {
      if (this._beginSessionIfNeeded(e), !this._session)
        return;
      t = this._session.selectAll(i.searchScope);
    }
    if (t.length > 0) {
      const n = this._editor.getSelection();
      for (let s = 0, o = t.length; s < o; s++) {
        const a = t[s];
        if (a.range.intersectRanges(n)) {
          t[s] = t[0], t[0] = a;
          break;
        }
      }
      this._setSelections(t.map((s) => new z(s.range.startLineNumber, s.range.startColumn, s.range.endLineNumber, s.range.endColumn)));
    }
  }
}
Qn.ID = "editor.contrib.multiCursorController";
class xo extends D {
  run(e, t) {
    const i = Qn.get(t);
    if (!i)
      return;
    const n = t._getViewModel();
    if (n) {
      const s = n.getCursorStates(), o = Ke.get(t);
      if (o)
        this._run(i, o);
      else {
        const a = e.get(q).createInstance(Ke, t);
        this._run(i, a), a.dispose();
      }
      Cn(s, n.getCursorStates());
    }
  }
}
class iP extends xo {
  constructor() {
    super({
      id: "editor.action.addSelectionToNextFindMatch",
      label: g("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
      alias: "Add Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 2082,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "3_multi",
        title: g({ key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"] }, "Add &&Next Occurrence"),
        order: 5
      }
    });
  }
  _run(e, t) {
    e.addSelectionToNextFindMatch(t);
  }
}
class nP extends xo {
  constructor() {
    super({
      id: "editor.action.addSelectionToPreviousFindMatch",
      label: g("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
      alias: "Add Selection To Previous Find Match",
      precondition: void 0,
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "3_multi",
        title: g({ key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"] }, "Add P&&revious Occurrence"),
        order: 6
      }
    });
  }
  _run(e, t) {
    e.addSelectionToPreviousFindMatch(t);
  }
}
class sP extends xo {
  constructor() {
    super({
      id: "editor.action.moveSelectionToNextFindMatch",
      label: g("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
      alias: "Move Last Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: ye(
          2089,
          2082
          /* KeyCode.KeyD */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(e, t) {
    e.moveSelectionToNextFindMatch(t);
  }
}
class oP extends xo {
  constructor() {
    super({
      id: "editor.action.moveSelectionToPreviousFindMatch",
      label: g("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
      alias: "Move Last Selection To Previous Find Match",
      precondition: void 0
    });
  }
  _run(e, t) {
    e.moveSelectionToPreviousFindMatch(t);
  }
}
class rP extends xo {
  constructor() {
    super({
      id: "editor.action.selectHighlights",
      label: g("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
      alias: "Select All Occurrences of Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 3114,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "3_multi",
        title: g({ key: "miSelectHighlights", comment: ["&& denotes a mnemonic"] }, "Select All &&Occurrences"),
        order: 7
      }
    });
  }
  _run(e, t) {
    e.selectAll(t);
  }
}
class aP extends xo {
  constructor() {
    super({
      id: "editor.action.changeAll",
      label: g("changeAll.label", "Change All Occurrences"),
      alias: "Change All Occurrences",
      precondition: L.and(b.writable, b.editorTextFocus),
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 2108,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.2
      }
    });
  }
  _run(e, t) {
    e.selectAll(t);
  }
}
class lP {
  constructor(e, t, i, n, s) {
    this._model = e, this._searchText = t, this._matchCase = i, this._wordSeparators = n, this._modelVersionId = this._model.getVersionId(), this._cachedFindMatches = null, s && this._model === s._model && this._searchText === s._searchText && this._matchCase === s._matchCase && this._wordSeparators === s._wordSeparators && this._modelVersionId === s._modelVersionId && (this._cachedFindMatches = s._cachedFindMatches);
  }
  findMatches() {
    return this._cachedFindMatches === null && (this._cachedFindMatches = this._model.findMatches(this._searchText, !0, !1, this._matchCase, this._wordSeparators, !1).map((e) => e.range), this._cachedFindMatches.sort(S.compareRangesUsingStarts)), this._cachedFindMatches;
  }
}
let Br = fu = class extends P {
  constructor(e, t) {
    super(), this._languageFeaturesService = t, this.editor = e, this._isEnabled = e.getOption(
      108
      /* EditorOption.selectionHighlight */
    ), this._decorations = e.createDecorationsCollection(), this.updateSoon = this._register(new Re(() => this._update(), 300)), this.state = null, this._register(e.onDidChangeConfiguration((n) => {
      this._isEnabled = e.getOption(
        108
        /* EditorOption.selectionHighlight */
      );
    })), this._register(e.onDidChangeCursorSelection((n) => {
      this._isEnabled && (n.selection.isEmpty() ? n.reason === 3 ? (this.state && this._setState(null), this.updateSoon.schedule()) : this._setState(null) : this._update());
    })), this._register(e.onDidChangeModel((n) => {
      this._setState(null);
    })), this._register(e.onDidChangeModelContent((n) => {
      this._isEnabled && this.updateSoon.schedule();
    }));
    const i = Ke.get(e);
    i && this._register(i.getState().onFindReplaceStateChange((n) => {
      this._update();
    })), this.updateSoon.schedule();
  }
  _update() {
    this._setState(fu._createState(this.state, this._isEnabled, this.editor));
  }
  static _createState(e, t, i) {
    if (!t || !i.hasModel())
      return null;
    const n = i.getSelection();
    if (n.startLineNumber !== n.endLineNumber)
      return null;
    const s = Qn.get(i);
    if (!s)
      return null;
    const o = Ke.get(i);
    if (!o)
      return null;
    let a = s.getSession(o);
    if (!a) {
      const c = i.getSelections();
      if (c.length > 1) {
        const u = o.getState().matchCase;
        if (!fC(i.getModel(), c, u))
          return null;
      }
      a = Hr.create(i, o);
    }
    if (!a || a.currentMatch || /^[ \t]+$/.test(a.searchText) || a.searchText.length > 200)
      return null;
    const l = o.getState(), d = l.matchCase;
    if (l.isRevealed) {
      let c = l.searchString;
      d || (c = c.toLowerCase());
      let h = a.searchText;
      if (d || (h = h.toLowerCase()), c === h && a.matchCase === l.matchCase && a.wholeWord === l.wholeWord && !l.isRegex)
        return null;
    }
    return new lP(i.getModel(), a.searchText, a.matchCase, a.wholeWord ? i.getOption(
      130
      /* EditorOption.wordSeparators */
    ) : null, e);
  }
  _setState(e) {
    if (this.state = e, !this.state) {
      this._decorations.clear();
      return;
    }
    if (!this.editor.hasModel())
      return;
    const t = this.editor.getModel();
    if (t.isTooLargeForTokenization())
      return;
    const i = this.state.findMatches(), n = this.editor.getSelections();
    n.sort(S.compareRangesUsingStarts);
    const s = [];
    for (let d = 0, c = 0, h = i.length, u = n.length; d < h; ) {
      const p = i[d];
      if (c >= u)
        s.push(p), d++;
      else {
        const f = S.compareRangesUsingStarts(p, n[c]);
        f < 0 ? ((n[c].isEmpty() || !S.areIntersecting(p, n[c])) && s.push(p), d++) : (f > 0 || d++, c++);
      }
    }
    const o = this.editor.getOption(
      81
      /* EditorOption.occurrencesHighlight */
    ) !== "off", a = this._languageFeaturesService.documentHighlightProvider.has(t) && o, l = s.map((d) => ({
      range: d,
      options: GR(a)
    }));
    this._decorations.set(l);
  }
  dispose() {
    this._setState(null), super.dispose();
  }
};
Br.ID = "editor.contrib.selectionHighlighter";
Br = fu = ZR([
  XR(1, V)
], Br);
function fC(r, e, t) {
  const i = pm(r, e[0], !t);
  for (let n = 1, s = e.length; n < s; n++) {
    const o = e[n];
    if (o.isEmpty())
      return !1;
    const a = pm(r, o, !t);
    if (i !== a)
      return !1;
  }
  return !0;
}
function pm(r, e, t) {
  const i = r.getValueInRange(e);
  return t ? i.toLowerCase() : i;
}
class dP extends D {
  constructor() {
    super({
      id: "editor.action.focusNextCursor",
      label: g("mutlicursor.focusNextCursor", "Focus Next Cursor"),
      metadata: {
        description: g("mutlicursor.focusNextCursor.description", "Focuses the next cursor"),
        args: []
      },
      alias: "Focus Next Cursor",
      precondition: void 0
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = t._getViewModel();
    if (n.cursorConfig.readOnly)
      return;
    n.model.pushStackElement();
    const s = Array.from(n.getCursorStates()), o = s.shift();
    o && (s.push(o), n.setCursorStates(i.source, 3, s), n.revealPrimaryCursor(i.source, !0), Cn(s, n.getCursorStates()));
  }
}
class cP extends D {
  constructor() {
    super({
      id: "editor.action.focusPreviousCursor",
      label: g("mutlicursor.focusPreviousCursor", "Focus Previous Cursor"),
      metadata: {
        description: g("mutlicursor.focusPreviousCursor.description", "Focuses the previous cursor"),
        args: []
      },
      alias: "Focus Previous Cursor",
      precondition: void 0
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = t._getViewModel();
    if (n.cursorConfig.readOnly)
      return;
    n.model.pushStackElement();
    const s = Array.from(n.getCursorStates()), o = s.pop();
    o && (s.unshift(o), n.setCursorStates(i.source, 3, s), n.revealPrimaryCursor(i.source, !0), Cn(s, n.getCursorStates()));
  }
}
Z(
  Qn.ID,
  Qn,
  4
  /* EditorContributionInstantiation.Lazy */
);
Z(
  Br.ID,
  Br,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
x(QR);
x(YR);
x(JR);
x(iP);
x(nP);
x(sP);
x(oP);
x(rP);
x(aP);
x(eP);
x(tP);
x(dP);
x(cP);
const hP = "editor.action.inlineEdit.accept", uP = "editor.action.inlineEdit.reject", gP = "editor.action.inlineEdit.jumpTo", pP = "editor.action.inlineEdit.jumpBack";
var fP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, mP = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const $c = "inline-edit";
let mu = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.languageService = i, this.isDisposed = ai(this, !1), this.currentTextModel = it(this.editor.onDidChangeModel, () => (
      /** @description editor.model */
      this.editor.getModel()
    )), this.uiState = Xe(this, (n) => {
      var s;
      if (this.isDisposed.read(n))
        return;
      const o = this.currentTextModel.read(n);
      if (o !== this.model.targetTextModel.read(n))
        return;
      const a = this.model.ghostText.read(n);
      if (!a)
        return;
      let l = (s = this.model.range) === null || s === void 0 ? void 0 : s.read(n);
      l && l.startLineNumber === l.endLineNumber && l.startColumn === l.endColumn && (l = void 0);
      const d = (l ? l.startLineNumber === l.endLineNumber : !0) && a.parts.length === 1 && a.parts[0].lines.length === 1, c = a.parts.length === 1 && a.parts[0].lines.every((w) => w.length === 0), h = [], u = [];
      function p(w, y) {
        if (u.length > 0) {
          const I = u[u.length - 1];
          y && I.decorations.push(new Cr(
            I.content.length + 1,
            I.content.length + 1 + w[0].length,
            y,
            0
            /* InlineDecorationType.Regular */
          )), I.content += w[0], w = w.slice(1);
        }
        for (const I of w)
          u.push({
            content: I,
            decorations: y ? [new Cr(
              1,
              I.length + 1,
              y,
              0
              /* InlineDecorationType.Regular */
            )] : []
          });
      }
      const f = o.getLineContent(a.lineNumber);
      let m, _ = 0;
      if (!c) {
        for (const w of a.parts) {
          let y = w.lines;
          l && !d && (p(y, $c), y = []), m === void 0 ? (h.push({
            column: w.column,
            text: y[0],
            preview: w.preview
          }), y = y.slice(1)) : p([f.substring(_, w.column - 1)], void 0), y.length > 0 && (p(y, $c), m === void 0 && w.column <= f.length && (m = w.column)), _ = w.column - 1;
        }
        m !== void 0 && p([f.substring(_)], void 0);
      }
      const v = m !== void 0 ? new Gb(m, f.length + 1) : void 0, C = d || !l ? a.lineNumber : l.endLineNumber - 1;
      return {
        inlineTexts: h,
        additionalLines: u,
        hiddenRange: v,
        lineNumber: C,
        additionalReservedLineCount: this.model.minReservedLineCount.read(n),
        targetTextModel: o,
        range: l,
        isSingleLine: d,
        isPureRemove: c,
        backgroundColoring: this.model.backgroundColoring.read(n)
      };
    }), this.decorations = Xe(this, (n) => {
      const s = this.uiState.read(n);
      if (!s)
        return [];
      const o = [];
      if (s.hiddenRange && o.push({
        range: s.hiddenRange.toRange(s.lineNumber),
        options: { inlineClassName: "inline-edit-hidden", description: "inline-edit-hidden" }
      }), s.range) {
        const a = [];
        if (s.isSingleLine)
          a.push(s.range);
        else if (s.isPureRemove) {
          const d = s.range.endLineNumber - s.range.startLineNumber;
          for (let c = 0; c < d; c++) {
            const h = s.range.startLineNumber + c, u = s.targetTextModel.getLineFirstNonWhitespaceColumn(h), p = s.targetTextModel.getLineLastNonWhitespaceColumn(h), f = new S(h, u, h, p);
            a.push(f);
          }
        } else {
          const d = s.range.endLineNumber - s.range.startLineNumber;
          for (let c = 0; c <= d; c++) {
            const h = s.range.startLineNumber + c, u = s.targetTextModel.getLineFirstNonWhitespaceColumn(h), p = s.targetTextModel.getLineLastNonWhitespaceColumn(h), f = new S(h, u, h, p);
            a.push(f);
          }
        }
        const l = s.backgroundColoring ? "inline-edit-remove backgroundColoring" : "inline-edit-remove";
        for (const d of a)
          o.push({
            range: d,
            options: { inlineClassName: l, description: "inline-edit-remove" }
          });
      }
      for (const a of s.inlineTexts)
        o.push({
          range: S.fromPositions(new F(s.lineNumber, a.column)),
          options: {
            description: $c,
            after: { content: a.text, inlineClassName: a.preview ? "inline-edit-decoration-preview" : "inline-edit-decoration", cursorStops: Rs.Left },
            showIfCollapsed: !0
          }
        });
      return o;
    }), this.additionalLinesWidget = this._register(new Qb(this.editor, this.languageService.languageIdCodec, Xe((n) => {
      const s = this.uiState.read(n);
      return s && !s.isPureRemove ? {
        lineNumber: s.lineNumber,
        additionalLines: s.additionalLines,
        minReservedLineCount: s.additionalReservedLineCount,
        targetTextModel: s.targetTextModel
      } : void 0;
    }))), this._register(pe(() => {
      this.isDisposed.set(!0, void 0);
    })), this._register(Zb(this.editor, this.decorations));
  }
  ownsViewZone(e) {
    return this.additionalLinesWidget.viewZoneId === e;
  }
};
mu = fP([
  mP(2, Et)
], mu);
var rp = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ci = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, _l;
let _u = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.instantiationService = i, this.alwaysShowToolbar = it(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).showToolbar === "always"), this.sessionPosition = void 0, this.position = Xe(this, (n) => {
      var s, o, a;
      const l = (s = this.model.read(n)) === null || s === void 0 ? void 0 : s.widget.model.ghostText.read(n);
      if (!this.alwaysShowToolbar.read(n) || !l || l.parts.length === 0)
        return this.sessionPosition = void 0, null;
      const d = l.parts[0].column;
      this.sessionPosition && this.sessionPosition.lineNumber !== l.lineNumber && (this.sessionPosition = void 0);
      const c = new F(l.lineNumber, Math.min(d, (a = (o = this.sessionPosition) === null || o === void 0 ? void 0 : o.column) !== null && a !== void 0 ? a : Number.MAX_SAFE_INTEGER));
      return this.sessionPosition = c, c;
    }), this._register(ug((n, s) => {
      if (!this.model.read(n) || !this.alwaysShowToolbar.read(n))
        return;
      const a = s.add(this.instantiationService.createInstance(oo, this.editor, !0, this.position));
      e.addContentWidget(a), s.add(pe(() => e.removeContentWidget(a)));
    }));
  }
};
_u = rp([
  Ci(2, q)
], _u);
let oo = _l = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this.editor = e, this.withBorder = t, this._position = i, this._contextKeyService = s, this._menuService = o, this.id = `InlineEditHintsContentWidget${_l.id++}`, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this.nodes = Ks("div.inlineEditHints", { className: this.withBorder ? ".withBorder" : "" }, [
      Ks("div@toolBar")
    ]), this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(E.InlineEditActions, this._contextKeyService)), this.toolBar = this._register(n.createInstance(vu, this.nodes.toolBar, this.editor, E.InlineEditToolbar, {
      menuOptions: { renderShortTitle: !0 },
      toolbarOptions: { primaryGroup: (a) => a.startsWith("primary") },
      actionViewItemProvider: (a, l) => {
        if (a instanceof Gs)
          return n.createInstance(_P, a, void 0);
      },
      telemetrySource: "InlineEditToolbar"
    })), this._register(this.toolBar.onDidChangeDropdownVisibility((a) => {
      _l._dropDownVisible = a;
    })), this._register(Ne((a) => {
      this._position.read(a), this.editor.layoutContentWidget(this);
    })), this._register(Ne((a) => {
      const l = [];
      for (const [d, c] of this.inlineCompletionsActionsMenus.getActions())
        for (const h of c)
          h instanceof Gs && l.push(h);
      l.length > 0 && l.unshift(new vr()), this.toolBar.setAdditionalSecondaryActions(l);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ],
      positionAffinity: 3
    };
  }
};
oo._dropDownVisible = !1;
oo.id = 0;
oo = _l = rp([
  Ci(3, q),
  Ci(4, ee),
  Ci(5, is)
], oo);
class _P extends gg {
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    if (this.label) {
      const t = Ks("div.keybinding").root;
      new Ju(t, eg, { disableTitle: !0, ...i_ }).set(e), this.label.textContent = this._action.label, this.label.appendChild(t), this.label.classList.add("inlineEditStatusBarItemLabel");
    }
  }
  updateTooltip() {
  }
}
let vu = class extends n_ {
  constructor(e, t, i, n, s, o, a, l, d) {
    super(e, { resetMenu: i, ...n }, s, o, a, l, d), this.editor = t, this.menuId = i, this.options2 = n, this.menuService = s, this.contextKeyService = o, this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: !0 })), this.additionalActions = [], this.prependedPrimaryActions = [], this._store.add(this.menu.onDidChange(() => this.updateToolbar())), this._store.add(this.editor.onDidChangeCursorPosition(() => this.updateToolbar())), this.updateToolbar();
  }
  updateToolbar() {
    var e, t, i, n, s, o, a;
    const l = [], d = [];
    cg(this.menu, (e = this.options2) === null || e === void 0 ? void 0 : e.menuOptions, { primary: l, secondary: d }, (i = (t = this.options2) === null || t === void 0 ? void 0 : t.toolbarOptions) === null || i === void 0 ? void 0 : i.primaryGroup, (s = (n = this.options2) === null || n === void 0 ? void 0 : n.toolbarOptions) === null || s === void 0 ? void 0 : s.shouldInlineSubmenu, (a = (o = this.options2) === null || o === void 0 ? void 0 : o.toolbarOptions) === null || a === void 0 ? void 0 : a.useSeparatorsInPrimaryActions), d.push(...this.additionalActions), l.unshift(...this.prependedPrimaryActions), this.setActions(l, d);
  }
  setAdditionalSecondaryActions(e) {
    jt(this.additionalActions, e, (t, i) => t === i) || (this.additionalActions = e, this.updateToolbar());
  }
};
vu = rp([
  Ci(4, is),
  Ci(5, ee),
  Ci(6, co),
  Ci(7, xe),
  Ci(8, ui)
], vu);
var vP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Bo = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Pn;
class bP {
  constructor(e, t) {
    this.widget = e, this.edit = t;
  }
  dispose() {
    this.widget.dispose();
  }
}
let we = Pn = class extends P {
  static get(e) {
    return e.getContribution(Pn.ID);
  }
  constructor(e, t, i, n, s, o) {
    super(), this.editor = e, this.instantiationService = t, this.contextKeyService = i, this.languageFeaturesService = n, this._commandService = s, this._configurationService = o, this._isVisibleContext = Pn.inlineEditVisibleContext.bindTo(this.contextKeyService), this._isCursorAtInlineEditContext = Pn.cursorAtInlineEditContext.bindTo(this.contextKeyService), this._currentEdit = this._register(Ll(this, void 0)), this._isAccepting = !1, this._enabled = it(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).enabled), this._fontFamily = it(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).fontFamily), this._backgroundColoring = it(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).backgroundColoring);
    const a = As("InlineEditController.modelContentChangedSignal", e.onDidChangeModelContent);
    this._register(Ne((u) => {
      this._enabled.read(u) && (a.read(u), this.getInlineEdit(e, !0));
    }));
    const l = it(e.onDidChangeCursorPosition, () => e.getPosition());
    this._register(Ne((u) => {
      if (!this._enabled.read(u))
        return;
      const p = l.read(u);
      p && this.checkCursorPosition(p);
    })), this._register(Ne((u) => {
      const p = this._currentEdit.read(u);
      if (this._isCursorAtInlineEditContext.set(!1), !p) {
        this._isVisibleContext.set(!1);
        return;
      }
      this._isVisibleContext.set(!0);
      const f = e.getPosition();
      f && this.checkCursorPosition(f);
    }));
    const d = As("InlineEditController.editorBlurSignal", e.onDidBlurEditorWidget);
    this._register(Ne((u) => {
      var p;
      this._enabled.read(u) && (d.read(u), !(this._configurationService.getValue("editor.experimentalInlineEdit.keepOnBlur") || e.getOption(
        63
        /* EditorOption.inlineEdit */
      ).keepOnBlur) && ((p = this._currentRequestCts) === null || p === void 0 || p.dispose(), this._currentRequestCts = void 0, this.clear(!1)));
    }));
    const c = As("InlineEditController.editorFocusSignal", e.onDidFocusEditorText);
    this._register(Ne((u) => {
      this._enabled.read(u) && (c.read(u), this.getInlineEdit(e, !0));
    }));
    const h = this._register(T_());
    this._register(Ne((u) => {
      const p = this._fontFamily.read(u);
      h.setStyle(p === "" || p === "default" ? "" : `
.monaco-editor .inline-edit-decoration,
.monaco-editor .inline-edit-decoration-preview,
.monaco-editor .inline-edit {
	font-family: ${p};
}`);
    })), this._register(new _u(this.editor, this._currentEdit, this.instantiationService));
  }
  checkCursorPosition(e) {
    var t;
    if (!this._currentEdit) {
      this._isCursorAtInlineEditContext.set(!1);
      return;
    }
    const i = (t = this._currentEdit.get()) === null || t === void 0 ? void 0 : t.edit;
    if (!i) {
      this._isCursorAtInlineEditContext.set(!1);
      return;
    }
    this._isCursorAtInlineEditContext.set(S.containsPosition(i.range, e));
  }
  validateInlineEdit(e, t) {
    var i, n;
    if (t.text.includes(`
`) && t.range.startLineNumber !== t.range.endLineNumber && t.range.startColumn !== t.range.endColumn) {
      if (t.range.startColumn !== 1)
        return !1;
      const o = t.range.endLineNumber, a = t.range.endColumn, l = (n = (i = e.getModel()) === null || i === void 0 ? void 0 : i.getLineLength(o)) !== null && n !== void 0 ? n : 0;
      if (a !== l + 1)
        return !1;
    }
    return !0;
  }
  async fetchInlineEdit(e, t) {
    this._currentRequestCts && this._currentRequestCts.dispose(!0);
    const i = e.getModel();
    if (!i)
      return;
    const n = i.getVersionId(), s = this.languageFeaturesService.inlineEditProvider.all(i);
    if (s.length === 0)
      return;
    const o = s[0];
    this._currentRequestCts = new Oe();
    const a = this._currentRequestCts.token, l = t ? jp.Automatic : jp.Invoke;
    if (t && await CP(50, a), a.isCancellationRequested || i.isDisposed() || i.getVersionId() !== n)
      return;
    const c = await o.provideInlineEdit(i, { triggerKind: l }, a);
    if (c && !(a.isCancellationRequested || i.isDisposed() || i.getVersionId() !== n) && this.validateInlineEdit(e, c))
      return c;
  }
  async getInlineEdit(e, t) {
    var i;
    this._isCursorAtInlineEditContext.set(!1), this.clear(), this._isAccepting = !1;
    const n = await this.fetchInlineEdit(e, t);
    if (!n)
      return;
    const s = n.range.endLineNumber, o = n.range.endColumn, a = new Pr(s, [new Ul(o, n.text, !1)]), l = this.instantiationService.createInstance(mu, this.editor, {
      ghostText: Nn(a),
      minReservedLineCount: Nn(0),
      targetTextModel: Nn((i = this.editor.getModel()) !== null && i !== void 0 ? i : void 0),
      range: Nn(n.range),
      backgroundColoring: this._backgroundColoring
    });
    this._currentEdit.set(new bP(l, n), void 0);
  }
  async trigger() {
    await this.getInlineEdit(this.editor, !1);
  }
  async jumpBack() {
    this._jumpBackPosition && (this.editor.setPosition(this._jumpBackPosition), this.editor.revealPositionInCenterIfOutsideViewport(this._jumpBackPosition));
  }
  accept() {
    var e;
    this._isAccepting = !0;
    const t = (e = this._currentEdit.get()) === null || e === void 0 ? void 0 : e.edit;
    if (!t)
      return;
    let i = t.text;
    t.text.startsWith(`
`) && (i = t.text.substring(1)), this.editor.pushUndoStop(), this.editor.executeEdits("acceptCurrent", [ue.replace(S.lift(t.range), i)]), t.accepted && this._commandService.executeCommand(t.accepted.id, ...t.accepted.arguments || []), this.freeEdit(t), this._currentEdit.set(void 0, void 0);
  }
  jumpToCurrent() {
    var e, t;
    this._jumpBackPosition = (e = this.editor.getSelection()) === null || e === void 0 ? void 0 : e.getStartPosition();
    const i = (t = this._currentEdit.get()) === null || t === void 0 ? void 0 : t.edit;
    if (!i)
      return;
    const n = F.lift({ lineNumber: i.range.startLineNumber, column: i.range.startColumn });
    this.editor.setPosition(n), this.editor.revealPositionInCenterIfOutsideViewport(n);
  }
  clear(e = !0) {
    var t;
    const i = (t = this._currentEdit.get()) === null || t === void 0 ? void 0 : t.edit;
    i && (i != null && i.rejected) && !this._isAccepting && e && this._commandService.executeCommand(i.rejected.id, ...i.rejected.arguments || []), i && this.freeEdit(i), this._currentEdit.set(void 0, void 0);
  }
  freeEdit(e) {
    const t = this.editor.getModel();
    if (!t)
      return;
    const i = this.languageFeaturesService.inlineEditProvider.all(t);
    i.length !== 0 && i[0].freeInlineEdit(e);
  }
  shouldShowHoverAt(e) {
    const t = this._currentEdit.get();
    if (!t)
      return !1;
    const i = t.edit, n = t.widget.model;
    if (S.containsPosition(i.range, e.getStartPosition()) || S.containsPosition(i.range, e.getEndPosition()))
      return !0;
    const o = n.ghostText.get();
    return o ? o.parts.some((a) => e.containsPosition(new F(o.lineNumber, a.column))) : !1;
  }
  shouldShowHoverAtViewZone(e) {
    var t, i;
    return (i = (t = this._currentEdit.get()) === null || t === void 0 ? void 0 : t.widget.ownsViewZone(e)) !== null && i !== void 0 ? i : !1;
  }
};
we.ID = "editor.contrib.inlineEditController";
we.inlineEditVisibleKey = "inlineEditVisible";
we.inlineEditVisibleContext = new Q(Pn.inlineEditVisibleKey, !1);
we.cursorAtInlineEditKey = "cursorAtInlineEdit";
we.cursorAtInlineEditContext = new Q(Pn.cursorAtInlineEditKey, !1);
we = Pn = vP([
  Bo(1, q),
  Bo(2, ee),
  Bo(3, V),
  Bo(4, Fe),
  Bo(5, he)
], we);
function CP(r, e) {
  return new Promise((t) => {
    let i;
    const n = setTimeout(() => {
      i && i.dispose(), t();
    }, r);
    e && (i = e.onCancellationRequested(() => {
      clearTimeout(n), i && i.dispose(), t();
    }));
  });
}
class SP extends D {
  constructor() {
    super({
      id: hP,
      label: "Accept Inline Edit",
      alias: "Accept Inline Edit",
      precondition: L.and(b.writable, we.inlineEditVisibleContext),
      kbOpts: [
        {
          weight: 101,
          primary: 2,
          kbExpr: L.and(b.writable, we.inlineEditVisibleContext, we.cursorAtInlineEditContext)
        }
      ],
      menuOpts: [{
        menuId: E.InlineEditToolbar,
        title: "Accept",
        group: "primary",
        order: 1
      }]
    });
  }
  async run(e, t) {
    const i = we.get(t);
    i == null || i.accept();
  }
}
class wP extends D {
  constructor() {
    const e = L.and(b.writable, L.not(we.inlineEditVisibleKey));
    super({
      id: "editor.action.inlineEdit.trigger",
      label: "Trigger Inline Edit",
      alias: "Trigger Inline Edit",
      precondition: e,
      kbOpts: {
        weight: 101,
        primary: 2646,
        kbExpr: e
      }
    });
  }
  async run(e, t) {
    const i = we.get(t);
    i == null || i.trigger();
  }
}
class yP extends D {
  constructor() {
    const e = L.and(b.writable, we.inlineEditVisibleContext, L.not(we.cursorAtInlineEditKey));
    super({
      id: gP,
      label: "Jump to Inline Edit",
      alias: "Jump to Inline Edit",
      precondition: e,
      kbOpts: {
        weight: 101,
        primary: 2646,
        kbExpr: e
      },
      menuOpts: [{
        menuId: E.InlineEditToolbar,
        title: "Jump To Edit",
        group: "primary",
        order: 3,
        when: e
      }]
    });
  }
  async run(e, t) {
    const i = we.get(t);
    i == null || i.jumpToCurrent();
  }
}
class xP extends D {
  constructor() {
    const e = L.and(b.writable, we.cursorAtInlineEditContext);
    super({
      id: pP,
      label: "Jump Back from Inline Edit",
      alias: "Jump Back from Inline Edit",
      precondition: e,
      kbOpts: {
        weight: 110,
        primary: 2646,
        kbExpr: e
      },
      menuOpts: [{
        menuId: E.InlineEditToolbar,
        title: "Jump Back",
        group: "primary",
        order: 3,
        when: e
      }]
    });
  }
  async run(e, t) {
    const i = we.get(t);
    i == null || i.jumpBack();
  }
}
class LP extends D {
  constructor() {
    const e = L.and(b.writable, we.inlineEditVisibleContext);
    super({
      id: uP,
      label: "Reject Inline Edit",
      alias: "Reject Inline Edit",
      precondition: e,
      kbOpts: {
        weight: 100,
        primary: 9,
        kbExpr: e
      },
      menuOpts: [{
        menuId: E.InlineEditToolbar,
        title: "Reject",
        group: "secondary",
        order: 2
      }]
    });
  }
  async run(e, t) {
    const i = we.get(t);
    i == null || i.clear();
  }
}
var IP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, fm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class DP {
  constructor(e, t, i) {
    this.owner = e, this.range = t, this.controller = i;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let bu = class {
  constructor(e, t, i) {
    this._editor = e, this._instantiationService = t, this._telemetryService = i, this.hoverOrdinal = 5;
  }
  suggestHoverAnchor(e) {
    const t = we.get(this._editor);
    if (!t)
      return null;
    const i = e.target;
    if (i.type === 8) {
      const n = i.detail;
      if (t.shouldShowHoverAtViewZone(n.viewZoneId)) {
        const s = i.range;
        return new An(1e3, this, s, e.event.posx, e.event.posy, !1);
      }
    }
    return i.type === 7 && t.shouldShowHoverAt(i.range) ? new An(1e3, this, i.range, e.event.posx, e.event.posy, !1) : i.type === 6 && i.detail.mightBeForeignElement && t.shouldShowHoverAt(i.range) ? new An(1e3, this, i.range, e.event.posx, e.event.posy, !1) : null;
  }
  computeSync(e, t) {
    if (this._editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).showToolbar !== "onHover")
      return [];
    const i = we.get(this._editor);
    return i && i.shouldShowHoverAt(e.range) ? [new DP(this, e.range, i)] : [];
  }
  renderHoverParts(e, t) {
    const i = new M();
    this._telemetryService.publicLog2("inlineEditHover.shown");
    const n = this._instantiationService.createInstance(oo, this._editor, !1, Nn(null));
    return e.fragment.appendChild(n.getDomNode()), i.add(n), i;
  }
};
bu = IP([
  fm(1, q),
  fm(2, ui)
], bu);
x(SP);
x(LP);
x(yP);
x(xP);
x(wP);
Z(
  we.ID,
  we,
  3
  /* EditorContributionInstantiation.Eventually */
);
bn.register(bu);
const Yn = {
  Visible: new Q("parameterHintsVisible", !1),
  MultipleSignatures: new Q("parameterHintsMultipleSignatures", !1)
};
async function mC(r, e, t, i, n) {
  const s = r.ordered(e);
  for (const o of s)
    try {
      const a = await o.provideSignatureHelp(e, t, n, i);
      if (a)
        return a;
    } catch (a) {
      Ie(a);
    }
}
de.registerCommand("_executeSignatureHelpProvider", async (r, ...e) => {
  const [t, i, n] = e;
  ie(ce.isUri(t)), ie(F.isIPosition(i)), ie(typeof n == "string" || !n);
  const s = r.get(V), o = await r.get(Zt).createModelReference(t);
  try {
    const a = await mC(s.signatureHelpProvider, o.object.textEditorModel, F.lift(i), {
      triggerKind: Yi.Invoke,
      isRetrigger: !1,
      triggerCharacter: n
    }, X.None);
    return a ? (setTimeout(() => a.dispose(), 0), a.value) : void 0;
  } finally {
    o.dispose();
  }
});
var Ui;
(function(r) {
  r.Default = {
    type: 0
    /* Type.Default */
  };
  class e {
    constructor(n, s) {
      this.request = n, this.previouslyActiveHints = s, this.type = 2;
    }
  }
  r.Pending = e;
  class t {
    constructor(n) {
      this.hints = n, this.type = 1;
    }
  }
  r.Active = t;
})(Ui || (Ui = {}));
class nc extends P {
  constructor(e, t, i = nc.DEFAULT_DELAY) {
    super(), this._onChangedHints = this._register(new G()), this.onChangedHints = this._onChangedHints.event, this.triggerOnType = !1, this._state = Ui.Default, this._pendingTriggers = [], this._lastSignatureHelpResult = this._register(new ft()), this.triggerChars = new yl(), this.retriggerChars = new yl(), this.triggerId = 0, this.editor = e, this.providers = t, this.throttledDelayer = new Vn(i), this._register(this.editor.onDidBlurEditorWidget(() => this.cancel())), this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange())), this._register(this.editor.onDidChangeModel((n) => this.onModelChanged())), this._register(this.editor.onDidChangeModelLanguage((n) => this.onModelChanged())), this._register(this.editor.onDidChangeCursorSelection((n) => this.onCursorChange(n))), this._register(this.editor.onDidChangeModelContent((n) => this.onModelContentChange())), this._register(this.providers.onDidChange(this.onModelChanged, this)), this._register(this.editor.onDidType((n) => this.onDidType(n))), this.onEditorConfigurationChange(), this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state.type === 2 && this._state.request.cancel(), this._state = e;
  }
  cancel(e = !1) {
    this.state = Ui.Default, this.throttledDelayer.cancel(), e || this._onChangedHints.fire(void 0);
  }
  trigger(e, t) {
    const i = this.editor.getModel();
    if (!i || !this.providers.has(i))
      return;
    const n = ++this.triggerId;
    this._pendingTriggers.push(e), this.throttledDelayer.trigger(() => this.doTrigger(n), t).catch(re);
  }
  next() {
    if (this.state.type !== 1)
      return;
    const e = this.state.hints.signatures.length, t = this.state.hints.activeSignature, i = t % e === e - 1, n = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).cycle;
    if ((e < 2 || i) && !n) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(i && n ? 0 : t + 1);
  }
  previous() {
    if (this.state.type !== 1)
      return;
    const e = this.state.hints.signatures.length, t = this.state.hints.activeSignature, i = t === 0, n = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).cycle;
    if ((e < 2 || i) && !n) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(i && n ? e - 1 : t - 1);
  }
  updateActiveSignature(e) {
    this.state.type === 1 && (this.state = new Ui.Active({ ...this.state.hints, activeSignature: e }), this._onChangedHints.fire(this.state.hints));
  }
  async doTrigger(e) {
    const t = this.state.type === 1 || this.state.type === 2, i = this.getLastActiveHints();
    if (this.cancel(!0), this._pendingTriggers.length === 0)
      return !1;
    const n = this._pendingTriggers.reduce(kP);
    this._pendingTriggers = [];
    const s = {
      triggerKind: n.triggerKind,
      triggerCharacter: n.triggerCharacter,
      isRetrigger: t,
      activeSignatureHelp: i
    };
    if (!this.editor.hasModel())
      return !1;
    const o = this.editor.getModel(), a = this.editor.getPosition();
    this.state = new Ui.Pending(Pe((l) => mC(this.providers, o, a, s, l)), i);
    try {
      const l = await this.state.request;
      return e !== this.triggerId ? (l == null || l.dispose(), !1) : !l || !l.value.signatures || l.value.signatures.length === 0 ? (l == null || l.dispose(), this._lastSignatureHelpResult.clear(), this.cancel(), !1) : (this.state = new Ui.Active(l.value), this._lastSignatureHelpResult.value = l, this._onChangedHints.fire(this.state.hints), !0);
    } catch (l) {
      return e === this.triggerId && (this.state = Ui.Default), re(l), !1;
    }
  }
  getLastActiveHints() {
    switch (this.state.type) {
      case 1:
        return this.state.hints;
      case 2:
        return this.state.previouslyActiveHints;
      default:
        return;
    }
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel(), this.triggerChars.clear(), this.retriggerChars.clear();
    const e = this.editor.getModel();
    if (e)
      for (const t of this.providers.ordered(e)) {
        for (const i of t.signatureHelpTriggerCharacters || [])
          if (i.length) {
            const n = i.charCodeAt(0);
            this.triggerChars.add(n), this.retriggerChars.add(n);
          }
        for (const i of t.signatureHelpRetriggerCharacters || [])
          i.length && this.retriggerChars.add(i.charCodeAt(0));
      }
  }
  onDidType(e) {
    if (!this.triggerOnType)
      return;
    const t = e.length - 1, i = e.charCodeAt(t);
    (this.triggerChars.has(i) || this.isTriggered && this.retriggerChars.has(i)) && this.trigger({
      triggerKind: Yi.TriggerCharacter,
      triggerCharacter: e.charAt(t)
    });
  }
  onCursorChange(e) {
    e.source === "mouse" ? this.cancel() : this.isTriggered && this.trigger({ triggerKind: Yi.ContentChange });
  }
  onModelContentChange() {
    this.isTriggered && this.trigger({ triggerKind: Yi.ContentChange });
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).enabled, this.triggerOnType || this.cancel();
  }
  dispose() {
    this.cancel(!0), super.dispose();
  }
}
nc.DEFAULT_DELAY = 120;
function kP(r, e) {
  switch (e.triggerKind) {
    case Yi.Invoke:
      return e;
    case Yi.ContentChange:
      return r;
    case Yi.TriggerCharacter:
    default:
      return e;
  }
}
var NP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, jc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Cu;
const at = O, RP = Ae("parameter-hints-next", j.chevronDown, g("parameterHintsNextIcon", "Icon for show next parameter hint.")), PP = Ae("parameter-hints-previous", j.chevronUp, g("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
let Zl = Cu = class extends P {
  constructor(e, t, i, n, s) {
    super(), this.editor = e, this.model = t, this.renderDisposeables = this._register(new M()), this.visible = !1, this.announcedLabel = null, this.allowEditorOverflow = !0, this.markdownRenderer = this._register(new po({ editor: e }, s, n)), this.keyVisible = Yn.Visible.bindTo(i), this.keyMultipleSignatures = Yn.MultipleSignatures.bindTo(i);
  }
  createParameterHintDOMNodes() {
    const e = at(".editor-widget.parameter-hints-widget"), t = A(e, at(".phwrapper"));
    t.tabIndex = -1;
    const i = A(t, at(".controls")), n = A(i, at(".button" + oe.asCSSSelector(PP))), s = A(i, at(".overloads")), o = A(i, at(".button" + oe.asCSSSelector(RP)));
    this._register(le(n, "click", (u) => {
      wl.stop(u), this.previous();
    })), this._register(le(o, "click", (u) => {
      wl.stop(u), this.next();
    }));
    const a = at(".body"), l = new P_(a, {
      alwaysConsumeMouseWheel: !0
    });
    this._register(l), t.appendChild(l.getDomNode());
    const d = A(a, at(".signature")), c = A(a, at(".docs"));
    e.style.userSelect = "text", this.domNodes = {
      element: e,
      signature: d,
      overloads: s,
      docs: c,
      scrollbar: l
    }, this.editor.addContentWidget(this), this.hide(), this._register(this.editor.onDidChangeCursorSelection((u) => {
      this.visible && this.editor.layoutContentWidget(this);
    }));
    const h = () => {
      if (!this.domNodes)
        return;
      const u = this.editor.getOption(
        50
        /* EditorOption.fontInfo */
      );
      this.domNodes.element.style.fontSize = `${u.fontSize}px`, this.domNodes.element.style.lineHeight = `${u.lineHeight / u.fontSize}`;
    };
    h(), this._register(De.chain(this.editor.onDidChangeConfiguration.bind(this.editor), (u) => u.filter((p) => p.hasChanged(
      50
      /* EditorOption.fontInfo */
    )))(h)), this._register(this.editor.onDidLayoutChange((u) => this.updateMaxHeight())), this.updateMaxHeight();
  }
  show() {
    this.visible || (this.domNodes || this.createParameterHintDOMNodes(), this.keyVisible.set(!0), this.visible = !0, setTimeout(() => {
      var e;
      (e = this.domNodes) === null || e === void 0 || e.element.classList.add("visible");
    }, 100), this.editor.layoutContentWidget(this));
  }
  hide() {
    var e;
    this.renderDisposeables.clear(), this.visible && (this.keyVisible.reset(), this.visible = !1, this.announcedLabel = null, (e = this.domNodes) === null || e === void 0 || e.element.classList.remove("visible"), this.editor.layoutContentWidget(this));
  }
  getPosition() {
    return this.visible ? {
      position: this.editor.getPosition(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ]
    } : null;
  }
  render(e) {
    var t;
    if (this.renderDisposeables.clear(), !this.domNodes)
      return;
    const i = e.signatures.length > 1;
    this.domNodes.element.classList.toggle("multiple", i), this.keyMultipleSignatures.set(i), this.domNodes.signature.innerText = "", this.domNodes.docs.innerText = "";
    const n = e.signatures[e.activeSignature];
    if (!n)
      return;
    const s = A(this.domNodes.signature, at(".code")), o = this.editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    s.style.fontSize = `${o.fontSize}px`, s.style.fontFamily = o.fontFamily;
    const a = n.parameters.length > 0, l = (t = n.activeParameter) !== null && t !== void 0 ? t : e.activeParameter;
    if (a)
      this.renderParameters(s, n, l);
    else {
      const h = A(s, at("span"));
      h.textContent = n.label;
    }
    const d = n.parameters[l];
    if (d != null && d.documentation) {
      const h = at("span.documentation");
      if (typeof d.documentation == "string")
        h.textContent = d.documentation;
      else {
        const u = this.renderMarkdownDocs(d.documentation);
        h.appendChild(u.element);
      }
      A(this.domNodes.docs, at("p", {}, h));
    }
    if (n.documentation !== void 0)
      if (typeof n.documentation == "string")
        A(this.domNodes.docs, at("p", {}, n.documentation));
      else {
        const h = this.renderMarkdownDocs(n.documentation);
        A(this.domNodes.docs, h.element);
      }
    const c = this.hasDocs(n, d);
    if (this.domNodes.signature.classList.toggle("has-docs", c), this.domNodes.docs.classList.toggle("empty", !c), this.domNodes.overloads.textContent = String(e.activeSignature + 1).padStart(e.signatures.length.toString().length, "0") + "/" + e.signatures.length, d) {
      let h = "";
      const u = n.parameters[l];
      Array.isArray(u.label) ? h = n.label.substring(u.label[0], u.label[1]) : h = u.label, u.documentation && (h += typeof u.documentation == "string" ? `, ${u.documentation}` : `, ${u.documentation.value}`), n.documentation && (h += typeof n.documentation == "string" ? `, ${n.documentation}` : `, ${n.documentation.value}`), this.announcedLabel !== h && (xt(g("hint", "{0}, hint", h)), this.announcedLabel = h);
    }
    this.editor.layoutContentWidget(this), this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(e) {
    const t = this.renderDisposeables.add(this.markdownRenderer.render(e, {
      asyncRenderCallback: () => {
        var i;
        (i = this.domNodes) === null || i === void 0 || i.scrollbar.scanDomNode();
      }
    }));
    return t.element.classList.add("markdown-docs"), t;
  }
  hasDocs(e, t) {
    return !!(t && typeof t.documentation == "string" && Ns(t.documentation).length > 0 || t && typeof t.documentation == "object" && Ns(t.documentation).value.length > 0 || e.documentation && typeof e.documentation == "string" && Ns(e.documentation).length > 0 || e.documentation && typeof e.documentation == "object" && Ns(e.documentation.value).length > 0);
  }
  renderParameters(e, t, i) {
    const [n, s] = this.getParameterLabelOffsets(t, i), o = document.createElement("span");
    o.textContent = t.label.substring(0, n);
    const a = document.createElement("span");
    a.textContent = t.label.substring(n, s), a.className = "parameter active";
    const l = document.createElement("span");
    l.textContent = t.label.substring(s), A(e, o, a, l);
  }
  getParameterLabelOffsets(e, t) {
    const i = e.parameters[t];
    if (i) {
      if (Array.isArray(i.label))
        return i.label;
      if (i.label.length) {
        const n = new RegExp(`(\\W|^)${pr(i.label)}(?=\\W|$)`, "g");
        n.test(e.label);
        const s = n.lastIndex - i.label.length;
        return s >= 0 ? [s, n.lastIndex] : [0, 0];
      } else
        return [0, 0];
    } else
      return [0, 0];
  }
  next() {
    this.editor.focus(), this.model.next();
  }
  previous() {
    this.editor.focus(), this.model.previous();
  }
  getDomNode() {
    return this.domNodes || this.createParameterHintDOMNodes(), this.domNodes.element;
  }
  getId() {
    return Cu.ID;
  }
  updateMaxHeight() {
    if (!this.domNodes)
      return;
    const t = `${Math.max(this.editor.getLayoutInfo().height / 4, 250)}px`;
    this.domNodes.element.style.maxHeight = t;
    const i = this.domNodes.element.getElementsByClassName("phwrapper");
    i.length && (i[0].style.maxHeight = t);
  }
};
Zl.ID = "editor.widget.parameterHintsWidget";
Zl = Cu = NP([
  jc(2, ee),
  jc(3, Gt),
  jc(4, Et)
], Zl);
W("editorHoverWidget.highlightForeground", { dark: ji, light: ji, hcDark: ji, hcLight: ji }, g("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));
var MP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, mm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Su;
let Jn = Su = class extends P {
  static get(e) {
    return e.getContribution(Su.ID);
  }
  constructor(e, t, i) {
    super(), this.editor = e, this.model = this._register(new nc(e, i.signatureHelpProvider)), this._register(this.model.onChangedHints((n) => {
      var s;
      n ? (this.widget.value.show(), this.widget.value.render(n)) : (s = this.widget.rawValue) === null || s === void 0 || s.hide();
    })), this.widget = new Qu(() => this._register(t.createInstance(Zl, this.editor, this.model)));
  }
  cancel() {
    this.model.cancel();
  }
  previous() {
    var e;
    (e = this.widget.rawValue) === null || e === void 0 || e.previous();
  }
  next() {
    var e;
    (e = this.widget.rawValue) === null || e === void 0 || e.next();
  }
  trigger(e) {
    this.model.trigger(e, 0);
  }
};
Jn.ID = "editor.controller.parameterHints";
Jn = Su = MP([
  mm(1, q),
  mm(2, V)
], Jn);
class EP extends D {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: g("parameterHints.trigger.label", "Trigger Parameter Hints"),
      alias: "Trigger Parameter Hints",
      precondition: b.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 3082,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Jn.get(t);
    i == null || i.trigger({
      triggerKind: Yi.Invoke
    });
  }
}
Z(
  Jn.ID,
  Jn,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
x(EP);
const ap = 175, lp = bt.bindToContribution(Jn.get);
B(new lp({
  id: "closeParameterHints",
  precondition: Yn.Visible,
  handler: (r) => r.cancel(),
  kbOpts: {
    weight: ap,
    kbExpr: b.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
B(new lp({
  id: "showPrevParameterHint",
  precondition: L.and(Yn.Visible, Yn.MultipleSignatures),
  handler: (r) => r.previous(),
  kbOpts: {
    weight: ap,
    kbExpr: b.focus,
    primary: 16,
    secondary: [
      528
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      528,
      302
      /* KeyCode.KeyP */
    ] }
  }
}));
B(new lp({
  id: "showNextParameterHint",
  precondition: L.and(Yn.Visible, Yn.MultipleSignatures),
  handler: (r) => r.next(),
  kbOpts: {
    weight: ap,
    kbExpr: b.focus,
    primary: 18,
    secondary: [
      530
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      530,
      300
      /* KeyCode.KeyN */
    ] }
  }
}));
var TP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, sl = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Lo = new Q("renameInputVisible", !1, g("renameInputVisible", "Whether the rename input widget is visible")), wu = new Q("renameInputFocused", !1, g("renameInputFocused", "Whether the rename input widget is focused"));
let yu = class {
  constructor(e, t, i, n, s, o) {
    this._editor = e, this._acceptKeybindings = t, this._themeService = i, this._keybindingService = n, this._logService = o, this._disposables = new M(), this.allowEditorOverflow = !0, this._visibleContextKey = Lo.bindTo(s), this._focusedContextKey = wu.bindTo(s), this._editor.addContentWidget(this), this._disposables.add(this._editor.onDidChangeConfiguration((a) => {
      a.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    })), this._disposables.add(i.onDidColorThemeChange(this._updateStyles, this));
  }
  dispose() {
    this._disposables.dispose(), this._editor.removeContentWidget(this);
  }
  getId() {
    return "__renameInputWidget";
  }
  getDomNode() {
    return this._domNode || (this._domNode = document.createElement("div"), this._domNode.className = "monaco-editor rename-box", this._input = document.createElement("input"), this._input.className = "rename-input", this._input.type = "text", this._input.setAttribute("aria-label", g("renameAriaLabel", "Rename input. Type new name and press Enter to commit.")), this._disposables.add(le(this._input, "focus", () => {
      this._focusedContextKey.set(!0);
    })), this._disposables.add(le(this._input, "blur", () => {
      this._focusedContextKey.reset();
    })), this._domNode.appendChild(this._input), this._candidatesView = this._disposables.add(new AP(this._domNode, {
      fontInfo: this._editor.getOption(
        50
        /* EditorOption.fontInfo */
      ),
      onSelectionChange: () => this.acceptInput(!1)
      // we don't allow preview with mouse click for now
    })), this._label = document.createElement("div"), this._label.className = "rename-label", this._domNode.appendChild(this._label), this._updateFont(), this._updateStyles(this._themeService.getColorTheme())), this._domNode;
  }
  _updateStyles(e) {
    var t, i, n, s;
    if (!this._input || !this._domNode)
      return;
    const o = e.getColor(uy), a = e.getColor(gy);
    this._domNode.style.backgroundColor = String((t = e.getColor(Uo)) !== null && t !== void 0 ? t : ""), this._domNode.style.boxShadow = o ? ` 0 0 8px 2px ${o}` : "", this._domNode.style.border = a ? `1px solid ${a}` : "", this._domNode.style.color = String((i = e.getColor(py)) !== null && i !== void 0 ? i : ""), this._input.style.backgroundColor = String((n = e.getColor(fy)) !== null && n !== void 0 ? n : "");
    const l = e.getColor(my);
    this._input.style.borderWidth = l ? "1px" : "0px", this._input.style.borderStyle = l ? "solid" : "none", this._input.style.borderColor = (s = l == null ? void 0 : l.toString()) !== null && s !== void 0 ? s : "none";
  }
  _updateFont() {
    if (!this._input || !this._label || !this._candidatesView)
      return;
    const e = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._input.style.fontFamily = e.fontFamily, this._input.style.fontWeight = e.fontWeight, this._input.style.fontSize = `${e.fontSize}px`, this._candidatesView.updateFont(e), this._label.style.fontSize = `${this._computeLabelFontSize(e.fontSize)}px`;
  }
  _computeLabelFontSize(e) {
    return e * 0.8;
  }
  getPosition() {
    if (!this._visible || !this._editor.hasModel() || // @ulugbekna: shouldn't happen
    !this._editor.getDomNode())
      return null;
    const e = ia(this.getDomNode().ownerDocument.body), t = mt(this._editor.getDomNode()), i = this._getTopForPosition();
    this._nPxAvailableAbove = i + t.top, this._nPxAvailableBelow = e.height - this._nPxAvailableAbove;
    const n = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), { totalHeight: s } = es.getLayoutInfo({ lineHeight: n }), o = this._nPxAvailableBelow > s * 6 ? [
      2,
      1
      /* ContentWidgetPositionPreference.ABOVE */
    ] : [
      1,
      2
      /* ContentWidgetPositionPreference.BELOW */
    ];
    return {
      position: this._position,
      preference: o
    };
  }
  beforeRender() {
    var e, t;
    const [i, n] = this._acceptKeybindings;
    return this._label.innerText = g({ key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (e = this._keybindingService.lookupKeybinding(i)) === null || e === void 0 ? void 0 : e.getLabel(), (t = this._keybindingService.lookupKeybinding(n)) === null || t === void 0 ? void 0 : t.getLabel()), this._domNode.style.minWidth = "200px", null;
  }
  afterRender(e) {
    if (this._trace("invoking afterRender, position: ", e ? "not null" : "null"), e === null) {
      this.cancelInput(!0, "afterRender (because position is null)");
      return;
    }
    if (!this._editor.hasModel() || // shouldn't happen
    !this._editor.getDomNode())
      return;
    ie(this._candidatesView), ie(this._nPxAvailableAbove !== void 0), ie(this._nPxAvailableBelow !== void 0);
    const t = ks(this._input), i = ks(this._label);
    let n;
    e === 2 ? n = this._nPxAvailableBelow : n = this._nPxAvailableAbove, this._candidatesView.layout({
      height: n - i - t,
      width: lt(this._input)
    });
  }
  acceptInput(e) {
    var t;
    this._trace("invoking acceptInput"), (t = this._currentAcceptInput) === null || t === void 0 || t.call(this, e);
  }
  cancelInput(e, t) {
    var i;
    this._trace(`invoking cancelInput, caller: ${t}, _currentCancelInput: ${this._currentAcceptInput ? "not undefined" : "undefined"}`), (i = this._currentCancelInput) === null || i === void 0 || i.call(this, e);
  }
  focusNextRenameSuggestion() {
    var e;
    (e = this._candidatesView) === null || e === void 0 || e.focusNext();
  }
  focusPreviousRenameSuggestion() {
    var e;
    !((e = this._candidatesView) === null || e === void 0) && e.focusPrevious() || this._input.focus();
  }
  /**
   * @returns a `boolean` standing for `shouldFocusEditor`, if user didn't pick a new name, or a {@link RenameInputFieldResult}
   */
  getInput(e, t, i, n, s, o, a) {
    this._domNode.classList.toggle("preview", s), this._position = new F(e.startLineNumber, e.startColumn), this._input.value = t, this._input.setAttribute("selectionStart", i.toString()), this._input.setAttribute("selectionEnd", n.toString()), this._input.size = Math.max((e.endColumn - e.startColumn) * 1.1, 20);
    const l = new M();
    return l.add(pe(() => a.dispose(!0))), this._updateRenameCandidates(o, t, a.token), new Promise((d) => {
      this._currentCancelInput = (c) => {
        var h;
        return this._trace("invoking _currentCancelInput"), this._currentAcceptInput = void 0, this._currentCancelInput = void 0, (h = this._candidatesView) === null || h === void 0 || h.clearCandidates(), d(c), !0;
      }, this._currentAcceptInput = (c) => {
        this._trace("invoking _currentAcceptInput"), ie(this._input !== void 0), ie(this._candidatesView !== void 0);
        const h = this._candidatesView.nCandidates;
        let u, p;
        const f = this._candidatesView.focusedCandidate;
        if (f !== void 0 ? (this._trace("using new name from renameSuggestion"), u = f, p = "renameSuggestion") : (this._trace("using new name from inputField"), u = this._input.value, p = "inputField"), u === t || u.trim().length === 0) {
          this.cancelInput(!0, "_currentAcceptInput (because newName === value || newName.trim().length === 0)");
          return;
        }
        this._currentAcceptInput = void 0, this._currentCancelInput = void 0, this._candidatesView.clearCandidates(), d({
          newName: u,
          wantsPreview: s && c,
          source: p,
          nRenameSuggestions: h
        });
      }, l.add(a.token.onCancellationRequested(() => this.cancelInput(!0, "cts.token.onCancellationRequested"))), l.add(this._editor.onDidBlurEditorWidget(() => {
        var c;
        return this.cancelInput(!(!((c = this._domNode) === null || c === void 0) && c.ownerDocument.hasFocus()), "editor.onDidBlurEditorWidget");
      })), this._show();
    }).finally(() => {
      l.dispose(), this._hide();
    });
  }
  _show() {
    this._trace("invoking _show"), this._editor.revealLineInCenterIfOutsideViewport(
      this._position.lineNumber,
      0
      /* ScrollType.Smooth */
    ), this._visible = !0, this._visibleContextKey.set(!0), this._editor.layoutContentWidget(this), setTimeout(() => {
      this._input.focus(), this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
    }, 100);
  }
  async _updateRenameCandidates(e, t, i) {
    const n = (...d) => this._trace("_updateRenameCandidates", ...d);
    n("start");
    const s = await Zr(Promise.allSettled(e), i);
    if (s === void 0) {
      n("returning early - received updateRenameCandidates results - undefined");
      return;
    }
    const o = s.flatMap((d) => d.status === "fulfilled" && rl(d.value) ? d.value : []);
    n(`received updateRenameCandidates results - total (unfiltered) ${o.length} candidates.`);
    const a = Tm(o, (d) => d.newSymbolName);
    n(`distinct candidates - ${a.length} candidates.`);
    const l = a.filter(({ newSymbolName: d }) => {
      var c;
      return d.trim().length > 0 && d !== ((c = this._input) === null || c === void 0 ? void 0 : c.value) && d !== t;
    });
    if (n(`valid distinct candidates - ${o.length} candidates.`), l.length < 1) {
      n("returning early - no valid distinct candidates");
      return;
    }
    n("setting candidates"), this._candidatesView.setCandidates(l), n("asking editor to re-layout"), this._editor.layoutContentWidget(this);
  }
  _hide() {
    this._trace("invoked _hide"), this._visible = !1, this._visibleContextKey.reset(), this._editor.layoutContentWidget(this);
  }
  _getTopForPosition() {
    const e = this._editor.getVisibleRanges();
    let t;
    return e.length > 0 ? t = e[0].startLineNumber : (this._logService.warn("RenameInputField#_getTopForPosition: this should not happen - visibleRanges is empty"), t = Math.max(1, this._position.lineNumber - 5)), this._editor.getTopForLineNumber(this._position.lineNumber) - this._editor.getTopForLineNumber(t);
  }
  _trace(...e) {
    this._logService.trace("RenameInputField", ...e);
  }
};
yu = TP([
  sl(2, Mt),
  sl(3, xe),
  sl(4, ee),
  sl(5, fo)
], yu);
class AP {
  constructor(e, t) {
    this._disposables = new M(), this._availableHeight = 0, this._minimumWidth = 0, this._lineHeight = t.fontInfo.lineHeight, this._typicalHalfwidthCharacterWidth = t.fontInfo.typicalHalfwidthCharacterWidth, this._listContainer = document.createElement("div"), this._listContainer.style.fontFamily = t.fontInfo.fontFamily, this._listContainer.style.fontWeight = t.fontInfo.fontWeight, this._listContainer.style.fontSize = `${t.fontInfo.fontSize}px`, e.appendChild(this._listContainer);
    const i = this, n = new class {
      getTemplateId(o) {
        return "candidate";
      }
      getHeight(o) {
        return i._candidateViewHeight;
      }
    }(), s = new class {
      constructor() {
        this.templateId = "candidate";
      }
      renderTemplate(o) {
        return new es(o, { lineHeight: i._lineHeight });
      }
      renderElement(o, a, l) {
        l.model = o;
      }
      disposeTemplate(o) {
        o.dispose();
      }
    }();
    this._listWidget = new tg("NewSymbolNameCandidates", this._listContainer, n, [s], {
      keyboardSupport: !1,
      // @ulugbekna: because we handle keyboard events through proper commands & keybinding service, see `rename.ts`
      mouseSupport: !0,
      multipleSelectionSupport: !1
    }), this._disposables.add(this._listWidget.onDidChangeSelection((o) => {
      o.elements.length > 0 && t.onSelectionChange();
    })), this._disposables.add(this._listWidget.onDidBlur((o) => {
      this._listWidget.setFocus([]);
    })), this._listWidget.style(Wm);
  }
  dispose() {
    this._listWidget.dispose(), this._disposables.dispose();
  }
  // height - max height allowed by parent element
  layout({ height: e, width: t }) {
    this._availableHeight = e, this._minimumWidth = t;
  }
  setCandidates(e) {
    this._listWidget.splice(0, 0, e);
    const t = this._pickListHeight(e.length), i = this._pickListWidth(e);
    this._listWidget.layout(t, i), this._listContainer.style.height = `${t}px`, this._listContainer.style.width = `${i}px`, zs(g("renameSuggestionsReceivedAria", "Received {0} rename suggestions", e.length));
  }
  clearCandidates() {
    this._listContainer.style.height = "0px", this._listContainer.style.width = "0px", this._listWidget.splice(0, this._listWidget.length, []);
  }
  get nCandidates() {
    return this._listWidget.length;
  }
  get focusedCandidate() {
    if (this._listWidget.length === 0)
      return;
    const e = this._listWidget.getSelectedElements()[0];
    if (e !== void 0)
      return e.newSymbolName;
    const t = this._listWidget.getFocusedElements()[0];
    if (t !== void 0)
      return t.newSymbolName;
  }
  updateFont(e) {
    this._listContainer.style.fontFamily = e.fontFamily, this._listContainer.style.fontWeight = e.fontWeight, this._listContainer.style.fontSize = `${e.fontSize}px`, this._lineHeight = e.lineHeight, this._listWidget.rerender();
  }
  focusNext() {
    this._listWidget.length !== 0 && (this._listWidget.isDOMFocused() ? this._listWidget.focusNext() : (this._listWidget.domFocus(), this._listWidget.focusFirst()), this._listWidget.reveal(this._listWidget.getFocus()[0]));
  }
  /**
   * @returns true if focus is moved to previous element
   */
  focusPrevious() {
    if (this._listWidget.length === 0)
      return !1;
    this._listWidget.domFocus();
    const e = this._listWidget.getFocus()[0];
    return e !== 0 && (this._listWidget.focusPrevious(), this._listWidget.reveal(this._listWidget.getFocus()[0])), e > 0;
  }
  get _candidateViewHeight() {
    const { totalHeight: e } = es.getLayoutInfo({ lineHeight: this._lineHeight });
    return e;
  }
  _pickListHeight(e) {
    const t = this._candidateViewHeight * e;
    return Math.min(t, this._availableHeight, this._candidateViewHeight * 7);
  }
  _pickListWidth(e) {
    const t = Math.ceil(Math.max(...e.map((n) => n.newSymbolName.length)) * this._typicalHalfwidthCharacterWidth);
    return Math.max(
      this._minimumWidth,
      25 + t + 10
      /* (possibly visible) scrollbar width */
      // TODO@ulugbekna: approximate calc - clean this up
    );
  }
}
class es {
  constructor(e, { lineHeight: t }) {
    this.domNode = document.createElement("div"), this.domNode.style.display = "flex", this.domNode.style.alignItems = "center", this.domNode.style.height = `${t}px`, this.domNode.style.padding = `${es._PADDING}px`, this._icon = document.createElement("div"), this._icon.style.display = "flex", this._icon.style.alignItems = "center", this._icon.style.width = this._icon.style.height = `${t * 0.8}px`, this.domNode.appendChild(this._icon), this._label = document.createElement("div"), this._icon.style.display = "flex", this._icon.style.alignItems = "center", this._label.style.marginLeft = "5px", this.domNode.appendChild(this._label), e.appendChild(this.domNode);
  }
  set model(e) {
    this._icon.children.length === 0 && this._icon.appendChild(_y(j.sparkle)), this._label.innerText = e.newSymbolName;
  }
  static getLayoutInfo({ lineHeight: e }) {
    return { totalHeight: e + es._PADDING * 2 };
  }
  dispose() {
  }
}
es._PADDING = 2;
var OP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Bi = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, xu;
class dp {
  constructor(e, t, i) {
    this.model = e, this.position = t, this._providerRenameIdx = 0, this._providers = i.ordered(e);
  }
  hasProvider() {
    return this._providers.length > 0;
  }
  async resolveRenameLocation(e) {
    const t = [];
    for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
      const n = this._providers[this._providerRenameIdx];
      if (!n.resolveRenameLocation)
        break;
      const s = await n.resolveRenameLocation(this.model, this.position, e);
      if (s) {
        if (s.rejectReason) {
          t.push(s.rejectReason);
          continue;
        }
        return s;
      }
    }
    this._providerRenameIdx = 0;
    const i = this.model.getWordAtPosition(this.position);
    return i ? {
      range: new S(this.position.lineNumber, i.startColumn, this.position.lineNumber, i.endColumn),
      text: i.word,
      rejectReason: t.length > 0 ? t.join(`
`) : void 0
    } : {
      range: S.fromPositions(this.position),
      text: "",
      rejectReason: t.length > 0 ? t.join(`
`) : void 0
    };
  }
  async provideRenameEdits(e, t) {
    return this._provideRenameEdits(e, this._providerRenameIdx, [], t);
  }
  async _provideRenameEdits(e, t, i, n) {
    const s = this._providers[t];
    if (!s)
      return {
        edits: [],
        rejectReason: i.join(`
`)
      };
    const o = await s.provideRenameEdits(this.model, this.position, e, n);
    if (o) {
      if (o.rejectReason)
        return this._provideRenameEdits(e, t + 1, i.concat(o.rejectReason), n);
    } else
      return this._provideRenameEdits(e, t + 1, i.concat(g("no result", "No result.")), n);
    return o;
  }
}
async function FP(r, e, t, i) {
  const n = new dp(e, t, r), s = await n.resolveRenameLocation(X.None);
  return s != null && s.rejectReason ? { edits: [], rejectReason: s.rejectReason } : n.provideRenameEdits(i, X.None);
}
let Pi = xu = class {
  static get(e) {
    return e.getContribution(xu.ID);
  }
  constructor(e, t, i, n, s, o, a, l, d) {
    this.editor = e, this._instaService = t, this._notificationService = i, this._bulkEditService = n, this._progressService = s, this._logService = o, this._configService = a, this._languageFeaturesService = l, this._telemetryService = d, this._disposableStore = new M(), this._cts = new Oe(), this._renameInputField = this._disposableStore.add(this._instaService.createInstance(yu, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]));
  }
  dispose() {
    this._disposableStore.dispose(), this._cts.dispose(!0);
  }
  async run() {
    var e, t;
    const i = this._logService.trace.bind(this._logService, "[rename]");
    if (this._cts.dispose(!0), this._cts = new Oe(), !this.editor.hasModel()) {
      i("editor has no model");
      return;
    }
    const n = this.editor.getPosition(), s = new dp(this.editor.getModel(), n, this._languageFeaturesService.renameProvider);
    if (!s.hasProvider()) {
      i("skeleton has no provider");
      return;
    }
    const o = new Vs(this.editor, 5, void 0, this._cts.token);
    let a;
    try {
      i("resolving rename location");
      const w = s.resolveRenameLocation(o.token);
      this._progressService.showWhile(w, 250), a = await w, i("resolved rename location");
    } catch (w) {
      i("resolve rename location failed", JSON.stringify(w, null, "	")), (e = qe.get(this.editor)) === null || e === void 0 || e.showMessage(w || g("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), n);
      return;
    } finally {
      o.dispose();
    }
    if (!a) {
      i("returning early - no loc");
      return;
    }
    if (a.rejectReason) {
      i(`returning early - rejected with reason: ${a.rejectReason}`, a.rejectReason), (t = qe.get(this.editor)) === null || t === void 0 || t.showMessage(a.rejectReason, n);
      return;
    }
    if (o.token.isCancellationRequested) {
      i("returning early - cts1 cancelled");
      return;
    }
    const l = new Vs(this.editor, 5, a.range, this._cts.token), d = this.editor.getModel(), c = new Oe(l.token), h = this._languageFeaturesService.newSymbolNamesProvider.all(d), u = h.map((w) => w.provideNewSymbolNames(d, a.range, c.token));
    i(`requested new symbol names from ${h.length} providers`);
    const p = this.editor.getSelection();
    let f = 0, m = a.text.length;
    !S.isEmpty(p) && !S.spansMultipleLines(p) && S.containsRange(a.range, p) && (f = Math.max(0, p.startColumn - a.range.startColumn), m = Math.min(a.range.endColumn, p.endColumn) - a.range.startColumn), i("creating rename input field and awaiting its result");
    const _ = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview"), v = await this._renameInputField.getInput(a.range, a.text, f, m, _, u, c);
    if (i("received response from rename input field"), h.length > 0 && this._reportTelemetry(h.length, d.getLanguageId(), v), typeof v == "boolean") {
      i(`returning early - rename input field response - ${v}`), v && this.editor.focus(), l.dispose();
      return;
    }
    this.editor.focus(), i("requesting rename edits");
    const C = Zr(s.provideRenameEdits(v.newName, l.token), l.token).then(async (w) => {
      if (!w) {
        i("returning early - no rename edits result");
        return;
      }
      if (!this.editor.hasModel()) {
        i("returning early - no model after rename edits are provided");
        return;
      }
      if (w.rejectReason) {
        i(`returning early - rejected with reason: ${w.rejectReason}`), this._notificationService.info(w.rejectReason);
        return;
      }
      this.editor.setSelection(S.fromPositions(this.editor.getSelection().getPosition())), i("applying edits"), this._bulkEditService.apply(w, {
        editor: this.editor,
        showPreview: v.wantsPreview,
        label: g("label", "Renaming '{0}' to '{1}'", a == null ? void 0 : a.text, v.newName),
        code: "undoredo.rename",
        quotableLabel: g("quotableLabel", "Renaming {0} to {1}", a == null ? void 0 : a.text, v.newName),
        respectAutoSaveConfig: !0
      }).then((y) => {
        i("edits applied"), y.ariaSummary && xt(g("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", a.text, v.newName, y.ariaSummary));
      }).catch((y) => {
        i(`error when applying edits ${JSON.stringify(y, null, "	")}`), this._notificationService.error(g("rename.failedApply", "Rename failed to apply edits")), this._logService.error(y);
      });
    }, (w) => {
      i("error when providing rename edits", JSON.stringify(w, null, "	")), this._notificationService.error(g("rename.failed", "Rename failed to compute edits")), this._logService.error(w);
    }).finally(() => {
      l.dispose();
    });
    return i("returning rename operation"), this._progressService.showWhile(C, 250), C;
  }
  acceptRenameInput(e) {
    this._renameInputField.acceptInput(e);
  }
  cancelRenameInput() {
    this._renameInputField.cancelInput(!0, "cancelRenameInput command");
  }
  focusNextRenameSuggestion() {
    this._renameInputField.focusNextRenameSuggestion();
  }
  focusPreviousRenameSuggestion() {
    this._renameInputField.focusPreviousRenameSuggestion();
  }
  _reportTelemetry(e, t, i) {
    const n = typeof i == "boolean" ? {
      kind: "cancelled",
      languageId: t,
      nRenameSuggestionProviders: e
    } : {
      kind: "accepted",
      languageId: t,
      nRenameSuggestionProviders: e,
      source: i.source,
      nRenameSuggestions: i.nRenameSuggestions,
      wantsPreview: i.wantsPreview
    };
    this._telemetryService.publicLog2("renameInvokedEvent", n);
  }
};
Pi.ID = "editor.contrib.renameController";
Pi = xu = OP([
  Bi(1, q),
  Bi(2, Je),
  Bi(3, id),
  Bi(4, Qr),
  Bi(5, fo),
  Bi(6, vy),
  Bi(7, V),
  Bi(8, ui)
], Pi);
class WP extends D {
  constructor() {
    super({
      id: "editor.action.rename",
      label: g("rename.label", "Rename Symbol"),
      alias: "Rename Symbol",
      precondition: L.and(b.writable, b.hasRenameProvider),
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.1
      }
    });
  }
  runCommand(e, t) {
    const i = e.get(_e), [n, s] = Array.isArray(t) && t || [void 0, void 0];
    return ce.isUri(n) && F.isIPosition(s) ? i.openCodeEditor({ resource: n }, i.getActiveCodeEditor()).then((o) => {
      o && (o.setPosition(s), o.invokeWithinContext((a) => (this.reportTelemetry(a, o), this.run(a, o))));
    }, re) : super.runCommand(e, t);
  }
  run(e, t) {
    const i = e.get(fo), n = Pi.get(t);
    return n ? (i.trace("[RenameAction] got controller, running..."), n.run()) : (i.trace("[RenameAction] returning early - controller missing"), Promise.resolve());
  }
}
Z(
  Pi.ID,
  Pi,
  4
  /* EditorContributionInstantiation.Lazy */
);
x(WP);
const cp = bt.bindToContribution(Pi.get);
B(new cp({
  id: "acceptRenameInput",
  precondition: Lo,
  handler: (r) => r.acceptRenameInput(!1),
  kbOpts: {
    weight: 199,
    kbExpr: L.and(b.focus, L.not("isComposing")),
    primary: 3
    /* KeyCode.Enter */
  }
}));
B(new cp({
  id: "acceptRenameInputWithPreview",
  precondition: L.and(Lo, L.has("config.editor.rename.enablePreview")),
  handler: (r) => r.acceptRenameInput(!0),
  kbOpts: {
    weight: 199,
    kbExpr: L.and(b.focus, L.not("isComposing")),
    primary: 1027
    /* KeyCode.Enter */
  }
}));
B(new cp({
  id: "cancelRenameInput",
  precondition: Lo,
  handler: (r) => r.cancelRenameInput(),
  kbOpts: {
    weight: 199,
    kbExpr: b.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
ne(class extends rt {
  constructor() {
    super({
      id: "focusNextRenameSuggestion",
      title: {
        ...$("focusNextRenameSuggestion", "Focus Next Rename Suggestion")
      },
      precondition: Lo,
      keybinding: [
        {
          primary: 2,
          secondary: [
            18
            /* KeyCode.DownArrow */
          ],
          weight: 199
        }
      ]
    });
  }
  run(e) {
    const t = e.get(_e).getFocusedCodeEditor();
    if (!t)
      return;
    const i = Pi.get(t);
    i && i.focusNextRenameSuggestion();
  }
});
ne(class extends rt {
  constructor() {
    super({
      id: "focusPreviousRenameSuggestion",
      title: {
        ...$("focusPreviousRenameSuggestion", "Focus Previous Rename Suggestion")
      },
      precondition: Lo,
      keybinding: [
        {
          when: wu,
          primary: 6,
          weight: 199
        },
        {
          when: wu.toNegated(),
          primary: 1026,
          secondary: [
            16
            /* KeyCode.UpArrow */
          ],
          weight: 199
        }
      ]
    });
  }
  run(e) {
    const t = e.get(_e).getFocusedCodeEditor();
    if (!t)
      return;
    const i = Pi.get(t);
    i && i.focusPreviousRenameSuggestion();
  }
});
pi("_executeDocumentRenameProvider", function(r, e, t, ...i) {
  const [n] = i;
  ie(typeof n == "string");
  const { renameProvider: s } = r.get(V);
  return FP(s, e, t, n);
});
pi("_executePrepareRename", async function(r, e, t) {
  const { renameProvider: i } = r.get(V), s = await new dp(e, t, i).resolveRenameLocation(X.None);
  if (s != null && s.rejectReason)
    throw new Error(s.rejectReason);
  return s;
});
hi.as(rd.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "editor.rename.enablePreview": {
      scope: 5,
      description: g("enablePreview", "Enable/disable the ability to preview changes before renaming"),
      default: !0,
      type: "boolean"
    }
  }
});
function HP(r) {
  for (let e = 0, t = r.length; e < t; e += 4) {
    const i = r[e + 0], n = r[e + 1], s = r[e + 2], o = r[e + 3];
    r[e + 0] = o, r[e + 1] = s, r[e + 2] = n, r[e + 3] = i;
  }
}
function BP(r) {
  const e = new Uint8Array(r.buffer, r.byteOffset, r.length * 4);
  return by() || HP(e), Cy.wrap(e);
}
function _C(r) {
  const e = new Uint32Array(VP(r));
  let t = 0;
  if (e[t++] = r.id, r.type === "full")
    e[t++] = 1, e[t++] = r.data.length, e.set(r.data, t), t += r.data.length;
  else {
    e[t++] = 2, e[t++] = r.deltas.length;
    for (const i of r.deltas)
      e[t++] = i.start, e[t++] = i.deleteCount, i.data ? (e[t++] = i.data.length, e.set(i.data, t), t += i.data.length) : e[t++] = 0;
  }
  return BP(e);
}
function VP(r) {
  let e = 0;
  if (e += 2, r.type === "full")
    e += 1 + r.data.length;
  else {
    e += 1, e += 3 * r.deltas.length;
    for (const t of r.deltas)
      t.data && (e += t.data.length);
  }
  return e;
}
function sc(r) {
  return r && !!r.data;
}
function vC(r) {
  return r && Array.isArray(r.edits);
}
class UP {
  constructor(e, t, i) {
    this.provider = e, this.tokens = t, this.error = i;
  }
}
function bC(r, e) {
  return r.has(e);
}
function zP(r, e) {
  const t = r.orderedGroups(e);
  return t.length > 0 ? t[0] : [];
}
async function CC(r, e, t, i, n) {
  const s = zP(r, e), o = await Promise.all(s.map(async (a) => {
    let l, d = null;
    try {
      l = await a.provideDocumentSemanticTokens(e, a === t ? i : null, n);
    } catch (c) {
      d = c, l = null;
    }
    return (!l || !sc(l) && !vC(l)) && (l = null), new UP(a, l, d);
  }));
  for (const a of o) {
    if (a.error)
      throw a.error;
    if (a.tokens)
      return a;
  }
  return o.length > 0 ? o[0] : null;
}
function $P(r, e) {
  const t = r.orderedGroups(e);
  return t.length > 0 ? t[0] : null;
}
class jP {
  constructor(e, t) {
    this.provider = e, this.tokens = t;
  }
}
function qP(r, e) {
  return r.has(e);
}
function SC(r, e) {
  const t = r.orderedGroups(e);
  return t.length > 0 ? t[0] : [];
}
async function hp(r, e, t, i) {
  const n = SC(r, e), s = await Promise.all(n.map(async (o) => {
    let a;
    try {
      a = await o.provideDocumentRangeSemanticTokens(e, t, i);
    } catch (l) {
      Ie(l), a = null;
    }
    return (!a || !sc(a)) && (a = null), new jP(o, a);
  }));
  for (const o of s)
    if (o.tokens)
      return o;
  return s.length > 0 ? s[0] : null;
}
de.registerCommand("_provideDocumentSemanticTokensLegend", async (r, ...e) => {
  const [t] = e;
  ie(t instanceof ce);
  const i = r.get(Ge).getModel(t);
  if (!i)
    return;
  const { documentSemanticTokensProvider: n } = r.get(V), s = $P(n, i);
  return s ? s[0].getLegend() : r.get(Fe).executeCommand("_provideDocumentRangeSemanticTokensLegend", t);
});
de.registerCommand("_provideDocumentSemanticTokens", async (r, ...e) => {
  const [t] = e;
  ie(t instanceof ce);
  const i = r.get(Ge).getModel(t);
  if (!i)
    return;
  const { documentSemanticTokensProvider: n } = r.get(V);
  if (!bC(n, i))
    return r.get(Fe).executeCommand("_provideDocumentRangeSemanticTokens", t, i.getFullModelRange());
  const s = await CC(n, i, null, null, X.None);
  if (!s)
    return;
  const { provider: o, tokens: a } = s;
  if (!a || !sc(a))
    return;
  const l = _C({
    id: 0,
    type: "full",
    data: a.data
  });
  return a.resultId && o.releaseDocumentSemanticTokens(a.resultId), l;
});
de.registerCommand("_provideDocumentRangeSemanticTokensLegend", async (r, ...e) => {
  const [t, i] = e;
  ie(t instanceof ce);
  const n = r.get(Ge).getModel(t);
  if (!n)
    return;
  const { documentRangeSemanticTokensProvider: s } = r.get(V), o = SC(s, n);
  if (o.length === 0)
    return;
  if (o.length === 1)
    return o[0].getLegend();
  if (!i || !S.isIRange(i))
    return console.warn("provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in"), o[0].getLegend();
  const a = await hp(s, n, S.lift(i), X.None);
  if (a)
    return a.provider.getLegend();
});
de.registerCommand("_provideDocumentRangeSemanticTokens", async (r, ...e) => {
  const [t, i] = e;
  ie(t instanceof ce), ie(S.isIRange(i));
  const n = r.get(Ge).getModel(t);
  if (!n)
    return;
  const { documentRangeSemanticTokensProvider: s } = r.get(V), o = await hp(s, n, S.lift(i), X.None);
  if (!(!o || !o.tokens))
    return _C({
      id: 0,
      type: "full",
      data: o.tokens.data
    });
});
const up = "editor.semanticHighlighting";
function vl(r, e, t) {
  var i;
  const n = (i = t.getValue(up, { overrideIdentifier: r.getLanguageId(), resource: r.uri })) === null || i === void 0 ? void 0 : i.enabled;
  return typeof n == "boolean" ? n : e.getColorTheme().semanticHighlighting;
}
var wC = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ei = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Vi;
let Lu = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._watchers = /* @__PURE__ */ Object.create(null);
    const a = (c) => {
      this._watchers[c.uri.toString()] = new Vr(c, e, i, s, o);
    }, l = (c, h) => {
      h.dispose(), delete this._watchers[c.uri.toString()];
    }, d = () => {
      for (const c of t.getModels()) {
        const h = this._watchers[c.uri.toString()];
        vl(c, i, n) ? h || a(c) : h && l(c, h);
      }
    };
    t.getModels().forEach((c) => {
      vl(c, i, n) && a(c);
    }), this._register(t.onModelAdded((c) => {
      vl(c, i, n) && a(c);
    })), this._register(t.onModelRemoved((c) => {
      const h = this._watchers[c.uri.toString()];
      h && l(c, h);
    })), this._register(n.onDidChangeConfiguration((c) => {
      c.affectsConfiguration(up) && d();
    })), this._register(i.onDidColorThemeChange(d));
  }
  dispose() {
    for (const e of Object.values(this._watchers))
      e.dispose();
    super.dispose();
  }
};
Lu = wC([
  ei(0, wg),
  ei(1, Ge),
  ei(2, Mt),
  ei(3, he),
  ei(4, Pt),
  ei(5, V)
], Lu);
let Vr = Vi = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._semanticTokensStylingService = t, this._isDisposed = !1, this._model = e, this._provider = s.documentSemanticTokensProvider, this._debounceInformation = n.for(this._provider, "DocumentSemanticTokens", { min: Vi.REQUEST_MIN_DELAY, max: Vi.REQUEST_MAX_DELAY }), this._fetchDocumentSemanticTokens = this._register(new Re(() => this._fetchDocumentSemanticTokensNow(), Vi.REQUEST_MIN_DELAY)), this._currentDocumentResponse = null, this._currentDocumentRequestCancellationTokenSource = null, this._documentProvidersChangeListeners = [], this._providersChangedDuringRequest = !1, this._register(this._model.onDidChangeContent(() => {
      this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._register(this._model.onDidChangeAttached(() => {
      this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._register(this._model.onDidChangeLanguage(() => {
      this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const o = () => {
      $e(this._documentProvidersChangeListeners), this._documentProvidersChangeListeners = [];
      for (const a of this._provider.all(e))
        typeof a.onDidChange == "function" && this._documentProvidersChangeListeners.push(a.onDidChange(() => {
          if (this._currentDocumentRequestCancellationTokenSource) {
            this._providersChangedDuringRequest = !0;
            return;
          }
          this._fetchDocumentSemanticTokens.schedule(0);
        }));
    };
    o(), this._register(this._provider.onDidChange(() => {
      o(), this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._register(i.onDidColorThemeChange((a) => {
      this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), $e(this._documentProvidersChangeListeners), this._documentProvidersChangeListeners = [], this._setDocumentSemanticTokens(null, null, null, []), this._isDisposed = !0, super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource)
      return;
    if (!bC(this._provider, this._model)) {
      this._currentDocumentResponse && this._model.tokenization.setSemanticTokens(null, !1);
      return;
    }
    if (!this._model.isAttachedToEditor())
      return;
    const e = new Oe(), t = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null, i = this._currentDocumentResponse && this._currentDocumentResponse.resultId || null, n = CC(this._provider, this._model, t, i, e.token);
    this._currentDocumentRequestCancellationTokenSource = e, this._providersChangedDuringRequest = !1;
    const s = [], o = this._model.onDidChangeContent((l) => {
      s.push(l);
    }), a = new Rt(!1);
    n.then((l) => {
      if (this._debounceInformation.update(this._model, a.elapsed()), this._currentDocumentRequestCancellationTokenSource = null, o.dispose(), !l)
        this._setDocumentSemanticTokens(null, null, null, s);
      else {
        const { provider: d, tokens: c } = l, h = this._semanticTokensStylingService.getStyling(d);
        this._setDocumentSemanticTokens(d, c || null, h, s);
      }
    }, (l) => {
      l && (go(l) || typeof l.message == "string" && l.message.indexOf("busy") !== -1) || re(l), this._currentDocumentRequestCancellationTokenSource = null, o.dispose(), (s.length > 0 || this._providersChangedDuringRequest) && (this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model)));
    });
  }
  static _copy(e, t, i, n, s) {
    s = Math.min(s, i.length - n, e.length - t);
    for (let o = 0; o < s; o++)
      i[n + o] = e[t + o];
  }
  _setDocumentSemanticTokens(e, t, i, n) {
    const s = this._currentDocumentResponse, o = () => {
      (n.length > 0 || this._providersChangedDuringRequest) && !this._fetchDocumentSemanticTokens.isScheduled() && this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    };
    if (this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._isDisposed) {
      e && t && e.releaseDocumentSemanticTokens(t.resultId);
      return;
    }
    if (!e || !i) {
      this._model.tokenization.setSemanticTokens(null, !1);
      return;
    }
    if (!t) {
      this._model.tokenization.setSemanticTokens(null, !0), o();
      return;
    }
    if (vC(t)) {
      if (!s) {
        this._model.tokenization.setSemanticTokens(null, !0);
        return;
      }
      if (t.edits.length === 0)
        t = {
          resultId: t.resultId,
          data: s.data
        };
      else {
        let a = 0;
        for (const u of t.edits)
          a += (u.data ? u.data.length : 0) - u.deleteCount;
        const l = s.data, d = new Uint32Array(l.length + a);
        let c = l.length, h = d.length;
        for (let u = t.edits.length - 1; u >= 0; u--) {
          const p = t.edits[u];
          if (p.start > l.length) {
            i.warnInvalidEditStart(s.resultId, t.resultId, u, p.start, l.length), this._model.tokenization.setSemanticTokens(null, !0);
            return;
          }
          const f = c - (p.start + p.deleteCount);
          f > 0 && (Vi._copy(l, c - f, d, h - f, f), h -= f), p.data && (Vi._copy(p.data, 0, d, h - p.data.length, p.data.length), h -= p.data.length), c = p.start;
        }
        c > 0 && Vi._copy(l, 0, d, 0, c), t = {
          resultId: t.resultId,
          data: d
        };
      }
    }
    if (sc(t)) {
      this._currentDocumentResponse = new KP(e, t.resultId, t.data);
      const a = O_(t, i, this._model.getLanguageId());
      if (n.length > 0)
        for (const l of n)
          for (const d of a)
            for (const c of l.changes)
              d.applyEdit(c.range, c.text);
      this._model.tokenization.setSemanticTokens(a, !0);
    } else
      this._model.tokenization.setSemanticTokens(null, !0);
    o();
  }
};
Vr.REQUEST_MIN_DELAY = 300;
Vr.REQUEST_MAX_DELAY = 2e3;
Vr = Vi = wC([
  ei(1, wg),
  ei(2, Mt),
  ei(3, Pt),
  ei(4, V)
], Vr);
class KP {
  constructor(e, t, i) {
    this.provider = e, this.resultId = t, this.data = i;
  }
  dispose() {
    this.provider.releaseDocumentSemanticTokens(this.resultId);
  }
}
Jr(Lu);
var GP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Vo = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Ur = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._semanticTokensStylingService = t, this._themeService = i, this._configurationService = n, this._editor = e, this._provider = o.documentRangeSemanticTokensProvider, this._debounceInformation = s.for(this._provider, "DocumentRangeSemanticTokens", { min: 100, max: 500 }), this._tokenizeViewport = this._register(new Re(() => this._tokenizeViewportNow(), 100)), this._outstandingRequests = [];
    const a = () => {
      this._editor.hasModel() && this._tokenizeViewport.schedule(this._debounceInformation.get(this._editor.getModel()));
    };
    this._register(this._editor.onDidScrollChange(() => {
      a();
    })), this._register(this._editor.onDidChangeModel(() => {
      this._cancelAll(), a();
    })), this._register(this._editor.onDidChangeModelContent((l) => {
      this._cancelAll(), a();
    })), this._register(this._provider.onDidChange(() => {
      this._cancelAll(), a();
    })), this._register(this._configurationService.onDidChangeConfiguration((l) => {
      l.affectsConfiguration(up) && (this._cancelAll(), a());
    })), this._register(this._themeService.onDidColorThemeChange(() => {
      this._cancelAll(), a();
    })), a();
  }
  _cancelAll() {
    for (const e of this._outstandingRequests)
      e.cancel();
    this._outstandingRequests = [];
  }
  _removeOutstandingRequest(e) {
    for (let t = 0, i = this._outstandingRequests.length; t < i; t++)
      if (this._outstandingRequests[t] === e) {
        this._outstandingRequests.splice(t, 1);
        return;
      }
  }
  _tokenizeViewportNow() {
    if (!this._editor.hasModel())
      return;
    const e = this._editor.getModel();
    if (e.tokenization.hasCompleteSemanticTokens())
      return;
    if (!vl(e, this._themeService, this._configurationService)) {
      e.tokenization.hasSomeSemanticTokens() && e.tokenization.setSemanticTokens(null, !1);
      return;
    }
    if (!qP(this._provider, e)) {
      e.tokenization.hasSomeSemanticTokens() && e.tokenization.setSemanticTokens(null, !1);
      return;
    }
    const t = this._editor.getVisibleRangesPlusViewportAboveBelow();
    this._outstandingRequests = this._outstandingRequests.concat(t.map((i) => this._requestRange(e, i)));
  }
  _requestRange(e, t) {
    const i = e.getVersionId(), n = Pe((o) => Promise.resolve(hp(this._provider, e, t, o))), s = new Rt(!1);
    return n.then((o) => {
      if (this._debounceInformation.update(e, s.elapsed()), !o || !o.tokens || e.isDisposed() || e.getVersionId() !== i)
        return;
      const { provider: a, tokens: l } = o, d = this._semanticTokensStylingService.getStyling(a);
      e.tokenization.setPartialSemanticTokens(t, O_(l, d, e.getLanguageId()));
    }).then(() => this._removeOutstandingRequest(n), () => this._removeOutstandingRequest(n)), n;
  }
};
Ur.ID = "editor.contrib.viewportSemanticTokens";
Ur = GP([
  Vo(1, wg),
  Vo(2, Mt),
  Vo(3, he),
  Vo(4, Pt),
  Vo(5, V)
], Ur);
Z(
  Ur.ID,
  Ur,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
class ZP {
  constructor(e = !0) {
    this.selectSubwords = e;
  }
  provideSelectionRanges(e, t) {
    const i = [];
    for (const n of t) {
      const s = [];
      i.push(s), this.selectSubwords && this._addInWordRanges(s, e, n), this._addWordRanges(s, e, n), this._addWhitespaceLine(s, e, n), s.push({ range: e.getFullModelRange() });
    }
    return i;
  }
  _addInWordRanges(e, t, i) {
    const n = t.getWordAtPosition(i);
    if (!n)
      return;
    const { word: s, startColumn: o } = n, a = i.column - o;
    let l = a, d = a, c = 0;
    for (; l >= 0; l--) {
      const h = s.charCodeAt(l);
      if (l !== a && (h === 95 || h === 45))
        break;
      if (qp(h) && Kp(c))
        break;
      c = h;
    }
    for (l += 1; d < s.length; d++) {
      const h = s.charCodeAt(d);
      if (Kp(h) && qp(c))
        break;
      if (h === 95 || h === 45)
        break;
      c = h;
    }
    l < d && e.push({ range: new S(i.lineNumber, o + l, i.lineNumber, o + d) });
  }
  _addWordRanges(e, t, i) {
    const n = t.getWordAtPosition(i);
    n && e.push({ range: new S(i.lineNumber, n.startColumn, i.lineNumber, n.endColumn) });
  }
  _addWhitespaceLine(e, t, i) {
    t.getLineLength(i.lineNumber) > 0 && t.getLineFirstNonWhitespaceColumn(i.lineNumber) === 0 && t.getLineLastNonWhitespaceColumn(i.lineNumber) === 0 && e.push({ range: new S(i.lineNumber, 1, i.lineNumber, t.getLineMaxColumn(i.lineNumber)) });
  }
}
var XP = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, QP = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Iu;
class gp {
  constructor(e, t) {
    this.index = e, this.ranges = t;
  }
  mov(e) {
    const t = this.index + (e ? 1 : -1);
    if (t < 0 || t >= this.ranges.length)
      return this;
    const i = new gp(t, this.ranges);
    return i.ranges[t].equalsRange(this.ranges[this.index]) ? i.mov(e) : i;
  }
}
let ro = Iu = class {
  static get(e) {
    return e.getContribution(Iu.ID);
  }
  constructor(e, t) {
    this._editor = e, this._languageFeaturesService = t, this._ignoreSelection = !1;
  }
  dispose() {
    var e;
    (e = this._selectionListener) === null || e === void 0 || e.dispose();
  }
  async run(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getSelections(), i = this._editor.getModel();
    if (this._state || await xC(this._languageFeaturesService.selectionRangeProvider, i, t.map((s) => s.getPosition()), this._editor.getOption(
      113
      /* EditorOption.smartSelect */
    ), X.None).then((s) => {
      var o;
      if (!(!nt(s) || s.length !== t.length) && !(!this._editor.hasModel() || !jt(this._editor.getSelections(), t, (a, l) => a.equalsSelection(l)))) {
        for (let a = 0; a < s.length; a++)
          s[a] = s[a].filter((l) => l.containsPosition(t[a].getStartPosition()) && l.containsPosition(t[a].getEndPosition())), s[a].unshift(t[a]);
        this._state = s.map((a) => new gp(0, a)), (o = this._selectionListener) === null || o === void 0 || o.dispose(), this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
          var a;
          this._ignoreSelection || ((a = this._selectionListener) === null || a === void 0 || a.dispose(), this._state = void 0);
        });
      }
    }), !this._state)
      return;
    this._state = this._state.map((s) => s.mov(e));
    const n = this._state.map((s) => z.fromPositions(s.ranges[s.index].getStartPosition(), s.ranges[s.index].getEndPosition()));
    this._ignoreSelection = !0;
    try {
      this._editor.setSelections(n);
    } finally {
      this._ignoreSelection = !1;
    }
  }
};
ro.ID = "editor.contrib.smartSelectController";
ro = Iu = XP([
  QP(1, V)
], ro);
class yC extends D {
  constructor(e, t) {
    super(t), this._forward = e;
  }
  async run(e, t) {
    const i = ro.get(t);
    i && await i.run(this._forward);
  }
}
class YP extends yC {
  constructor() {
    super(!0, {
      id: "editor.action.smartSelect.expand",
      label: g("smartSelect.expand", "Expand Selection"),
      alias: "Expand Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 1553,
        mac: {
          primary: 3345,
          secondary: [
            1297
            /* KeyCode.RightArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "1_basic",
        title: g({ key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"] }, "&&Expand Selection"),
        order: 2
      }
    });
  }
}
de.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
class JP extends yC {
  constructor() {
    super(!1, {
      id: "editor.action.smartSelect.shrink",
      label: g("smartSelect.shrink", "Shrink Selection"),
      alias: "Shrink Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 1551,
        mac: {
          primary: 3343,
          secondary: [
            1295
            /* KeyCode.LeftArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: E.MenubarSelectionMenu,
        group: "1_basic",
        title: g({ key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"] }, "&&Shrink Selection"),
        order: 3
      }
    });
  }
}
Z(
  ro.ID,
  ro,
  4
  /* EditorContributionInstantiation.Lazy */
);
x(YP);
x(JP);
async function xC(r, e, t, i, n) {
  const s = r.all(e).concat(new ZP(i.selectSubwords));
  s.length === 1 && s.unshift(new ct());
  const o = [], a = [];
  for (const l of s)
    o.push(Promise.resolve(l.provideSelectionRanges(e, t, n)).then((d) => {
      if (nt(d) && d.length === t.length)
        for (let c = 0; c < t.length; c++) {
          a[c] || (a[c] = []);
          for (const h of d[c])
            S.isIRange(h.range) && S.containsPosition(h.range, t[c]) && a[c].push(S.lift(h.range));
        }
    }, Ie));
  return await Promise.all(o), a.map((l) => {
    if (l.length === 0)
      return [];
    l.sort((u, p) => F.isBefore(u.getStartPosition(), p.getStartPosition()) ? 1 : F.isBefore(p.getStartPosition(), u.getStartPosition()) || F.isBefore(u.getEndPosition(), p.getEndPosition()) ? -1 : F.isBefore(p.getEndPosition(), u.getEndPosition()) ? 1 : 0);
    const d = [];
    let c;
    for (const u of l)
      (!c || S.containsRange(u, c) && !S.equalsRange(u, c)) && (d.push(u), c = u);
    if (!i.selectLeadingAndTrailingWhitespace)
      return d;
    const h = [d[0]];
    for (let u = 1; u < d.length; u++) {
      const p = d[u - 1], f = d[u];
      if (f.startLineNumber !== p.startLineNumber || f.endLineNumber !== p.endLineNumber) {
        const m = new S(p.startLineNumber, e.getLineFirstNonWhitespaceColumn(p.startLineNumber), p.endLineNumber, e.getLineLastNonWhitespaceColumn(p.endLineNumber));
        m.containsRange(p) && !m.equalsRange(p) && f.containsRange(m) && !f.equalsRange(m) && h.push(m);
        const _ = new S(p.startLineNumber, 1, p.endLineNumber, e.getLineMaxColumn(p.endLineNumber));
        _.containsRange(p) && !_.equalsRange(m) && f.containsRange(_) && !f.equalsRange(_) && h.push(_);
      }
      h.push(f);
    }
    return h;
  });
}
de.registerCommand("_executeSelectionRangeProvider", async function(r, ...e) {
  const [t, i] = e;
  ie(ce.isUri(t));
  const n = r.get(V).selectionRangeProvider, s = await r.get(Zt).createModelReference(t);
  try {
    return xC(n, s.object.textEditorModel, i, { selectLeadingAndTrailingWhitespace: !0, selectSubwords: !0 }, X.None);
  } finally {
    s.dispose();
  }
});
const eM = Object.freeze({
  View: $("view", "View"),
  Help: $("help", "Help"),
  Test: $("test", "Test"),
  File: $("file", "File"),
  Preferences: $("preferences", "Preferences"),
  Developer: $({ key: "developer", comment: ["A developer on Code itself or someone diagnosing issues in Code"] }, "Developer")
});
class _m {
  constructor(e, t, i, n = null) {
    this.startLineNumbers = e, this.endLineNumbers = t, this.lastLineRelativePosition = i, this.showEndForLine = n;
  }
  equals(e) {
    return !!e && this.lastLineRelativePosition === e.lastLineRelativePosition && this.showEndForLine === e.showEndForLine && jt(this.startLineNumbers, e.startLineNumbers) && jt(this.endLineNumbers, e.endLineNumbers);
  }
}
const vm = C_("stickyScrollViewLayer", { createHTML: (r) => r }), qc = "data-sticky-line-index", bm = "data-sticky-is-line", tM = "data-sticky-is-line-number", Cm = "data-sticky-is-folding-icon";
class iM extends P {
  constructor(e) {
    super(), this._editor = e, this._foldingIconStore = new M(), this._rootDomNode = document.createElement("div"), this._lineNumbersDomNode = document.createElement("div"), this._linesDomNodeScrollable = document.createElement("div"), this._linesDomNode = document.createElement("div"), this._lineHeight = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), this._renderedStickyLines = [], this._lineNumbers = [], this._lastLineRelativePosition = 0, this._minContentWidthInPx = 0, this._isOnGlyphMargin = !1, this._lineNumbersDomNode.className = "sticky-widget-line-numbers", this._lineNumbersDomNode.setAttribute("role", "none"), this._linesDomNode.className = "sticky-widget-lines", this._linesDomNode.setAttribute("role", "list"), this._linesDomNodeScrollable.className = "sticky-widget-lines-scrollable", this._linesDomNodeScrollable.appendChild(this._linesDomNode), this._rootDomNode.className = "sticky-widget", this._rootDomNode.classList.toggle("peek", e instanceof an), this._rootDomNode.appendChild(this._lineNumbersDomNode), this._rootDomNode.appendChild(this._linesDomNodeScrollable);
    const t = () => {
      this._linesDomNode.style.left = this._editor.getOption(
        115
        /* EditorOption.stickyScroll */
      ).scrollWithEditor ? `-${this._editor.getScrollLeft()}px` : "0px";
    };
    this._register(this._editor.onDidChangeConfiguration((i) => {
      i.hasChanged(
        115
        /* EditorOption.stickyScroll */
      ) && t(), i.hasChanged(
        67
        /* EditorOption.lineHeight */
      ) && (this._lineHeight = this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      ));
    })), this._register(this._editor.onDidScrollChange((i) => {
      i.scrollLeftChanged && t(), i.scrollWidthChanged && this._updateWidgetWidth();
    })), this._register(this._editor.onDidChangeModel(() => {
      t(), this._updateWidgetWidth();
    })), this._register(this._foldingIconStore), t(), this._register(this._editor.onDidLayoutChange((i) => {
      this._updateWidgetWidth();
    })), this._updateWidgetWidth();
  }
  get lineNumbers() {
    return this._lineNumbers;
  }
  get lineNumberCount() {
    return this._lineNumbers.length;
  }
  getRenderedStickyLine(e) {
    return this._renderedStickyLines.find((t) => t.lineNumber === e);
  }
  getCurrentLines() {
    return this._lineNumbers;
  }
  setState(e, t, i) {
    if (i === void 0 && (!this._previousState && !e || this._previousState && this._previousState.equals(e)))
      return;
    const n = this._isWidgetHeightZero(e), s = n ? void 0 : e, o = n ? 0 : this._findLineToRebuildWidgetFrom(e, i);
    this._renderRootNode(s, t, o), this._previousState = e;
  }
  _isWidgetHeightZero(e) {
    if (!e)
      return !0;
    const t = e.startLineNumbers.length * this._lineHeight + e.lastLineRelativePosition;
    if (t > 0) {
      this._lastLineRelativePosition = e.lastLineRelativePosition;
      const i = [...e.startLineNumbers];
      e.showEndForLine !== null && (i[e.showEndForLine] = e.endLineNumbers[e.showEndForLine]), this._lineNumbers = i;
    } else
      this._lastLineRelativePosition = 0, this._lineNumbers = [];
    return t === 0;
  }
  _findLineToRebuildWidgetFrom(e, t) {
    if (!e || !this._previousState)
      return 0;
    if (t !== void 0)
      return t;
    const i = this._previousState, n = e.startLineNumbers.findIndex((s) => !i.startLineNumbers.includes(s));
    return n === -1 ? 0 : n;
  }
  _updateWidgetWidth() {
    const e = this._editor.getLayoutInfo(), t = e.contentLeft;
    this._lineNumbersDomNode.style.width = `${t}px`, this._linesDomNodeScrollable.style.setProperty("--vscode-editorStickyScroll-scrollableWidth", `${this._editor.getScrollWidth() - e.verticalScrollbarWidth}px`), this._rootDomNode.style.width = `${e.width - e.verticalScrollbarWidth}px`;
  }
  _clearStickyLinesFromLine(e) {
    this._foldingIconStore.clear();
    for (let t = e; t < this._renderedStickyLines.length; t++) {
      const i = this._renderedStickyLines[t];
      i.lineNumberDomNode.remove(), i.lineDomNode.remove();
    }
    this._renderedStickyLines = this._renderedStickyLines.slice(0, e), this._rootDomNode.style.display = "none";
  }
  _useFoldingOpacityTransition(e) {
    this._lineNumbersDomNode.style.setProperty("--vscode-editorStickyScroll-foldingOpacityTransition", `opacity ${e ? 0.5 : 0}s`);
  }
  _setFoldingIconsVisibility(e) {
    for (const t of this._renderedStickyLines) {
      const i = t.foldingIcon;
      i && i.setVisible(e ? !0 : i.isCollapsed);
    }
  }
  async _renderRootNode(e, t, i) {
    if (this._clearStickyLinesFromLine(i), !e)
      return;
    for (const a of this._renderedStickyLines)
      this._updateTopAndZIndexOfStickyLine(a);
    const n = this._editor.getLayoutInfo(), s = this._lineNumbers.slice(i);
    for (const [a, l] of s.entries()) {
      const d = this._renderChildNode(a + i, l, t, n);
      d && (this._linesDomNode.appendChild(d.lineDomNode), this._lineNumbersDomNode.appendChild(d.lineNumberDomNode), this._renderedStickyLines.push(d));
    }
    t && (this._setFoldingHoverListeners(), this._useFoldingOpacityTransition(!this._isOnGlyphMargin));
    const o = this._lineNumbers.length * this._lineHeight + this._lastLineRelativePosition;
    this._rootDomNode.style.display = "block", this._lineNumbersDomNode.style.height = `${o}px`, this._linesDomNodeScrollable.style.height = `${o}px`, this._rootDomNode.style.height = `${o}px`, this._rootDomNode.style.marginLeft = "0px", this._minContentWidthInPx = Math.max(...this._renderedStickyLines.map((a) => a.scrollWidth)) + n.verticalScrollbarWidth, this._editor.layoutOverlayWidget(this);
  }
  _setFoldingHoverListeners() {
    this._editor.getOption(
      110
      /* EditorOption.showFoldingControls */
    ) === "mouseover" && (this._foldingIconStore.add(le(this._lineNumbersDomNode, Le.MOUSE_ENTER, () => {
      this._isOnGlyphMargin = !0, this._setFoldingIconsVisibility(!0);
    })), this._foldingIconStore.add(le(this._lineNumbersDomNode, Le.MOUSE_LEAVE, () => {
      this._isOnGlyphMargin = !1, this._useFoldingOpacityTransition(!0), this._setFoldingIconsVisibility(!1);
    })));
  }
  _renderChildNode(e, t, i, n) {
    const s = this._editor._getViewModel();
    if (!s)
      return;
    const o = s.coordinatesConverter.convertModelPositionToViewPosition(new F(t, 1)).lineNumber, a = s.getViewLineRenderingData(o), l = this._editor.getOption(
      68
      /* EditorOption.lineNumbers */
    );
    let d;
    try {
      d = Cr.filter(a.inlineDecorations, o, a.minColumn, a.maxColumn);
    } catch {
      d = [];
    }
    const c = new w_(!0, !0, a.content, a.continuesWithWrappedLine, a.isBasicASCII, a.containsRTL, 0, a.tokens, d, a.tabSize, a.startVisibleColumn, 1, 1, 1, 500, "none", !0, !0, null), h = new y_(2e3), u = S_(c, h);
    let p;
    vm ? p = vm.createHTML(h.build()) : p = h.build();
    const f = document.createElement("span");
    f.setAttribute(qc, String(e)), f.setAttribute(bm, ""), f.setAttribute("role", "listitem"), f.tabIndex = 0, f.className = "sticky-line-content", f.classList.add(`stickyLine${t}`), f.style.lineHeight = `${this._lineHeight}px`, f.innerHTML = p;
    const m = document.createElement("span");
    m.setAttribute(qc, String(e)), m.setAttribute(tM, ""), m.className = "sticky-line-number", m.style.lineHeight = `${this._lineHeight}px`;
    const _ = n.contentLeft;
    m.style.width = `${_}px`;
    const v = document.createElement("span");
    l.renderType === 1 || l.renderType === 3 && t % 10 === 0 ? v.innerText = t.toString() : l.renderType === 2 && (v.innerText = Math.abs(t - this._editor.getPosition().lineNumber).toString()), v.className = "sticky-line-number-inner", v.style.lineHeight = `${this._lineHeight}px`, v.style.width = `${n.lineNumbersWidth}px`, v.style.paddingLeft = `${n.lineNumbersLeft}px`, m.appendChild(v);
    const C = this._renderFoldingIconForLine(i, t);
    C && m.appendChild(C.domNode), this._editor.applyFontInfo(f), this._editor.applyFontInfo(v), m.style.lineHeight = `${this._lineHeight}px`, f.style.lineHeight = `${this._lineHeight}px`, m.style.height = `${this._lineHeight}px`, f.style.height = `${this._lineHeight}px`;
    const w = new nM(e, t, f, m, C, u.characterMapping, f.scrollWidth);
    return this._updateTopAndZIndexOfStickyLine(w);
  }
  _updateTopAndZIndexOfStickyLine(e) {
    var t;
    const i = e.index, n = e.lineDomNode, s = e.lineNumberDomNode, o = i === this._lineNumbers.length - 1, a = "0", l = "1";
    n.style.zIndex = o ? a : l, s.style.zIndex = o ? a : l;
    const d = `${i * this._lineHeight + this._lastLineRelativePosition + (!((t = e.foldingIcon) === null || t === void 0) && t.isCollapsed ? 1 : 0)}px`, c = `${i * this._lineHeight}px`;
    return n.style.top = o ? d : c, s.style.top = o ? d : c, e;
  }
  _renderFoldingIconForLine(e, t) {
    const i = this._editor.getOption(
      110
      /* EditorOption.showFoldingControls */
    );
    if (!e || i === "never")
      return;
    const n = e.regions, s = n.findRange(t), o = n.getStartLineNumber(s);
    if (!(t === o))
      return;
    const l = n.isCollapsed(s), d = new sM(l, o, n.getEndLineNumber(s), this._lineHeight);
    return d.setVisible(this._isOnGlyphMargin ? !0 : l || i === "always"), d.domNode.setAttribute(Cm, ""), d;
  }
  getId() {
    return "editor.contrib.stickyScrollWidget";
  }
  getDomNode() {
    return this._rootDomNode;
  }
  getPosition() {
    return {
      preference: null
    };
  }
  getMinContentWidthInPx() {
    return this._minContentWidthInPx;
  }
  focusLineWithIndex(e) {
    0 <= e && e < this._renderedStickyLines.length && this._renderedStickyLines[e].lineDomNode.focus();
  }
  /**
   * Given a leaf dom node, tries to find the editor position.
   */
  getEditorPositionFromNode(e) {
    if (!e || e.children.length > 0)
      return null;
    const t = this._getRenderedStickyLineFromChildDomNode(e);
    if (!t)
      return null;
    const i = Sy(t.characterMapping, e, 0);
    return new F(t.lineNumber, i);
  }
  getLineNumberFromChildDomNode(e) {
    var t, i;
    return (i = (t = this._getRenderedStickyLineFromChildDomNode(e)) === null || t === void 0 ? void 0 : t.lineNumber) !== null && i !== void 0 ? i : null;
  }
  _getRenderedStickyLineFromChildDomNode(e) {
    const t = this.getLineIndexFromChildDomNode(e);
    return t === null || t < 0 || t >= this._renderedStickyLines.length ? null : this._renderedStickyLines[t];
  }
  /**
   * Given a child dom node, tries to find the line number attribute that was stored in the node.
   * @returns the attribute value or null if none is found.
   */
  getLineIndexFromChildDomNode(e) {
    const t = this._getAttributeValue(e, qc);
    return t ? parseInt(t, 10) : null;
  }
  /**
   * Given a child dom node, tries to find if it is (contained in) a sticky line.
   * @returns a boolean.
   */
  isInStickyLine(e) {
    return this._getAttributeValue(e, bm) !== void 0;
  }
  /**
   * Given a child dom node, tries to find if this dom node is (contained in) a sticky folding icon.
   * @returns a boolean.
   */
  isInFoldingIconDomNode(e) {
    return this._getAttributeValue(e, Cm) !== void 0;
  }
  /**
   * Given the dom node, finds if it or its parent sequence contains the given attribute.
   * @returns the attribute value or undefined.
   */
  _getAttributeValue(e, t) {
    for (; e && e !== this._rootDomNode; ) {
      const i = e.getAttribute(t);
      if (i !== null)
        return i;
      e = e.parentElement;
    }
  }
}
class nM {
  constructor(e, t, i, n, s, o, a) {
    this.index = e, this.lineNumber = t, this.lineDomNode = i, this.lineNumberDomNode = n, this.foldingIcon = s, this.characterMapping = o, this.scrollWidth = a;
  }
}
class sM {
  constructor(e, t, i, n) {
    this.isCollapsed = e, this.foldingStartLine = t, this.foldingEndLine = i, this.dimension = n, this.domNode = document.createElement("div"), this.domNode.style.width = `${n}px`, this.domNode.style.height = `${n}px`, this.domNode.className = oe.asClassName(e ? Hd : Wd);
  }
  setVisible(e) {
    this.domNode.style.cursor = e ? "pointer" : "default", this.domNode.style.opacity = e ? "1" : "0";
  }
}
class lr {
  constructor(e, t) {
    this.startLineNumber = e, this.endLineNumber = t;
  }
}
class Xl {
  constructor(e, t, i) {
    this.range = e, this.children = t, this.parent = i;
  }
}
class LC {
  constructor(e, t, i, n) {
    this.uri = e, this.version = t, this.element = i, this.outlineProviderId = n;
  }
}
var oc = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, zr = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, dr;
(function(r) {
  r.OUTLINE_MODEL = "outlineModel", r.FOLDING_PROVIDER_MODEL = "foldingProviderModel", r.INDENTATION_MODEL = "indentationModel";
})(dr || (dr = {}));
var Zi;
(function(r) {
  r[r.VALID = 0] = "VALID", r[r.INVALID = 1] = "INVALID", r[r.CANCELED = 2] = "CANCELED";
})(Zi || (Zi = {}));
let Du = class extends P {
  constructor(e, t, i, n) {
    super(), this._editor = e, this._languageConfigurationService = t, this._languageFeaturesService = i, this._modelProviders = [], this._modelPromise = null, this._updateScheduler = this._register(new Vn(300)), this._updateOperation = this._register(new M());
    const s = new ku(i), o = new Ru(this._editor, i), a = new Nu(this._editor, t);
    switch (n) {
      case dr.OUTLINE_MODEL:
        this._modelProviders.push(s), this._modelProviders.push(o), this._modelProviders.push(a);
        break;
      case dr.FOLDING_PROVIDER_MODEL:
        this._modelProviders.push(o), this._modelProviders.push(a);
        break;
      case dr.INDENTATION_MODEL:
        this._modelProviders.push(a);
        break;
    }
  }
  _cancelModelPromise() {
    this._modelPromise && (this._modelPromise.cancel(), this._modelPromise = null);
  }
  async update(e, t, i) {
    return this._updateOperation.clear(), this._updateOperation.add({
      dispose: () => {
        this._cancelModelPromise(), this._updateScheduler.cancel();
      }
    }), this._cancelModelPromise(), await this._updateScheduler.trigger(async () => {
      for (const n of this._modelProviders) {
        const { statusPromise: s, modelPromise: o } = n.computeStickyModel(e, t, i);
        this._modelPromise = o;
        const a = await s;
        if (this._modelPromise !== o)
          return null;
        switch (a) {
          case Zi.CANCELED:
            return this._updateOperation.clear(), null;
          case Zi.VALID:
            return n.stickyModel;
        }
      }
      return null;
    }).catch((n) => (re(n), null));
  }
};
Du = oc([
  zr(1, fe),
  zr(2, V)
], Du);
class IC {
  constructor() {
    this._stickyModel = null;
  }
  get stickyModel() {
    return this._stickyModel;
  }
  _invalid() {
    return this._stickyModel = null, Zi.INVALID;
  }
  computeStickyModel(e, t, i) {
    if (i.isCancellationRequested || !this.isProviderValid(e))
      return { statusPromise: this._invalid(), modelPromise: null };
    const n = Pe((s) => this.createModelFromProvider(e, t, s));
    return {
      statusPromise: n.then((s) => this.isModelValid(s) ? i.isCancellationRequested ? Zi.CANCELED : (this._stickyModel = this.createStickyModel(e, t, i, s), Zi.VALID) : this._invalid()).then(void 0, (s) => (re(s), Zi.CANCELED)),
      modelPromise: n
    };
  }
  /**
   * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.
   * This method by default returns true.
   * @param model model returned by the provider
   * @returns boolean indicating whether the model is valid
   */
  isModelValid(e) {
    return !0;
  }
  /**
   * Method which checks whether the provider is valid before applying it to find the provider model.
   * This method by default returns true.
   * @param textModel text-model of the editor
   * @returns boolean indicating whether the provider is valid
   */
  isProviderValid(e) {
    return !0;
  }
}
let ku = class extends IC {
  constructor(e) {
    super(), this._languageFeaturesService = e;
  }
  createModelFromProvider(e, t, i) {
    return bi.create(this._languageFeaturesService.documentSymbolProvider, e, i);
  }
  createStickyModel(e, t, i, n) {
    var s;
    const { stickyOutlineElement: o, providerID: a } = this._stickyModelFromOutlineModel(n, (s = this._stickyModel) === null || s === void 0 ? void 0 : s.outlineProviderId);
    return new LC(e.uri, t, o, a);
  }
  isModelValid(e) {
    return e && e.children.size > 0;
  }
  _stickyModelFromOutlineModel(e, t) {
    let i;
    if (Si.first(e.children.values()) instanceof Kb) {
      const a = Si.find(e.children.values(), (l) => l.id === t);
      if (a)
        i = a.children;
      else {
        let l = "", d = -1, c;
        for (const [h, u] of e.children.entries()) {
          const p = this._findSumOfRangesOfGroup(u);
          p > d && (c = u, d = p, l = u.id);
        }
        t = l, i = c.children;
      }
    } else
      i = e.children;
    const n = [], s = Array.from(i.values()).sort((a, l) => {
      const d = new lr(a.symbol.range.startLineNumber, a.symbol.range.endLineNumber), c = new lr(l.symbol.range.startLineNumber, l.symbol.range.endLineNumber);
      return this._comparator(d, c);
    });
    for (const a of s)
      n.push(this._stickyModelFromOutlineElement(a, a.symbol.selectionRange.startLineNumber));
    return {
      stickyOutlineElement: new Xl(void 0, n, void 0),
      providerID: t
    };
  }
  _stickyModelFromOutlineElement(e, t) {
    const i = [];
    for (const s of e.children.values())
      if (s.symbol.selectionRange.startLineNumber !== s.symbol.range.endLineNumber)
        if (s.symbol.selectionRange.startLineNumber !== t)
          i.push(this._stickyModelFromOutlineElement(s, s.symbol.selectionRange.startLineNumber));
        else
          for (const o of s.children.values())
            i.push(this._stickyModelFromOutlineElement(o, s.symbol.selectionRange.startLineNumber));
    i.sort((s, o) => this._comparator(s.range, o.range));
    const n = new lr(e.symbol.selectionRange.startLineNumber, e.symbol.range.endLineNumber);
    return new Xl(n, i, void 0);
  }
  _comparator(e, t) {
    return e.startLineNumber !== t.startLineNumber ? e.startLineNumber - t.startLineNumber : t.endLineNumber - e.endLineNumber;
  }
  _findSumOfRangesOfGroup(e) {
    let t = 0;
    for (const i of e.children.values())
      t += this._findSumOfRangesOfGroup(i);
    return e instanceof Xh ? t + e.symbol.range.endLineNumber - e.symbol.selectionRange.startLineNumber : t;
  }
};
ku = oc([
  zr(0, V)
], ku);
class DC extends IC {
  constructor(e) {
    super(), this._foldingLimitReporter = new $b(e);
  }
  createStickyModel(e, t, i, n) {
    const s = this._fromFoldingRegions(n);
    return new LC(e.uri, t, s, void 0);
  }
  isModelValid(e) {
    return e !== null;
  }
  _fromFoldingRegions(e) {
    const t = e.length, i = [], n = new Xl(void 0, [], void 0);
    for (let s = 0; s < t; s++) {
      const o = e.getParentIndex(s);
      let a;
      o !== -1 ? a = i[o] : a = n;
      const l = new Xl(new lr(e.getStartLineNumber(s), e.getEndLineNumber(s) + 1), [], a);
      a.children.push(l), i.push(l);
    }
    return n;
  }
}
let Nu = class extends DC {
  constructor(e, t) {
    super(e), this._languageConfigurationService = t;
  }
  createModelFromProvider(e, t, i) {
    return new Xg(e, this._languageConfigurationService, this._foldingLimitReporter).compute(i);
  }
};
Nu = oc([
  zr(1, fe)
], Nu);
let Ru = class extends DC {
  constructor(e, t) {
    super(e), this._languageFeaturesService = t;
  }
  isProviderValid(e) {
    return li.getFoldingRangeProviders(this._languageFeaturesService, e).length > 0;
  }
  createModelFromProvider(e, t, i) {
    const n = li.getFoldingRangeProviders(this._languageFeaturesService, e);
    return new Yg(e, n, () => this.createModelFromProvider(e, t, i), this._foldingLimitReporter, void 0).compute(i);
  }
};
Ru = oc([
  zr(1, V)
], Ru);
var oM = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Sm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class rM {
  constructor(e, t, i) {
    this.startLineNumber = e, this.endLineNumber = t, this.nestingDepth = i;
  }
}
let Pu = class extends P {
  constructor(e, t, i) {
    super(), this._languageFeaturesService = t, this._languageConfigurationService = i, this._onDidChangeStickyScroll = this._register(new G()), this.onDidChangeStickyScroll = this._onDidChangeStickyScroll.event, this._options = null, this._model = null, this._cts = null, this._stickyModelProvider = null, this._editor = e, this._sessionStore = this._register(new M()), this._updateSoon = this._register(new Re(() => this.update(), 50)), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        115
        /* EditorOption.stickyScroll */
      ) && this.readConfiguration();
    })), this.readConfiguration();
  }
  readConfiguration() {
    this._stickyModelProvider = null, this._sessionStore.clear(), this._options = this._editor.getOption(
      115
      /* EditorOption.stickyScroll */
    ), this._options.enabled && (this._stickyModelProvider = this._sessionStore.add(new Du(this._editor, this._languageConfigurationService, this._languageFeaturesService, this._options.defaultModel)), this._sessionStore.add(this._editor.onDidChangeModel(() => {
      this._model = null, this._onDidChangeStickyScroll.fire(), this.update();
    })), this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this.update())), this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule())), this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => this.update())), this.update());
  }
  getVersionId() {
    var e;
    return (e = this._model) === null || e === void 0 ? void 0 : e.version;
  }
  async update() {
    var e;
    (e = this._cts) === null || e === void 0 || e.dispose(!0), this._cts = new Oe(), await this.updateStickyModel(this._cts.token), this._onDidChangeStickyScroll.fire();
  }
  async updateStickyModel(e) {
    if (!this._editor.hasModel() || !this._stickyModelProvider || this._editor.getModel().isTooLargeForTokenization()) {
      this._model = null;
      return;
    }
    const t = this._editor.getModel(), i = t.getVersionId(), n = await this._stickyModelProvider.update(t, i, e);
    e.isCancellationRequested || (this._model = n);
  }
  updateIndex(e) {
    return e === -1 ? e = 0 : e < 0 && (e = -e - 2), e;
  }
  getCandidateStickyLinesIntersectingFromStickyModel(e, t, i, n, s) {
    if (t.children.length === 0)
      return;
    let o = s;
    const a = [];
    for (let c = 0; c < t.children.length; c++) {
      const h = t.children[c];
      h.range && a.push(h.range.startLineNumber);
    }
    const l = this.updateIndex(Sl(a, e.startLineNumber, (c, h) => c - h)), d = this.updateIndex(Sl(a, e.startLineNumber + n, (c, h) => c - h));
    for (let c = l; c <= d; c++) {
      const h = t.children[c];
      if (!h)
        return;
      if (h.range) {
        const u = h.range.startLineNumber, p = h.range.endLineNumber;
        e.startLineNumber <= p + 1 && u - 1 <= e.endLineNumber && u !== o && (o = u, i.push(new rM(u, p - 1, n + 1)), this.getCandidateStickyLinesIntersectingFromStickyModel(e, h, i, n + 1, u));
      } else
        this.getCandidateStickyLinesIntersectingFromStickyModel(e, h, i, n, s);
    }
  }
  getCandidateStickyLinesIntersecting(e) {
    var t, i;
    if (!(!((t = this._model) === null || t === void 0) && t.element))
      return [];
    let n = [];
    this.getCandidateStickyLinesIntersectingFromStickyModel(e, this._model.element, n, 0, -1);
    const s = (i = this._editor._getViewModel()) === null || i === void 0 ? void 0 : i.getHiddenAreas();
    if (s)
      for (const o of s)
        n = n.filter((a) => !(a.startLineNumber >= o.startLineNumber && a.endLineNumber <= o.endLineNumber + 1));
    return n;
  }
};
Pu = oM([
  Sm(1, V),
  Sm(2, fe)
], Pu);
var aM = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, vs = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Mu;
let di = Mu = class extends P {
  constructor(e, t, i, n, s, o, a) {
    super(), this._editor = e, this._contextMenuService = t, this._languageFeaturesService = i, this._instaService = n, this._contextKeyService = a, this._sessionStore = new M(), this._foldingModel = null, this._maxStickyLines = Number.MAX_SAFE_INTEGER, this._candidateDefinitionsLength = -1, this._focusedStickyElementIndex = -1, this._enabled = !1, this._focused = !1, this._positionRevealed = !1, this._onMouseDown = !1, this._endLineNumbers = [], this._showEndForLine = null, this._stickyScrollWidget = new iM(this._editor), this._stickyLineCandidateProvider = new Pu(this._editor, i, s), this._register(this._stickyScrollWidget), this._register(this._stickyLineCandidateProvider), this._widgetState = new _m([], [], 0), this._onDidResize(), this._readConfiguration();
    const l = this._stickyScrollWidget.getDomNode();
    this._register(this._editor.onDidChangeConfiguration((c) => {
      (c.hasChanged(
        115
        /* EditorOption.stickyScroll */
      ) || c.hasChanged(
        73
        /* EditorOption.minimap */
      ) || c.hasChanged(
        67
        /* EditorOption.lineHeight */
      ) || c.hasChanged(
        110
        /* EditorOption.showFoldingControls */
      )) && this._readConfiguration();
    })), this._register(le(l, Le.CONTEXT_MENU, async (c) => {
      this._onContextMenu(En(l), c);
    })), this._stickyScrollFocusedContextKey = b.stickyScrollFocused.bindTo(this._contextKeyService), this._stickyScrollVisibleContextKey = b.stickyScrollVisible.bindTo(this._contextKeyService);
    const d = this._register(Us(l));
    this._register(d.onDidBlur((c) => {
      this._positionRevealed === !1 && l.clientHeight === 0 ? (this._focusedStickyElementIndex = -1, this.focus()) : this._disposeFocusStickyScrollStore();
    })), this._register(d.onDidFocus((c) => {
      this.focus();
    })), this._registerMouseListeners(), this._register(le(l, Le.MOUSE_DOWN, (c) => {
      this._onMouseDown = !0;
    }));
  }
  static get(e) {
    return e.getContribution(Mu.ID);
  }
  _disposeFocusStickyScrollStore() {
    var e;
    this._stickyScrollFocusedContextKey.set(!1), (e = this._focusDisposableStore) === null || e === void 0 || e.dispose(), this._focused = !1, this._positionRevealed = !1, this._onMouseDown = !1;
  }
  focus() {
    if (this._onMouseDown) {
      this._onMouseDown = !1, this._editor.focus();
      return;
    }
    this._stickyScrollFocusedContextKey.get() !== !0 && (this._focused = !0, this._focusDisposableStore = new M(), this._stickyScrollFocusedContextKey.set(!0), this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumbers.length - 1, this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex));
  }
  focusNext() {
    this._focusedStickyElementIndex < this._stickyScrollWidget.lineNumberCount - 1 && this._focusNav(!0);
  }
  focusPrevious() {
    this._focusedStickyElementIndex > 0 && this._focusNav(!1);
  }
  selectEditor() {
    this._editor.focus();
  }
  // True is next, false is previous
  _focusNav(e) {
    this._focusedStickyElementIndex = e ? this._focusedStickyElementIndex + 1 : this._focusedStickyElementIndex - 1, this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
  }
  goToFocused() {
    const e = this._stickyScrollWidget.lineNumbers;
    this._disposeFocusStickyScrollStore(), this._revealPosition({ lineNumber: e[this._focusedStickyElementIndex], column: 1 });
  }
  _revealPosition(e) {
    this._reveaInEditor(e, () => this._editor.revealPosition(e));
  }
  _revealLineInCenterIfOutsideViewport(e) {
    this._reveaInEditor(e, () => this._editor.revealLineInCenterIfOutsideViewport(
      e.lineNumber,
      0
      /* ScrollType.Smooth */
    ));
  }
  _reveaInEditor(e, t) {
    this._focused && this._disposeFocusStickyScrollStore(), this._positionRevealed = !0, t(), this._editor.setSelection(S.fromPositions(e)), this._editor.focus();
  }
  _registerMouseListeners() {
    const e = this._register(new M()), t = this._register(new Ld(this._editor, {
      extractLineNumberFromMouseEvent: (s) => {
        const o = this._stickyScrollWidget.getEditorPositionFromNode(s.target.element);
        return o ? o.lineNumber : 0;
      }
    })), i = (s) => {
      if (!this._editor.hasModel() || s.target.type !== 12 || s.target.detail !== this._stickyScrollWidget.getId())
        return null;
      const o = s.target.element;
      if (!o || o.innerText !== o.innerHTML)
        return null;
      const a = this._stickyScrollWidget.getEditorPositionFromNode(o);
      return a ? {
        range: new S(a.lineNumber, a.column, a.lineNumber, a.column + o.innerText.length),
        textElement: o
      } : null;
    }, n = this._stickyScrollWidget.getDomNode();
    this._register(Bn(n, Le.CLICK, (s) => {
      if (s.ctrlKey || s.altKey || s.metaKey || !s.leftButton)
        return;
      if (s.shiftKey) {
        const d = this._stickyScrollWidget.getLineIndexFromChildDomNode(s.target);
        if (d === null)
          return;
        const c = new F(this._endLineNumbers[d], 1);
        this._revealLineInCenterIfOutsideViewport(c);
        return;
      }
      if (this._stickyScrollWidget.isInFoldingIconDomNode(s.target)) {
        const d = this._stickyScrollWidget.getLineNumberFromChildDomNode(s.target);
        this._toggleFoldingRegionForLine(d);
        return;
      }
      if (!this._stickyScrollWidget.isInStickyLine(s.target))
        return;
      let l = this._stickyScrollWidget.getEditorPositionFromNode(s.target);
      if (!l) {
        const d = this._stickyScrollWidget.getLineNumberFromChildDomNode(s.target);
        if (d === null)
          return;
        l = new F(d, 1);
      }
      this._revealPosition(l);
    })), this._register(Bn(n, Le.MOUSE_MOVE, (s) => {
      if (s.shiftKey) {
        const o = this._stickyScrollWidget.getLineIndexFromChildDomNode(s.target);
        if (o === null || this._showEndForLine !== null && this._showEndForLine === o)
          return;
        this._showEndForLine = o, this._renderStickyScroll();
        return;
      }
      this._showEndForLine !== null && (this._showEndForLine = null, this._renderStickyScroll());
    })), this._register(le(n, Le.MOUSE_LEAVE, (s) => {
      this._showEndForLine !== null && (this._showEndForLine = null, this._renderStickyScroll());
    })), this._register(t.onMouseMoveOrRelevantKeyDown(([s, o]) => {
      const a = i(s);
      if (!a || !s.hasTriggerModifier || !this._editor.hasModel()) {
        e.clear();
        return;
      }
      const { range: l, textElement: d } = a;
      if (!l.equalsRange(this._stickyRangeProjectedOnEditor))
        this._stickyRangeProjectedOnEditor = l, e.clear();
      else if (d.style.textDecoration === "underline")
        return;
      const c = new Oe();
      e.add(pe(() => c.dispose(!0)));
      let h;
      Pd(this._languageFeaturesService.definitionProvider, this._editor.getModel(), new F(l.startLineNumber, l.startColumn + 1), c.token).then((u) => {
        if (!c.token.isCancellationRequested)
          if (u.length !== 0) {
            this._candidateDefinitionsLength = u.length;
            const p = d;
            h !== p ? (e.clear(), h = p, h.style.textDecoration = "underline", e.add(pe(() => {
              h.style.textDecoration = "none";
            }))) : h || (h = p, h.style.textDecoration = "underline", e.add(pe(() => {
              h.style.textDecoration = "none";
            })));
          } else
            e.clear();
      });
    })), this._register(t.onCancel(() => {
      e.clear();
    })), this._register(t.onExecute(async (s) => {
      if (s.target.type !== 12 || s.target.detail !== this._stickyScrollWidget.getId())
        return;
      const o = this._stickyScrollWidget.getEditorPositionFromNode(s.target.element);
      o && (!this._editor.hasModel() || !this._stickyRangeProjectedOnEditor || (this._candidateDefinitionsLength > 1 && (this._focused && this._disposeFocusStickyScrollStore(), this._revealPosition({ lineNumber: o.lineNumber, column: 1 })), this._instaService.invokeFunction(sC, s, this._editor, { uri: this._editor.getModel().uri, range: this._stickyRangeProjectedOnEditor })));
    }));
  }
  _onContextMenu(e, t) {
    const i = new wy(e, t);
    this._contextMenuService.showContextMenu({
      menuId: E.StickyScrollContext,
      getAnchor: () => i
    });
  }
  _toggleFoldingRegionForLine(e) {
    if (!this._foldingModel || e === null)
      return;
    const t = this._stickyScrollWidget.getRenderedStickyLine(e), i = t == null ? void 0 : t.foldingIcon;
    if (!i)
      return;
    Hb(this._foldingModel, Number.MAX_VALUE, [e]), i.isCollapsed = !i.isCollapsed;
    const n = (i.isCollapsed ? this._editor.getTopForLineNumber(i.foldingEndLine) : this._editor.getTopForLineNumber(i.foldingStartLine)) - this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ) * t.index + 1;
    this._editor.setScrollTop(n), this._renderStickyScroll(e);
  }
  _readConfiguration() {
    const e = this._editor.getOption(
      115
      /* EditorOption.stickyScroll */
    );
    if (e.enabled === !1) {
      this._editor.removeOverlayWidget(this._stickyScrollWidget), this._sessionStore.clear(), this._enabled = !1;
      return;
    } else
      e.enabled && !this._enabled && (this._editor.addOverlayWidget(this._stickyScrollWidget), this._sessionStore.add(this._editor.onDidScrollChange((i) => {
        i.scrollTopChanged && (this._showEndForLine = null, this._renderStickyScroll());
      })), this._sessionStore.add(this._editor.onDidLayoutChange(() => this._onDidResize())), this._sessionStore.add(this._editor.onDidChangeModelTokens((i) => this._onTokensChange(i))), this._sessionStore.add(this._stickyLineCandidateProvider.onDidChangeStickyScroll(() => {
        this._showEndForLine = null, this._renderStickyScroll();
      })), this._enabled = !0);
    this._editor.getOption(
      68
      /* EditorOption.lineNumbers */
    ).renderType === 2 && this._sessionStore.add(this._editor.onDidChangeCursorPosition(() => {
      this._showEndForLine = null, this._renderStickyScroll(0);
    }));
  }
  _needsUpdate(e) {
    const t = this._stickyScrollWidget.getCurrentLines();
    for (const i of t)
      for (const n of e.ranges)
        if (i >= n.fromLineNumber && i <= n.toLineNumber)
          return !0;
    return !1;
  }
  _onTokensChange(e) {
    this._needsUpdate(e) && this._renderStickyScroll(0);
  }
  _onDidResize() {
    const t = this._editor.getLayoutInfo().height / this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    this._maxStickyLines = Math.round(t * 0.25);
  }
  async _renderStickyScroll(e) {
    var t, i;
    const n = this._editor.getModel();
    if (!n || n.isTooLargeForTokenization()) {
      this._foldingModel = null, this._stickyScrollWidget.setState(void 0, null);
      return;
    }
    const s = this._stickyLineCandidateProvider.getVersionId();
    if (s === void 0 || s === n.getVersionId())
      if (this._foldingModel = (i = await ((t = li.get(this._editor)) === null || t === void 0 ? void 0 : t.getFoldingModel())) !== null && i !== void 0 ? i : null, this._widgetState = this.findScrollWidgetState(), this._stickyScrollVisibleContextKey.set(this._widgetState.startLineNumbers.length !== 0), !this._focused)
        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, e);
      else if (this._focusedStickyElementIndex === -1)
        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, e), this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1, this._focusedStickyElementIndex !== -1 && this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
      else {
        const o = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];
        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, e), this._stickyScrollWidget.lineNumberCount === 0 ? this._focusedStickyElementIndex = -1 : (this._stickyScrollWidget.lineNumbers.includes(o) || (this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1), this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex));
      }
  }
  findScrollWidgetState() {
    const e = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), t = Math.min(this._maxStickyLines, this._editor.getOption(
      115
      /* EditorOption.stickyScroll */
    ).maxLineCount), i = this._editor.getScrollTop();
    let n = 0;
    const s = [], o = [], a = this._editor.getVisibleRanges();
    if (a.length !== 0) {
      const l = new lr(a[0].startLineNumber, a[a.length - 1].endLineNumber), d = this._stickyLineCandidateProvider.getCandidateStickyLinesIntersecting(l);
      for (const c of d) {
        const h = c.startLineNumber, u = c.endLineNumber, p = c.nestingDepth;
        if (u - h > 0) {
          const f = (p - 1) * e, m = p * e, _ = this._editor.getBottomForLineNumber(h) - i, v = this._editor.getTopForLineNumber(u) - i, C = this._editor.getBottomForLineNumber(u) - i;
          if (f > v && f <= C) {
            s.push(h), o.push(u + 1), n = C - m;
            break;
          } else
            m > _ && m <= C && (s.push(h), o.push(u + 1));
          if (s.length === t)
            break;
        }
      }
    }
    return this._endLineNumbers = o, new _m(s, o, n, this._showEndForLine);
  }
  dispose() {
    super.dispose(), this._sessionStore.dispose();
  }
};
di.ID = "store.contrib.stickyScrollController";
di = Mu = aM([
  vs(1, co),
  vs(2, V),
  vs(3, q),
  vs(4, fe),
  vs(5, Pt),
  vs(6, ee)
], di);
class lM extends rt {
  constructor() {
    super({
      id: "editor.action.toggleStickyScroll",
      title: {
        ...$("toggleEditorStickyScroll", "Toggle Editor Sticky Scroll"),
        mnemonicTitle: g({ key: "mitoggleStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Toggle Editor Sticky Scroll")
      },
      category: eM.View,
      toggled: {
        condition: L.equals("config.editor.stickyScroll.enabled", !0),
        title: g("stickyScroll", "Sticky Scroll"),
        mnemonicTitle: g({ key: "miStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Sticky Scroll")
      },
      menu: [
        { id: E.CommandPalette },
        { id: E.MenubarAppearanceMenu, group: "4_editor", order: 3 },
        { id: E.StickyScrollContext }
      ]
    });
  }
  async run(e) {
    const t = e.get(he), i = !t.getValue("editor.stickyScroll.enabled");
    return t.updateValue("editor.stickyScroll.enabled", i);
  }
}
const rc = 100;
class dM extends Kt {
  constructor() {
    super({
      id: "editor.action.focusStickyScroll",
      title: {
        ...$("focusStickyScroll", "Focus Sticky Scroll"),
        mnemonicTitle: g({ key: "mifocusStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Focus Sticky Scroll")
      },
      precondition: L.and(L.has("config.editor.stickyScroll.enabled"), b.stickyScrollVisible),
      menu: [
        { id: E.CommandPalette }
      ]
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = di.get(t)) === null || i === void 0 || i.focus();
  }
}
class cM extends Kt {
  constructor() {
    super({
      id: "editor.action.selectNextStickyScrollLine",
      title: $("selectNextStickyScrollLine.title", "Select next sticky scroll line"),
      precondition: b.stickyScrollFocused.isEqualTo(!0),
      keybinding: {
        weight: rc,
        primary: 18
        /* KeyCode.DownArrow */
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = di.get(t)) === null || i === void 0 || i.focusNext();
  }
}
class hM extends Kt {
  constructor() {
    super({
      id: "editor.action.selectPreviousStickyScrollLine",
      title: $("selectPreviousStickyScrollLine.title", "Select previous sticky scroll line"),
      precondition: b.stickyScrollFocused.isEqualTo(!0),
      keybinding: {
        weight: rc,
        primary: 16
        /* KeyCode.UpArrow */
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = di.get(t)) === null || i === void 0 || i.focusPrevious();
  }
}
class uM extends Kt {
  constructor() {
    super({
      id: "editor.action.goToFocusedStickyScrollLine",
      title: $("goToFocusedStickyScrollLine.title", "Go to focused sticky scroll line"),
      precondition: b.stickyScrollFocused.isEqualTo(!0),
      keybinding: {
        weight: rc,
        primary: 3
        /* KeyCode.Enter */
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = di.get(t)) === null || i === void 0 || i.goToFocused();
  }
}
class gM extends Kt {
  constructor() {
    super({
      id: "editor.action.selectEditor",
      title: $("selectEditor.title", "Select Editor"),
      precondition: b.stickyScrollFocused.isEqualTo(!0),
      keybinding: {
        weight: rc,
        primary: 9
        /* KeyCode.Escape */
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = di.get(t)) === null || i === void 0 || i.selectEditor();
  }
}
Z(
  di.ID,
  di,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
ne(lM);
ne(dM);
ne(hM);
ne(cM);
ne(uM);
ne(gM);
var kC = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Xo = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class pM {
  constructor(e, t, i, n, s, o) {
    this.range = e, this.insertText = t, this.filterText = i, this.additionalTextEdits = n, this.command = s, this.completion = o;
  }
}
let Eu = class extends yy {
  constructor(e, t, i, n, s, o) {
    super(s.disposable), this.model = e, this.line = t, this.word = i, this.completionModel = n, this._suggestMemoryService = o;
  }
  canBeReused(e, t, i) {
    return this.model === e && this.line === t && this.word.word.length > 0 && this.word.startColumn === i.startColumn && this.word.endColumn < i.endColumn && this.completionModel.getIncompleteProvider().size === 0;
  }
  get items() {
    var e;
    const t = [], { items: i } = this.completionModel, n = this._suggestMemoryService.select(this.model, { lineNumber: this.line, column: this.word.endColumn + this.completionModel.lineContext.characterCountDelta }, i), s = Si.slice(i, n), o = Si.slice(i, 0, n);
    let a = 5;
    for (const l of Si.concat(s, o)) {
      if (l.score === mr.Default)
        continue;
      const d = new S(
        l.editStart.lineNumber,
        l.editStart.column,
        l.editInsertEnd.lineNumber,
        l.editInsertEnd.column + this.completionModel.lineContext.characterCountDelta
        // end PLUS character delta
      ), c = l.completion.insertTextRules && l.completion.insertTextRules & 4 ? { snippet: l.completion.insertText } : l.completion.insertText;
      t.push(new pM(d, c, (e = l.filterTextLow) !== null && e !== void 0 ? e : l.labelLow, l.completion.additionalTextEdits, l.completion.command, l)), a-- >= 0 && l.resolve(X.None);
    }
    return t;
  }
};
Eu = kC([
  Xo(5, $d)
], Eu);
let Tu = class extends P {
  constructor(e, t, i, n) {
    super(), this._languageFeatureService = e, this._clipboardService = t, this._suggestMemoryService = i, this._editorService = n, this._store.add(e.inlineCompletionsProvider.register("*", this));
  }
  async provideInlineCompletions(e, t, i, n) {
    var s;
    if (i.selectedSuggestionInfo)
      return;
    let o;
    for (const f of this._editorService.listCodeEditors())
      if (f.getModel() === e) {
        o = f;
        break;
      }
    if (!o)
      return;
    const a = o.getOption(
      89
      /* EditorOption.quickSuggestions */
    );
    if (Es.isAllOff(a))
      return;
    e.tokenization.tokenizeIfCheap(t.lineNumber);
    const l = e.tokenization.getLineTokens(t.lineNumber), d = l.getStandardTokenType(l.findTokenIndexAtOffset(Math.max(t.column - 1 - 1, 0)));
    if (Es.valueFor(a, d) !== "inline")
      return;
    let c = e.getWordAtPosition(t), h;
    if (c != null && c.word || (h = this._getTriggerCharacterInfo(e, t)), !(c != null && c.word) && !h || (c || (c = e.getWordUntilPosition(t)), c.endColumn !== t.column))
      return;
    let u;
    const p = e.getValueInRange(new S(t.lineNumber, 1, t.lineNumber, t.column));
    if (!h && (!((s = this._lastResult) === null || s === void 0) && s.canBeReused(e, t.lineNumber, c))) {
      const f = new hm(p, t.column - this._lastResult.word.endColumn);
      this._lastResult.completionModel.lineContext = f, this._lastResult.acquire(), u = this._lastResult;
    } else {
      const f = await ep(this._languageFeatureService.completionProvider, e, t, new Mr(void 0, ql.createSuggestFilter(o).itemKind, h == null ? void 0 : h.providers), h && { triggerKind: 1, triggerCharacter: h.ch }, n);
      let m;
      f.needsClipboard && (m = await this._clipboardService.readText());
      const _ = new zi(f.items, t.column, new hm(p, 0), Bt.None, o.getOption(
        118
        /* EditorOption.suggest */
      ), o.getOption(
        112
        /* EditorOption.snippetSuggestions */
      ), { boostFullMatch: !1, firstMatchCanBeWeak: !1 }, m);
      u = new Eu(e, t.lineNumber, c, _, f, this._suggestMemoryService);
    }
    return this._lastResult = u, u;
  }
  handleItemDidShow(e, t) {
    t.completion.resolve(X.None);
  }
  freeInlineCompletions(e) {
    e.release();
  }
  _getTriggerCharacterInfo(e, t) {
    var i;
    const n = e.getValueInRange(S.fromPositions({ lineNumber: t.lineNumber, column: t.column - 1 }, t)), s = /* @__PURE__ */ new Set();
    for (const o of this._languageFeatureService.completionProvider.all(e))
      !((i = o.triggerCharacters) === null || i === void 0) && i.includes(n) && s.add(o);
    if (s.size !== 0)
      return { providers: s, ch: n };
  }
};
Tu = kC([
  Xo(0, V),
  Xo(1, ho),
  Xo(2, $d),
  Xo(3, _e)
], Tu);
Jr(Tu);
class fM extends D {
  constructor() {
    super({
      id: "editor.action.forceRetokenize",
      label: g("forceRetokenize", "Developer: Force Retokenize"),
      alias: "Developer: Force Retokenize",
      precondition: void 0
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel();
    i.tokenization.resetTokenization();
    const n = new Rt();
    i.tokenization.forceTokenization(i.getLineCount()), n.stop(), console.log(`tokenization took ${n.elapsed()}`);
  }
}
x(fM);
class ac extends rt {
  constructor() {
    super({
      id: ac.ID,
      title: $({ key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"] }, "Toggle Tab Key Moves Focus"),
      precondition: void 0,
      keybinding: {
        primary: 2091,
        mac: {
          primary: 1323
          /* KeyCode.KeyM */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: !0
    });
  }
  run() {
    const t = !Gp.getTabFocusMode();
    Gp.setTabFocusMode(t), t ? xt(g("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element")) : xt(g("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
  }
}
ac.ID = "editor.action.toggleTabFocusMode";
ne(ac);
var mM = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, _M = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Au = class extends P {
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e ? (this.el.setAttribute("aria-disabled", "false"), this.el.tabIndex = 0, this.el.style.pointerEvents = "auto", this.el.style.opacity = "1", this.el.style.cursor = "pointer", this._enabled = !1) : (this.el.setAttribute("aria-disabled", "true"), this.el.tabIndex = -1, this.el.style.pointerEvents = "none", this.el.style.opacity = "0.4", this.el.style.cursor = "default", this._enabled = !0), this._enabled = e;
  }
  constructor(e, t, i = {}, n) {
    var s;
    super(), this._link = t, this._enabled = !0, this.el = A(e, O("a.monaco-link", {
      tabIndex: (s = t.tabIndex) !== null && s !== void 0 ? s : 0,
      href: t.href,
      title: t.title
    }, t.label)), this.el.setAttribute("role", "button");
    const o = this._register(new Cc(this.el, "click")), a = this._register(new Cc(this.el, "keypress")), l = De.chain(a.event, (h) => h.map((u) => new xy(u)).filter(
      (u) => u.keyCode === 3
      /* KeyCode.Enter */
    )), d = this._register(new Cc(this.el, Ly.Tap)).event;
    this._register(Fm.addTarget(this.el));
    const c = De.any(o.event, l, d);
    this._register(c((h) => {
      this.enabled && (wl.stop(h, !0), i != null && i.opener ? i.opener(this._link.href) : n.open(this._link.href, { allowCommands: !0 }));
    })), this.enabled = !0;
  }
};
Au = mM([
  _M(3, Gt)
], Au);
var NC = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, RC = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const vM = 26;
let Ou = class extends P {
  constructor(e, t) {
    super(), this._editor = e, this.instantiationService = t, this.banner = this._register(this.instantiationService.createInstance(Fu));
  }
  hide() {
    this._editor.setBanner(null, 0), this.banner.clear();
  }
  show(e) {
    this.banner.show({
      ...e,
      onClose: () => {
        var t;
        this.hide(), (t = e.onClose) === null || t === void 0 || t.call(e);
      }
    }), this._editor.setBanner(this.banner.element, vM);
  }
};
Ou = NC([
  RC(1, q)
], Ou);
let Fu = class extends P {
  constructor(e) {
    super(), this.instantiationService = e, this.markdownRenderer = this.instantiationService.createInstance(po, {}), this.element = O("div.editor-banner"), this.element.tabIndex = 0;
  }
  getAriaLabel(e) {
    if (e.ariaLabel)
      return e.ariaLabel;
    if (typeof e.message == "string")
      return e.message;
  }
  getBannerMessage(e) {
    if (typeof e == "string") {
      const t = O("span");
      return t.innerText = e, t;
    }
    return this.markdownRenderer.render(e).element;
  }
  clear() {
    Qi(this.element);
  }
  show(e) {
    Qi(this.element);
    const t = this.getAriaLabel(e);
    t && this.element.setAttribute("aria-label", t);
    const i = A(this.element, O("div.icon-container"));
    i.setAttribute("aria-hidden", "true"), e.icon && i.appendChild(O(`div${oe.asCSSSelector(e.icon)}`));
    const n = A(this.element, O("div.message-container"));
    if (n.setAttribute("aria-hidden", "true"), n.appendChild(this.getBannerMessage(e.message)), this.messageActionsContainer = A(this.element, O("div.message-actions-container")), e.actions)
      for (const o of e.actions)
        this._register(this.instantiationService.createInstance(Au, this.messageActionsContainer, { ...o, tabIndex: -1 }, {}));
    const s = A(this.element, O("div.action-container"));
    this.actionBar = this._register(new ur(s)), this.actionBar.push(this._register(new qs("banner.close", "Close Banner", oe.asClassName(c_), !0, () => {
      typeof e.onClose == "function" && e.onClose();
    })), { icon: !0, label: !1 }), this.actionBar.setFocusable(!1);
  }
};
Fu = NC([
  RC(0, q)
], Fu);
var pp = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Hs = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const bM = Ae("extensions-warning-message", j.warning, g("warningIcon", "Icon shown with a warning message in the extensions editor."));
let ao = class extends P {
  constructor(e, t, i, n) {
    super(), this._editor = e, this._editorWorkerService = t, this._workspaceTrustService = i, this._highlighter = null, this._bannerClosed = !1, this._updateState = (s) => {
      if (s && s.hasMore) {
        if (this._bannerClosed)
          return;
        const o = Math.max(s.ambiguousCharacterCount, s.nonBasicAsciiCharacterCount, s.invisibleCharacterCount);
        let a;
        if (s.nonBasicAsciiCharacterCount >= o)
          a = {
            message: g("unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters", "This document contains many non-basic ASCII unicode characters"),
            command: new Do()
          };
        else if (s.ambiguousCharacterCount >= o)
          a = {
            message: g("unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters", "This document contains many ambiguous unicode characters"),
            command: new Sn()
          };
        else if (s.invisibleCharacterCount >= o)
          a = {
            message: g("unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters", "This document contains many invisible unicode characters"),
            command: new Io()
          };
        else
          throw new Error("Unreachable");
        this._bannerController.show({
          id: "unicodeHighlightBanner",
          message: a.message,
          icon: bM,
          actions: [
            {
              label: a.command.shortLabel,
              href: `command:${a.command.id}`
            }
          ],
          onClose: () => {
            this._bannerClosed = !0;
          }
        });
      } else
        this._bannerController.hide();
    }, this._bannerController = this._register(n.createInstance(Ou, e)), this._register(this._editor.onDidChangeModel(() => {
      this._bannerClosed = !1, this._updateHighlighter();
    })), this._options = e.getOption(
      125
      /* EditorOption.unicodeHighlighting */
    ), this._register(i.onDidChangeTrust((s) => {
      this._updateHighlighter();
    })), this._register(e.onDidChangeConfiguration((s) => {
      s.hasChanged(
        125
        /* EditorOption.unicodeHighlighting */
      ) && (this._options = e.getOption(
        125
        /* EditorOption.unicodeHighlighting */
      ), this._updateHighlighter());
    })), this._updateHighlighter();
  }
  dispose() {
    this._highlighter && (this._highlighter.dispose(), this._highlighter = null), super.dispose();
  }
  _updateHighlighter() {
    if (this._updateState(null), this._highlighter && (this._highlighter.dispose(), this._highlighter = null), !this._editor.hasModel())
      return;
    const e = CM(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
    if ([
      e.nonBasicASCII,
      e.ambiguousCharacters,
      e.invisibleCharacters
    ].every((i) => i === !1))
      return;
    const t = {
      nonBasicASCII: e.nonBasicASCII,
      ambiguousCharacters: e.ambiguousCharacters,
      invisibleCharacters: e.invisibleCharacters,
      includeComments: e.includeComments,
      includeStrings: e.includeStrings,
      allowedCodePoints: Object.keys(e.allowedCharacters).map((i) => i.codePointAt(0)),
      allowedLocales: Object.keys(e.allowedLocales).map((i) => i === "_os" ? new Intl.NumberFormat().resolvedOptions().locale : i === "_vscode" ? Dy : i)
    };
    this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri) ? this._highlighter = new Wu(this._editor, t, this._updateState, this._editorWorkerService) : this._highlighter = new SM(this._editor, t, this._updateState);
  }
  getDecorationInfo(e) {
    return this._highlighter ? this._highlighter.getDecorationInfo(e) : null;
  }
};
ao.ID = "editor.contrib.unicodeHighlighter";
ao = pp([
  Hs(1, sa),
  Hs(2, Iy),
  Hs(3, q)
], ao);
function CM(r, e) {
  return {
    nonBasicASCII: e.nonBasicASCII === Sc ? !r : e.nonBasicASCII,
    ambiguousCharacters: e.ambiguousCharacters,
    invisibleCharacters: e.invisibleCharacters,
    includeComments: e.includeComments === Sc ? !r : e.includeComments,
    includeStrings: e.includeStrings === Sc ? !r : e.includeStrings,
    allowedCharacters: e.allowedCharacters,
    allowedLocales: e.allowedLocales
  };
}
let Wu = class extends P {
  constructor(e, t, i, n) {
    super(), this._editor = e, this._options = t, this._updateState = i, this._editorWorkerService = n, this._model = this._editor.getModel(), this._decorations = this._editor.createDecorationsCollection(), this._updateSoon = this._register(new Re(() => this._update(), 250)), this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    })), this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear(), super.dispose();
  }
  _update() {
    if (this._model.isDisposed())
      return;
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const e = this._model.getVersionId();
    this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((t) => {
      if (this._model.isDisposed() || this._model.getVersionId() !== e)
        return;
      this._updateState(t);
      const i = [];
      if (!t.hasMore)
        for (const n of t.ranges)
          i.push({
            range: n,
            options: Ql.instance.getDecorationFromOptions(this._options)
          });
      this._decorations.set(i);
    });
  }
  getDecorationInfo(e) {
    if (!this._decorations.has(e))
      return null;
    const t = this._editor.getModel();
    if (!F_(t, e))
      return null;
    const i = t.getValueInRange(e.range);
    return {
      reason: MC(i, this._options),
      inComment: W_(t, e),
      inString: H_(t, e)
    };
  }
};
Wu = pp([
  Hs(3, sa)
], Wu);
class SM extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._options = t, this._updateState = i, this._model = this._editor.getModel(), this._decorations = this._editor.createDecorationsCollection(), this._updateSoon = this._register(new Re(() => this._update(), 250)), this._register(this._editor.onDidLayoutChange(() => {
      this._updateSoon.schedule();
    })), this._register(this._editor.onDidScrollChange(() => {
      this._updateSoon.schedule();
    })), this._register(this._editor.onDidChangeHiddenAreas(() => {
      this._updateSoon.schedule();
    })), this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    })), this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear(), super.dispose();
  }
  _update() {
    if (this._model.isDisposed())
      return;
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const e = this._editor.getVisibleRanges(), t = [], i = {
      ranges: [],
      ambiguousCharacterCount: 0,
      invisibleCharacterCount: 0,
      nonBasicAsciiCharacterCount: 0,
      hasMore: !1
    };
    for (const n of e) {
      const s = B_.computeUnicodeHighlights(this._model, this._options, n);
      for (const o of s.ranges)
        i.ranges.push(o);
      i.ambiguousCharacterCount += i.ambiguousCharacterCount, i.invisibleCharacterCount += i.invisibleCharacterCount, i.nonBasicAsciiCharacterCount += i.nonBasicAsciiCharacterCount, i.hasMore = i.hasMore || s.hasMore;
    }
    if (!i.hasMore)
      for (const n of i.ranges)
        t.push({ range: n, options: Ql.instance.getDecorationFromOptions(this._options) });
    this._updateState(i), this._decorations.set(t);
  }
  getDecorationInfo(e) {
    if (!this._decorations.has(e))
      return null;
    const t = this._editor.getModel(), i = t.getValueInRange(e.range);
    return F_(t, e) ? {
      reason: MC(i, this._options),
      inComment: W_(t, e),
      inString: H_(t, e)
    } : null;
  }
}
const PC = g("unicodeHighlight.configureUnicodeHighlightOptions", "Configure Unicode Highlight Options");
let Hu = class {
  constructor(e, t, i) {
    this._editor = e, this._languageService = t, this._openerService = i, this.hoverOrdinal = 5;
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1)
      return [];
    const i = this._editor.getModel(), n = this._editor.getContribution(ao.ID);
    if (!n)
      return [];
    const s = [], o = /* @__PURE__ */ new Set();
    let a = 300;
    for (const l of t) {
      const d = n.getDecorationInfo(l);
      if (!d)
        continue;
      const h = i.getValueInRange(l.range).codePointAt(0), u = Kc(h);
      let p;
      switch (d.reason.kind) {
        case 0: {
          x_(d.reason.confusableWith) ? p = g("unicodeHighlight.characterIsAmbiguousASCII", "The character {0} could be confused with the ASCII character {1}, which is more common in source code.", u, Kc(d.reason.confusableWith.codePointAt(0))) : p = g("unicodeHighlight.characterIsAmbiguous", "The character {0} could be confused with the character {1}, which is more common in source code.", u, Kc(d.reason.confusableWith.codePointAt(0)));
          break;
        }
        case 1:
          p = g("unicodeHighlight.characterIsInvisible", "The character {0} is invisible.", u);
          break;
        case 2:
          p = g("unicodeHighlight.characterIsNonBasicAscii", "The character {0} is not a basic ASCII character.", u);
          break;
      }
      if (o.has(p))
        continue;
      o.add(p);
      const f = {
        codePoint: h,
        reason: d.reason,
        inComment: d.inComment,
        inString: d.inString
      }, m = g("unicodeHighlight.adjustSettings", "Adjust settings"), _ = `command:${_a.ID}?${encodeURIComponent(JSON.stringify(f))}`, v = new Ue("", !0).appendMarkdown(p).appendText(" ").appendLink(_, m, PC);
      s.push(new Vt(this, l.range, [v], !1, a++));
    }
    return s;
  }
  renderHoverParts(e, t) {
    return fb(e, t, this._editor, this._languageService, this._openerService);
  }
};
Hu = pp([
  Hs(1, Et),
  Hs(2, Gt)
], Hu);
function Bu(r) {
  return `U+${r.toString(16).padStart(4, "0")}`;
}
function Kc(r) {
  let e = `\`${Bu(r)}\``;
  return V_.isInvisibleCharacter(r) || (e += ` "${`${wM(r)}`}"`), e;
}
function wM(r) {
  return r === 96 ? "`` ` ``" : "`" + String.fromCodePoint(r) + "`";
}
function MC(r, e) {
  return B_.computeUnicodeHighlightReason(r, e);
}
class Ql {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  getDecorationFromOptions(e) {
    return this.getDecoration(!e.includeComments, !e.includeStrings);
  }
  getDecoration(e, t) {
    const i = `${e}${t}`;
    let n = this.map.get(i);
    return n || (n = Y.createDynamic({
      description: "unicode-highlight",
      stickiness: 1,
      className: "unicode-highlight",
      showIfCollapsed: !0,
      overviewRuler: null,
      minimap: null,
      hideInCommentTokens: e,
      hideInStringTokens: t
    }), this.map.set(i, n)), n;
  }
}
Ql.instance = new Ql();
class yM extends D {
  constructor() {
    super({
      id: Sn.ID,
      label: g("action.unicodeHighlight.disableHighlightingInComments", "Disable highlighting of characters in comments"),
      alias: "Disable highlighting of characters in comments",
      precondition: void 0
    }), this.shortLabel = g("unicodeHighlight.disableHighlightingInComments.shortLabel", "Disable Highlight In Comments");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(he);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      ki.includeComments,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
class xM extends D {
  constructor() {
    super({
      id: Sn.ID,
      label: g("action.unicodeHighlight.disableHighlightingInStrings", "Disable highlighting of characters in strings"),
      alias: "Disable highlighting of characters in strings",
      precondition: void 0
    }), this.shortLabel = g("unicodeHighlight.disableHighlightingInStrings.shortLabel", "Disable Highlight In Strings");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(he);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      ki.includeStrings,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
class Sn extends D {
  constructor() {
    super({
      id: Sn.ID,
      label: g("action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters", "Disable highlighting of ambiguous characters"),
      alias: "Disable highlighting of ambiguous characters",
      precondition: void 0
    }), this.shortLabel = g("unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel", "Disable Ambiguous Highlight");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(he);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      ki.ambiguousCharacters,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
Sn.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
class Io extends D {
  constructor() {
    super({
      id: Io.ID,
      label: g("action.unicodeHighlight.disableHighlightingOfInvisibleCharacters", "Disable highlighting of invisible characters"),
      alias: "Disable highlighting of invisible characters",
      precondition: void 0
    }), this.shortLabel = g("unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel", "Disable Invisible Highlight");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(he);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      ki.invisibleCharacters,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
Io.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
class Do extends D {
  constructor() {
    super({
      id: Do.ID,
      label: g("action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters", "Disable highlighting of non basic ASCII characters"),
      alias: "Disable highlighting of non basic ASCII characters",
      precondition: void 0
    }), this.shortLabel = g("unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel", "Disable Non ASCII Highlight");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(he);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      ki.nonBasicASCII,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
Do.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
class _a extends D {
  constructor() {
    super({
      id: _a.ID,
      label: g("action.unicodeHighlight.showExcludeOptions", "Show Exclude Options"),
      alias: "Show Exclude Options",
      precondition: void 0
    });
  }
  async run(e, t, i) {
    const { codePoint: n, reason: s, inString: o, inComment: a } = i, l = String.fromCodePoint(n), d = e.get(Ei), c = e.get(he);
    function h(f) {
      return V_.isInvisibleCharacter(f) ? g("unicodeHighlight.excludeInvisibleCharFromBeingHighlighted", "Exclude {0} (invisible character) from being highlighted", Bu(f)) : g("unicodeHighlight.excludeCharFromBeingHighlighted", "Exclude {0} from being highlighted", `${Bu(f)} "${l}"`);
    }
    const u = [];
    if (s.kind === 0)
      for (const f of s.notAmbiguousInLocales)
        u.push({
          label: g("unicodeHighlight.allowCommonCharactersInLanguage", 'Allow unicode characters that are more common in the language "{0}".', f),
          run: async () => {
            IM(c, [f]);
          }
        });
    if (u.push({
      label: h(n),
      run: () => LM(c, [n])
    }), a) {
      const f = new yM();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    } else if (o) {
      const f = new xM();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    }
    if (s.kind === 0) {
      const f = new Sn();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    } else if (s.kind === 1) {
      const f = new Io();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    } else if (s.kind === 2) {
      const f = new Do();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    } else
      DM(s);
    const p = await d.pick(u, { title: PC });
    p && await p.run();
  }
}
_a.ID = "editor.action.unicodeHighlight.showExcludeOptions";
async function LM(r, e) {
  const t = r.getValue(ki.allowedCharacters);
  let i;
  typeof t == "object" && t ? i = t : i = {};
  for (const n of e)
    i[String.fromCodePoint(n)] = !0;
  await r.updateValue(
    ki.allowedCharacters,
    i,
    2
    /* ConfigurationTarget.USER */
  );
}
async function IM(r, e) {
  var t;
  const i = (t = r.inspect(ki.allowedLocales).user) === null || t === void 0 ? void 0 : t.value;
  let n;
  typeof i == "object" && i ? n = Object.assign({}, i) : n = {};
  for (const s of e)
    n[s] = !0;
  await r.updateValue(
    ki.allowedLocales,
    n,
    2
    /* ConfigurationTarget.USER */
  );
}
function DM(r) {
  throw new Error(`Unexpected value: ${r}`);
}
x(Sn);
x(Io);
x(Do);
x(_a);
Z(
  ao.ID,
  ao,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
bn.register(Hu);
var kM = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, wm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const EC = "ignoreUnusualLineTerminators";
function NM(r, e, t) {
  r.setModelProperty(e.uri, EC, t);
}
function RM(r, e) {
  return r.getModelProperty(e.uri, EC);
}
let $r = class extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._dialogService = t, this._codeEditorService = i, this._isPresentingDialog = !1, this._config = this._editor.getOption(
      126
      /* EditorOption.unusualLineTerminators */
    ), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        126
        /* EditorOption.unusualLineTerminators */
      ) && (this._config = this._editor.getOption(
        126
        /* EditorOption.unusualLineTerminators */
      ), this._checkForUnusualLineTerminators());
    })), this._register(this._editor.onDidChangeModel(() => {
      this._checkForUnusualLineTerminators();
    })), this._register(this._editor.onDidChangeModelContent((n) => {
      n.isUndoing || this._checkForUnusualLineTerminators();
    })), this._checkForUnusualLineTerminators();
  }
  async _checkForUnusualLineTerminators() {
    if (this._config === "off" || !this._editor.hasModel())
      return;
    const e = this._editor.getModel();
    if (!e.mightContainUnusualLineTerminators() || RM(this._codeEditorService, e) === !0 || this._editor.getOption(
      91
      /* EditorOption.readOnly */
    ))
      return;
    if (this._config === "auto") {
      e.removeUnusualLineTerminators(this._editor.getSelections());
      return;
    }
    if (this._isPresentingDialog)
      return;
    let i;
    try {
      this._isPresentingDialog = !0, i = await this._dialogService.confirm({
        title: g("unusualLineTerminators.title", "Unusual Line Terminators"),
        message: g("unusualLineTerminators.message", "Detected unusual line terminators"),
        detail: g("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", oi(e.uri)),
        primaryButton: g({ key: "unusualLineTerminators.fix", comment: ["&& denotes a mnemonic"] }, "&&Remove Unusual Line Terminators"),
        cancelButton: g("unusualLineTerminators.ignore", "Ignore")
      });
    } finally {
      this._isPresentingDialog = !1;
    }
    if (!i.confirmed) {
      NM(this._codeEditorService, e, !0);
      return;
    }
    e.removeUnusualLineTerminators(this._editor.getSelections());
  }
};
$r.ID = "editor.contrib.unusualLineTerminatorsDetector";
$r = kM([
  wm(1, yg),
  wm(2, _e)
], $r);
Z(
  $r.ID,
  $r,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
var TC = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, bl = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Ce, Vu;
const lc = new Q("hasWordHighlights", !1);
function AC(r, e, t, i) {
  const n = r.ordered(e);
  return Sg(n.map((s) => () => Promise.resolve(s.provideDocumentHighlights(e, t, i)).then(void 0, Ie)), nt).then((s) => {
    if (s) {
      const o = new ri();
      return o.set(e.uri, s), o;
    }
    return new ri();
  });
}
function PM(r, e, t, i, n, s) {
  const o = r.ordered(e);
  return Sg(o.map((a) => () => {
    const l = s.filter((d) => ky(d)).filter((d) => Ny(a.selector, d.uri, d.getLanguageId(), !0, void 0, void 0) > 0);
    return Promise.resolve(a.provideMultiDocumentHighlights(e, t, l, n)).then(void 0, Ie);
  }), (a) => a instanceof ri && a.size > 0);
}
class fp {
  constructor(e, t, i) {
    this._model = e, this._selection = t, this._wordSeparators = i, this._wordRange = this._getCurrentWordRange(e, t), this._result = null;
  }
  get result() {
    return this._result || (this._result = Pe((e) => this._compute(this._model, this._selection, this._wordSeparators, e))), this._result;
  }
  _getCurrentWordRange(e, t) {
    const i = e.getWordAtPosition(t.getPosition());
    return i ? new S(t.startLineNumber, i.startColumn, t.startLineNumber, i.endColumn) : null;
  }
  isValid(e, t, i) {
    const n = t.startLineNumber, s = t.startColumn, o = t.endColumn, a = this._getCurrentWordRange(e, t);
    let l = !!(this._wordRange && this._wordRange.equalsRange(a));
    for (let d = 0, c = i.length; !l && d < c; d++) {
      const h = i.getRange(d);
      h && h.startLineNumber === n && h.startColumn <= s && h.endColumn >= o && (l = !0);
    }
    return l;
  }
  cancel() {
    this.result.cancel();
  }
}
class MM extends fp {
  constructor(e, t, i, n) {
    super(e, t, i), this._providers = n;
  }
  _compute(e, t, i, n) {
    return AC(this._providers, e, t.getPosition(), n).then((s) => s || new ri());
  }
}
class EM extends fp {
  constructor(e, t, i, n, s) {
    super(e, t, i), this._providers = n, this._otherModels = s;
  }
  _compute(e, t, i, n) {
    return PM(this._providers, e, t.getPosition(), i, n, this._otherModels).then((s) => s || new ri());
  }
}
class OC extends fp {
  constructor(e, t, i, n, s) {
    super(e, t, n), this._otherModels = s, this._selectionIsEmpty = t.isEmpty(), this._word = i;
  }
  _compute(e, t, i, n) {
    return vg(250, n).then(() => {
      const s = new ri();
      let o;
      if (this._word ? o = this._word : o = e.getWordAtPosition(t.getPosition()), !o)
        return new ri();
      const a = [e, ...this._otherModels];
      for (const l of a) {
        if (l.isDisposed())
          continue;
        const c = l.findMatches(o.word, !0, !1, !0, i, !1).map((h) => ({
          range: h.range,
          kind: oh.Text
        }));
        c && s.set(l.uri, c);
      }
      return s;
    });
  }
  isValid(e, t, i) {
    const n = t.isEmpty();
    return this._selectionIsEmpty !== n ? !1 : super.isValid(e, t, i);
  }
}
function TM(r, e, t, i, n) {
  return r.has(e) ? new MM(e, t, n, r) : new OC(e, t, i, n, []);
}
function AM(r, e, t, i, n, s) {
  return r.has(e) ? new EM(e, t, n, r, s) : new OC(e, t, i, n, s);
}
pi("_executeDocumentHighlights", async (r, e, t) => {
  const i = r.get(V), n = await AC(i.documentHighlightProvider, e, t, X.None);
  return n == null ? void 0 : n.get(e.uri);
});
let jr = Ce = class {
  constructor(e, t, i, n, s) {
    this.toUnhook = new M(), this.workerRequestTokenId = 0, this.workerRequestCompleted = !1, this.workerRequestValue = new ri(), this.lastCursorPositionChangeTime = 0, this.renderDecorationsTimer = -1, this.editor = e, this.providers = t, this.multiDocumentProviders = i, this.codeEditorService = s, this._hasWordHighlights = lc.bindTo(n), this._ignorePositionChangeEvent = !1, this.occurrencesHighlight = this.editor.getOption(
      81
      /* EditorOption.occurrencesHighlight */
    ), this.model = this.editor.getModel(), this.toUnhook.add(e.onDidChangeCursorPosition((o) => {
      this._ignorePositionChangeEvent || this.occurrencesHighlight !== "off" && this._onPositionChanged(o);
    })), this.toUnhook.add(e.onDidFocusEditorText((o) => {
      this.occurrencesHighlight !== "off" && (this.workerRequest || this._run());
    })), this.toUnhook.add(e.onDidChangeModelContent((o) => {
      this._stopAll();
    })), this.toUnhook.add(e.onDidChangeModel((o) => {
      !o.newModelUrl && o.oldModelUrl ? this._stopSingular() : Ce.query && this._run();
    })), this.toUnhook.add(e.onDidChangeConfiguration((o) => {
      const a = this.editor.getOption(
        81
        /* EditorOption.occurrencesHighlight */
      );
      this.occurrencesHighlight !== a && (this.occurrencesHighlight = a, this._stopAll());
    })), this.decorations = this.editor.createDecorationsCollection(), this.workerRequestTokenId = 0, this.workerRequest = null, this.workerRequestCompleted = !1, this.lastCursorPositionChangeTime = 0, this.renderDecorationsTimer = -1, Ce.query && this._run();
  }
  hasDecorations() {
    return this.decorations.length > 0;
  }
  restore() {
    this.occurrencesHighlight !== "off" && this._run();
  }
  _getSortedHighlights() {
    return this.decorations.getRanges().sort(S.compareRangesUsingStarts);
  }
  moveNext() {
    const e = this._getSortedHighlights(), i = (e.findIndex((s) => s.containsPosition(this.editor.getPosition())) + 1) % e.length, n = e[i];
    try {
      this._ignorePositionChangeEvent = !0, this.editor.setPosition(n.getStartPosition()), this.editor.revealRangeInCenterIfOutsideViewport(n);
      const s = this._getWord();
      if (s) {
        const o = this.editor.getModel().getLineContent(n.startLineNumber);
        xt(`${o}, ${i + 1} of ${e.length} for '${s.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = !1;
    }
  }
  moveBack() {
    const e = this._getSortedHighlights(), i = (e.findIndex((s) => s.containsPosition(this.editor.getPosition())) - 1 + e.length) % e.length, n = e[i];
    try {
      this._ignorePositionChangeEvent = !0, this.editor.setPosition(n.getStartPosition()), this.editor.revealRangeInCenterIfOutsideViewport(n);
      const s = this._getWord();
      if (s) {
        const o = this.editor.getModel().getLineContent(n.startLineNumber);
        xt(`${o}, ${i + 1} of ${e.length} for '${s.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = !1;
    }
  }
  _removeSingleDecorations() {
    if (!this.editor.hasModel())
      return;
    const e = Ce.storedDecorations.get(this.editor.getModel().uri);
    e && (this.editor.removeDecorations(e), Ce.storedDecorations.delete(this.editor.getModel().uri), this.decorations.length > 0 && (this.decorations.clear(), this._hasWordHighlights.set(!1)));
  }
  _removeAllDecorations() {
    const e = this.codeEditorService.listCodeEditors(), t = [];
    for (const i of e) {
      if (!i.hasModel())
        continue;
      const n = Ce.storedDecorations.get(i.getModel().uri);
      if (!n)
        continue;
      i.removeDecorations(n), t.push(i.getModel().uri);
      const s = Mi.get(i);
      s != null && s.wordHighlighter && s.wordHighlighter.decorations.length > 0 && (s.wordHighlighter.decorations.clear(), s.wordHighlighter.workerRequest = null, s.wordHighlighter._hasWordHighlights.set(!1));
    }
    for (const i of t)
      Ce.storedDecorations.delete(i);
  }
  _stopSingular() {
    var e, t, i, n;
    this._removeSingleDecorations(), this.editor.hasTextFocus() && (((e = this.editor.getModel()) === null || e === void 0 ? void 0 : e.uri.scheme) !== wt.vscodeNotebookCell && ((i = (t = Ce.query) === null || t === void 0 ? void 0 : t.modelInfo) === null || i === void 0 ? void 0 : i.model.uri.scheme) !== wt.vscodeNotebookCell ? (Ce.query = null, this._run()) : !((n = Ce.query) === null || n === void 0) && n.modelInfo && (Ce.query.modelInfo = null)), this.renderDecorationsTimer !== -1 && (clearTimeout(this.renderDecorationsTimer), this.renderDecorationsTimer = -1), this.workerRequest !== null && (this.workerRequest.cancel(), this.workerRequest = null), this.workerRequestCompleted || (this.workerRequestTokenId++, this.workerRequestCompleted = !0);
  }
  _stopAll() {
    this._removeAllDecorations(), this.renderDecorationsTimer !== -1 && (clearTimeout(this.renderDecorationsTimer), this.renderDecorationsTimer = -1), this.workerRequest !== null && (this.workerRequest.cancel(), this.workerRequest = null), this.workerRequestCompleted || (this.workerRequestTokenId++, this.workerRequestCompleted = !0);
  }
  _onPositionChanged(e) {
    var t;
    if (this.occurrencesHighlight === "off") {
      this._stopAll();
      return;
    }
    if (e.reason !== 3 && ((t = this.editor.getModel()) === null || t === void 0 ? void 0 : t.uri.scheme) !== wt.vscodeNotebookCell) {
      this._stopAll();
      return;
    }
    this._run();
  }
  _getWord() {
    const e = this.editor.getSelection(), t = e.startLineNumber, i = e.startColumn;
    return this.model.isDisposed() ? null : this.model.getWordAtPosition({
      lineNumber: t,
      column: i
    });
  }
  getOtherModelsToHighlight(e) {
    if (!e)
      return [];
    if (e.uri.scheme === wt.vscodeNotebookCell) {
      const s = [], o = this.codeEditorService.listCodeEditors();
      for (const a of o) {
        const l = a.getModel();
        l && l !== e && l.uri.scheme === wt.vscodeNotebookCell && s.push(l);
      }
      return s;
    }
    const i = [], n = this.codeEditorService.listCodeEditors();
    for (const s of n) {
      if (!U_(s))
        continue;
      const o = s.getModel();
      o && e === o.modified && i.push(o.modified);
    }
    if (i.length)
      return i;
    if (this.occurrencesHighlight === "singleFile")
      return [];
    for (const s of n) {
      const o = s.getModel();
      o && o !== e && i.push(o);
    }
    return i;
  }
  _run() {
    var e;
    let t;
    if (this.editor.hasTextFocus()) {
      const n = this.editor.getSelection();
      if (!n || n.startLineNumber !== n.endLineNumber) {
        Ce.query = null, this._stopAll();
        return;
      }
      const s = n.startColumn, o = n.endColumn, a = this._getWord();
      if (!a || a.startColumn > s || a.endColumn < o) {
        Ce.query = null, this._stopAll();
        return;
      }
      t = this.workerRequest && this.workerRequest.isValid(this.model, n, this.decorations), Ce.query = {
        modelInfo: {
          model: this.model,
          selection: n
        },
        word: a
      };
    } else if (!Ce.query)
      return;
    if (this.lastCursorPositionChangeTime = (/* @__PURE__ */ new Date()).getTime(), t)
      this.workerRequestCompleted && this.renderDecorationsTimer !== -1 && (clearTimeout(this.renderDecorationsTimer), this.renderDecorationsTimer = -1, this._beginRenderDecorations());
    else {
      this._stopAll();
      const n = ++this.workerRequestTokenId;
      this.workerRequestCompleted = !1;
      const s = this.getOtherModelsToHighlight(this.editor.getModel());
      if (!Ce.query.modelInfo || Ce.query.modelInfo.model.isDisposed())
        return;
      this.workerRequest = this.computeWithModel(Ce.query.modelInfo.model, Ce.query.modelInfo.selection, Ce.query.word, s), (e = this.workerRequest) === null || e === void 0 || e.result.then((o) => {
        n === this.workerRequestTokenId && (this.workerRequestCompleted = !0, this.workerRequestValue = o || [], this._beginRenderDecorations());
      }, re);
    }
  }
  computeWithModel(e, t, i, n) {
    return n.length ? AM(this.multiDocumentProviders, e, t, i, this.editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ), n) : TM(this.providers, e, t, i, this.editor.getOption(
      130
      /* EditorOption.wordSeparators */
    ));
  }
  _beginRenderDecorations() {
    const e = (/* @__PURE__ */ new Date()).getTime(), t = this.lastCursorPositionChangeTime + 250;
    e >= t ? (this.renderDecorationsTimer = -1, this.renderDecorations()) : this.renderDecorationsTimer = setTimeout(() => {
      this.renderDecorations();
    }, t - e);
  }
  renderDecorations() {
    var e, t, i;
    this.renderDecorationsTimer = -1;
    const n = this.codeEditorService.listCodeEditors();
    for (const s of n) {
      const o = Mi.get(s);
      if (!o)
        continue;
      const a = [], l = (e = s.getModel()) === null || e === void 0 ? void 0 : e.uri;
      if (l && this.workerRequestValue.has(l)) {
        const d = Ce.storedDecorations.get(l), c = this.workerRequestValue.get(l);
        if (c)
          for (const u of c)
            u.range && a.push({
              range: u.range,
              options: KR(u.kind)
            });
        let h = [];
        s.changeDecorations((u) => {
          h = u.deltaDecorations(d ?? [], a);
        }), Ce.storedDecorations = Ce.storedDecorations.set(l, h), a.length > 0 && ((t = o.wordHighlighter) === null || t === void 0 || t.decorations.set(a), (i = o.wordHighlighter) === null || i === void 0 || i._hasWordHighlights.set(!0));
      }
    }
  }
  dispose() {
    this._stopSingular(), this.toUnhook.dispose();
  }
};
jr.storedDecorations = new ri();
jr.query = null;
jr = Ce = TC([
  bl(4, _e)
], jr);
let Mi = Vu = class extends P {
  static get(e) {
    return e.getContribution(Vu.ID);
  }
  constructor(e, t, i, n) {
    super(), this._wordHighlighter = null;
    const s = () => {
      e.hasModel() && !e.getModel().isTooLargeForTokenization() && (this._wordHighlighter = new jr(e, i.documentHighlightProvider, i.multiDocumentHighlightProvider, t, n));
    };
    this._register(e.onDidChangeModel((o) => {
      this._wordHighlighter && (this._wordHighlighter.dispose(), this._wordHighlighter = null), s();
    })), s();
  }
  get wordHighlighter() {
    return this._wordHighlighter;
  }
  saveViewState() {
    return !!(this._wordHighlighter && this._wordHighlighter.hasDecorations());
  }
  moveNext() {
    var e;
    (e = this._wordHighlighter) === null || e === void 0 || e.moveNext();
  }
  moveBack() {
    var e;
    (e = this._wordHighlighter) === null || e === void 0 || e.moveBack();
  }
  restoreViewState(e) {
    this._wordHighlighter && e && this._wordHighlighter.restore();
  }
  dispose() {
    this._wordHighlighter && (this._wordHighlighter.dispose(), this._wordHighlighter = null), super.dispose();
  }
};
Mi.ID = "editor.contrib.wordHighlighter";
Mi = Vu = TC([
  bl(1, ee),
  bl(2, V),
  bl(3, _e)
], Mi);
class FC extends D {
  constructor(e, t) {
    super(t), this._isNext = e;
  }
  run(e, t) {
    const i = Mi.get(t);
    i && (this._isNext ? i.moveNext() : i.moveBack());
  }
}
class OM extends FC {
  constructor() {
    super(!0, {
      id: "editor.action.wordHighlight.next",
      label: g("wordHighlight.next.label", "Go to Next Symbol Highlight"),
      alias: "Go to Next Symbol Highlight",
      precondition: lc,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class FM extends FC {
  constructor() {
    super(!1, {
      id: "editor.action.wordHighlight.prev",
      label: g("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
      alias: "Go to Previous Symbol Highlight",
      precondition: lc,
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 1089,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class WM extends D {
  constructor() {
    super({
      id: "editor.action.wordHighlight.trigger",
      label: g("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
      alias: "Trigger Symbol Highlight",
      precondition: lc.toNegated(),
      kbOpts: {
        kbExpr: b.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    const n = Mi.get(t);
    n && n.restoreViewState(!0);
  }
}
Z(
  Mi.ID,
  Mi,
  0
  /* EditorContributionInstantiation.Eager */
);
x(OM);
x(FM);
x(WM);
class dc extends bt {
  constructor(e) {
    super(e), this._inSelectionMode = e.inSelectionMode, this._wordNavigationType = e.wordNavigationType;
  }
  runEditorCommand(e, t, i) {
    if (!t.hasModel())
      return;
    const n = ss(t.getOption(
      130
      /* EditorOption.wordSeparators */
    )), s = t.getModel(), a = t.getSelections().map((l) => {
      const d = new F(l.positionLineNumber, l.positionColumn), c = this._move(n, s, d, this._wordNavigationType);
      return this._moveTo(l, c, this._inSelectionMode);
    });
    if (s.pushStackElement(), t._getViewModel().setCursorStates("moveWordCommand", 3, a.map((l) => Ry.fromModelSelection(l))), a.length === 1) {
      const l = new F(a[0].positionLineNumber, a[0].positionColumn);
      t.revealPosition(
        l,
        0
        /* ScrollType.Smooth */
      );
    }
  }
  _moveTo(e, t, i) {
    return i ? new z(e.selectionStartLineNumber, e.selectionStartColumn, t.lineNumber, t.column) : new z(t.lineNumber, t.column, t.lineNumber, t.column);
  }
}
class wn extends dc {
  _move(e, t, i, n) {
    return oa.moveWordLeft(e, t, i, n);
  }
}
class yn extends dc {
  _move(e, t, i, n) {
    return oa.moveWordRight(e, t, i, n);
  }
}
class HM extends wn {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
}
class BM extends wn {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
}
class VM extends wn {
  constructor() {
    var e;
    super({
      inSelectionMode: !1,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: L.and(b.textInputFocus, (e = L.and(hd, ud)) === null || e === void 0 ? void 0 : e.negate()),
        primary: 2063,
        mac: {
          primary: 527
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class UM extends wn {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
}
class zM extends wn {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
}
class $M extends wn {
  constructor() {
    var e;
    super({
      inSelectionMode: !0,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: L.and(b.textInputFocus, (e = L.and(hd, ud)) === null || e === void 0 ? void 0 : e.negate()),
        primary: 3087,
        mac: {
          primary: 1551
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class jM extends wn {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0
    });
  }
  _move(e, t, i, n) {
    return super._move(ss(gd.wordSeparators.defaultValue), t, i, n);
  }
}
class qM extends wn {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0
    });
  }
  _move(e, t, i, n) {
    return super._move(ss(gd.wordSeparators.defaultValue), t, i, n);
  }
}
class KM extends yn {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
}
class GM extends yn {
  constructor() {
    var e;
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: L.and(b.textInputFocus, (e = L.and(hd, ud)) === null || e === void 0 ? void 0 : e.negate()),
        primary: 2065,
        mac: {
          primary: 529
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class ZM extends yn {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
}
class XM extends yn {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
}
class QM extends yn {
  constructor() {
    var e;
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: L.and(b.textInputFocus, (e = L.and(hd, ud)) === null || e === void 0 ? void 0 : e.negate()),
        primary: 3089,
        mac: {
          primary: 1553
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class YM extends yn {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
}
class JM extends yn {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0
    });
  }
  _move(e, t, i, n) {
    return super._move(ss(gd.wordSeparators.defaultValue), t, i, n);
  }
}
class eE extends yn {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0
    });
  }
  _move(e, t, i, n) {
    return super._move(ss(gd.wordSeparators.defaultValue), t, i, n);
  }
}
class cc extends bt {
  constructor(e) {
    super(e), this._whitespaceHeuristics = e.whitespaceHeuristics, this._wordNavigationType = e.wordNavigationType;
  }
  runEditorCommand(e, t, i) {
    const n = e.get(fe);
    if (!t.hasModel())
      return;
    const s = ss(t.getOption(
      130
      /* EditorOption.wordSeparators */
    )), o = t.getModel(), a = t.getSelections(), l = t.getOption(
      6
      /* EditorOption.autoClosingBrackets */
    ), d = t.getOption(
      11
      /* EditorOption.autoClosingQuotes */
    ), c = n.getLanguageConfiguration(o.getLanguageId()).getAutoClosingPairs(), h = t._getViewModel(), u = a.map((p) => {
      const f = this._delete({
        wordSeparators: s,
        model: o,
        selection: p,
        whitespaceHeuristics: this._whitespaceHeuristics,
        autoClosingDelete: t.getOption(
          9
          /* EditorOption.autoClosingDelete */
        ),
        autoClosingBrackets: l,
        autoClosingQuotes: d,
        autoClosingPairs: c,
        autoClosedCharacters: h.getCursorAutoClosedCharacters()
      }, this._wordNavigationType);
      return new Gr(f, "");
    });
    t.pushUndoStop(), t.executeCommands(this.id, u), t.pushUndoStop();
  }
}
class mp extends cc {
  _delete(e, t) {
    const i = oa.deleteWordLeft(e, t);
    return i || new S(1, 1, 1, 1);
  }
}
class _p extends cc {
  _delete(e, t) {
    const i = oa.deleteWordRight(e, t);
    if (i)
      return i;
    const n = e.model.getLineCount(), s = e.model.getLineMaxColumn(n);
    return new S(n, s, n, s);
  }
}
class tE extends mp {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: b.writable
    });
  }
}
class iE extends mp {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: b.writable
    });
  }
}
class nE extends mp {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 2049,
        mac: {
          primary: 513
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class sE extends _p {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: b.writable
    });
  }
}
class oE extends _p {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: b.writable
    });
  }
}
class rE extends _p {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 2068,
        mac: {
          primary: 532
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class aE extends D {
  constructor() {
    super({
      id: "deleteInsideWord",
      precondition: b.writable,
      label: g("deleteInsideWord", "Delete Word"),
      alias: "Delete Word"
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = ss(t.getOption(
      130
      /* EditorOption.wordSeparators */
    )), s = t.getModel(), a = t.getSelections().map((l) => {
      const d = oa.deleteInsideWord(n, s, l);
      return new Gr(d, "");
    });
    t.pushUndoStop(), t.executeCommands(this.id, a), t.pushUndoStop();
  }
}
B(new HM());
B(new BM());
B(new VM());
B(new UM());
B(new zM());
B(new $M());
B(new KM());
B(new GM());
B(new ZM());
B(new XM());
B(new QM());
B(new YM());
B(new jM());
B(new qM());
B(new JM());
B(new eE());
B(new tE());
B(new iE());
B(new nE());
B(new sE());
B(new oE());
B(new rE());
x(aE);
class lE extends cc {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 0,
      id: "deleteWordPartLeft",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: {
          primary: 769
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(e, t) {
    const i = pd.deleteWordPartLeft(e);
    return i || new S(1, 1, 1, 1);
  }
}
class dE extends cc {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 2,
      id: "deleteWordPartRight",
      precondition: b.writable,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: {
          primary: 788
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(e, t) {
    const i = pd.deleteWordPartRight(e);
    if (i)
      return i;
    const n = e.model.getLineCount(), s = e.model.getLineMaxColumn(n);
    return new S(n, s, n, s);
  }
}
class WC extends dc {
  _move(e, t, i, n) {
    return pd.moveWordPartLeft(e, t, i);
  }
}
class cE extends WC {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 0,
      id: "cursorWordPartLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: {
          primary: 783
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
de.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
class hE extends WC {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 0,
      id: "cursorWordPartLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: {
          primary: 1807
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
de.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
class HC extends dc {
  _move(e, t, i, n) {
    return pd.moveWordPartRight(e, t, i);
  }
}
class uE extends HC {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordPartRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: {
          primary: 785
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class gE extends HC {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordPartRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.textInputFocus,
        primary: 0,
        mac: {
          primary: 1809
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
B(new lE());
B(new dE());
B(new cE());
B(new hE());
B(new uE());
B(new gE());
class Uu extends P {
  constructor(e) {
    super(), this.editor = e, this._register(this.editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit()));
  }
  _onDidAttemptReadOnlyEdit() {
    const e = qe.get(this.editor);
    if (e && this.editor.hasModel()) {
      let t = this.editor.getOptions().get(
        92
        /* EditorOption.readOnlyMessage */
      );
      t || (this.editor.isSimpleWidget ? t = new Ue(g("editor.simple.readonly", "Cannot edit in read-only input")) : t = new Ue(g("editor.readonly", "Cannot edit in read-only editor"))), e.showMessage(t, this.editor.getPosition());
    }
  }
}
Uu.ID = "editor.contrib.readOnlyMessageController";
Z(
  Uu.ID,
  Uu,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
var pE = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ym = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let zu = class extends P {
  constructor(e, t, i) {
    super(), this._textModel = e, this._languageFeaturesService = t, this._outlineModelService = i, this._currentModel = ai(this, void 0);
    const n = As("documentSymbolProvider.onDidChange", this._languageFeaturesService.documentSymbolProvider.onDidChange), s = As("_textModel.onDidChangeContent", De.debounce((o) => this._textModel.onDidChangeContent(o), () => {
    }, 100));
    this._register(ug(async (o, a) => {
      n.read(o), s.read(o);
      const l = a.add(new Ey()), d = await this._outlineModelService.getOrCreate(this._textModel, l.token);
      a.isDisposed || this._currentModel.set(d, void 0);
    }));
  }
  getBreadcrumbItems(e, t) {
    const i = this._currentModel.read(t);
    if (!i)
      return [];
    const n = i.asListOfDocumentSymbols().filter((s) => e.contains(s.range.startLineNumber) && !e.contains(s.range.endLineNumber));
    return n.sort(My(M_((s) => s.range.endLineNumber - s.range.startLineNumber, E_))), n.map((s) => ({ name: s.name, kind: s.kind, startLineNumber: s.range.startLineNumber }));
  }
};
zu = pE([
  ym(1, V),
  ym(2, fa)
], zu);
Py.setBreadcrumbsSourceFactory((r, e) => e.createInstance(zu, r));
class $u extends P {
  constructor(e) {
    super(), this.editor = e, this.widget = null, sh && (this._register(e.onDidChangeConfiguration(() => this.update())), this.update());
  }
  update() {
    const e = !this.editor.getOption(
      91
      /* EditorOption.readOnly */
    );
    !this.widget && e ? this.widget = new hc(this.editor) : this.widget && !e && (this.widget.dispose(), this.widget = null);
  }
  dispose() {
    super.dispose(), this.widget && (this.widget.dispose(), this.widget = null);
  }
}
$u.ID = "editor.contrib.iPadShowKeyboard";
class hc extends P {
  constructor(e) {
    super(), this.editor = e, this._domNode = document.createElement("textarea"), this._domNode.className = "iPadShowKeyboard", this._register(le(this._domNode, "touchstart", (t) => {
      this.editor.focus();
    })), this._register(le(this._domNode, "focus", (t) => {
      this.editor.focus();
    })), this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this), super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return hc.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 1
      /* OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER */
    };
  }
}
hc.ID = "editor.contrib.ShowKeyboardWidget";
Z(
  $u.ID,
  $u,
  3
  /* EditorContributionInstantiation.Eventually */
);
var fE = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, xm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, ju;
let lo = ju = class extends P {
  static get(e) {
    return e.getContribution(ju.ID);
  }
  constructor(e, t, i) {
    super(), this._editor = e, this._languageService = i, this._widget = null, this._register(this._editor.onDidChangeModel((n) => this.stop())), this._register(this._editor.onDidChangeModelLanguage((n) => this.stop())), this._register(ld.onDidChange((n) => this.stop())), this._register(this._editor.onKeyUp((n) => n.keyCode === 9 && this.stop()));
  }
  dispose() {
    this.stop(), super.dispose();
  }
  launch() {
    this._widget || this._editor.hasModel() && (this._widget = new uc(this._editor, this._languageService));
  }
  stop() {
    this._widget && (this._widget.dispose(), this._widget = null);
  }
};
lo.ID = "editor.contrib.inspectTokens";
lo = ju = fE([
  xm(1, z_),
  xm(2, Et)
], lo);
class mE extends D {
  constructor() {
    super({
      id: "editor.action.inspectTokens",
      label: Ty.inspectTokensAction,
      alias: "Developer: Inspect Tokens",
      precondition: void 0
    });
  }
  run(e, t) {
    const i = lo.get(t);
    i == null || i.launch();
  }
}
function _E(r) {
  let e = "";
  for (let t = 0, i = r.length; t < i; t++) {
    const n = r.charCodeAt(t);
    switch (n) {
      case 9:
        e += "";
        break;
      case 32:
        e += "";
        break;
      default:
        e += String.fromCharCode(n);
    }
  }
  return e;
}
function vE(r, e) {
  const t = ld.get(e);
  if (t)
    return t;
  const i = r.encodeLanguageId(e);
  return {
    getInitialState: () => Ay,
    tokenize: (n, s, o) => Oy(e, o),
    tokenizeEncoded: (n, s, o) => Fy(i, o)
  };
}
class uc extends P {
  constructor(e, t) {
    super(), this.allowEditorOverflow = !0, this._editor = e, this._languageService = t, this._model = this._editor.getModel(), this._domNode = document.createElement("div"), this._domNode.className = "tokens-inspect-widget", this._tokenizationSupport = vE(this._languageService.languageIdCodec, this._model.getLanguageId()), this._compute(this._editor.getPosition()), this._register(this._editor.onDidChangeCursorPosition((i) => this._compute(this._editor.getPosition()))), this._editor.addContentWidget(this);
  }
  dispose() {
    this._editor.removeContentWidget(this), super.dispose();
  }
  getId() {
    return uc._ID;
  }
  _compute(e) {
    const t = this._getTokensAtLine(e.lineNumber);
    let i = 0;
    for (let l = t.tokens1.length - 1; l >= 0; l--) {
      const d = t.tokens1[l];
      if (e.column - 1 >= d.offset) {
        i = l;
        break;
      }
    }
    let n = 0;
    for (let l = t.tokens2.length >>> 1; l >= 0; l--)
      if (e.column - 1 >= t.tokens2[l << 1]) {
        n = l;
        break;
      }
    const s = this._model.getLineContent(e.lineNumber);
    let o = "";
    if (i < t.tokens1.length) {
      const l = t.tokens1[i].offset, d = i + 1 < t.tokens1.length ? t.tokens1[i + 1].offset : s.length;
      o = s.substring(l, d);
    }
    Cl(this._domNode, O("h2.tm-token", void 0, _E(o), O("span.tm-token-length", void 0, `${o.length} ${o.length === 1 ? "char" : "chars"}`))), A(this._domNode, O("hr.tokens-inspect-separator", { style: "clear:both" }));
    const a = (n << 1) + 1 < t.tokens2.length ? this._decodeMetadata(t.tokens2[(n << 1) + 1]) : null;
    A(this._domNode, O("table.tm-metadata-table", void 0, O("tbody", void 0, O("tr", void 0, O("td.tm-metadata-key", void 0, "language"), O("td.tm-metadata-value", void 0, `${a ? a.languageId : "-?-"}`)), O("tr", void 0, O("td.tm-metadata-key", void 0, "token type"), O("td.tm-metadata-value", void 0, `${a ? this._tokenTypeToString(a.tokenType) : "-?-"}`)), O("tr", void 0, O("td.tm-metadata-key", void 0, "font style"), O("td.tm-metadata-value", void 0, `${a ? this._fontStyleToString(a.fontStyle) : "-?-"}`)), O("tr", void 0, O("td.tm-metadata-key", void 0, "foreground"), O("td.tm-metadata-value", void 0, `${a ? K.Format.CSS.formatHex(a.foreground) : "-?-"}`)), O("tr", void 0, O("td.tm-metadata-key", void 0, "background"), O("td.tm-metadata-value", void 0, `${a ? K.Format.CSS.formatHex(a.background) : "-?-"}`))))), A(this._domNode, O("hr.tokens-inspect-separator")), i < t.tokens1.length && A(this._domNode, O("span.tm-token-type", void 0, t.tokens1[i].type)), this._editor.layoutContentWidget(this);
  }
  _decodeMetadata(e) {
    const t = ld.getColorMap(), i = Po.getLanguageId(e), n = Po.getTokenType(e), s = Po.getFontStyle(e), o = Po.getForeground(e), a = Po.getBackground(e);
    return {
      languageId: this._languageService.languageIdCodec.decodeLanguageId(i),
      tokenType: n,
      fontStyle: s,
      foreground: t[o],
      background: t[a]
    };
  }
  _tokenTypeToString(e) {
    switch (e) {
      case 0:
        return "Other";
      case 1:
        return "Comment";
      case 2:
        return "String";
      case 3:
        return "RegEx";
      default:
        return "??";
    }
  }
  _fontStyleToString(e) {
    let t = "";
    return e & 1 && (t += "italic "), e & 2 && (t += "bold "), e & 4 && (t += "underline "), e & 8 && (t += "strikethrough "), t.length === 0 && (t = "---"), t;
  }
  _getTokensAtLine(e) {
    const t = this._getStateBeforeLine(e), i = this._tokenizationSupport.tokenize(this._model.getLineContent(e), !0, t), n = this._tokenizationSupport.tokenizeEncoded(this._model.getLineContent(e), !0, t);
    return {
      startState: t,
      tokens1: i.tokens,
      tokens2: n.tokens,
      endState: i.endState
    };
  }
  _getStateBeforeLine(e) {
    let t = this._tokenizationSupport.getInitialState();
    for (let i = 1; i < e; i++)
      t = this._tokenizationSupport.tokenize(this._model.getLineContent(i), !0, t).endState;
    return t;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._editor.getPosition(),
      preference: [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
}
uc._ID = "editor.contrib.inspectTokensWidget";
Z(
  lo.ID,
  lo,
  4
  /* EditorContributionInstantiation.Lazy */
);
x(mE);
var bE = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Lm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Qo;
let Yl = Qo = class {
  constructor(e, t) {
    this.quickInputService = e, this.keybindingService = t, this.registry = hi.as(ra.Quickaccess);
  }
  provide(e) {
    const t = new M();
    return t.add(e.onDidAccept(() => {
      const [i] = e.selectedItems;
      i && this.quickInputService.quickAccess.show(i.prefix, { preserveValue: !0 });
    })), t.add(e.onDidChangeValue((i) => {
      const n = this.registry.getQuickAccessProvider(i.substr(Qo.PREFIX.length));
      n && n.prefix && n.prefix !== Qo.PREFIX && this.quickInputService.quickAccess.show(n.prefix, { preserveValue: !0 });
    })), e.items = this.getQuickAccessProviders().filter((i) => i.prefix !== Qo.PREFIX), t;
  }
  getQuickAccessProviders() {
    return this.registry.getQuickAccessProviders().sort((t, i) => t.prefix.localeCompare(i.prefix)).flatMap((t) => this.createPicks(t));
  }
  createPicks(e) {
    return e.helpEntries.map((t) => {
      const i = t.prefix || e.prefix, n = i || "";
      return {
        prefix: i,
        label: n,
        keybinding: t.commandId ? this.keybindingService.lookupKeybinding(t.commandId) : void 0,
        ariaLabel: g("helpPickAriaLabel", "{0}, {1}", n, t.description),
        description: t.description
      };
    });
  }
};
Yl.PREFIX = "?";
Yl = Qo = bE([
  Lm(0, Ei),
  Lm(1, xe)
], Yl);
hi.as(ra.Quickaccess).registerQuickAccessProvider({
  ctor: Yl,
  prefix: "",
  helpEntries: [{ description: Wy.helpQuickAccessActionLabel }]
});
class BC {
  constructor(e) {
    this.options = e, this.rangeHighlightDecorationId = void 0;
  }
  //#region Provider methods
  provide(e, t) {
    var i;
    const n = new M();
    e.canAcceptInBackground = !!(!((i = this.options) === null || i === void 0) && i.canAcceptInBackground), e.matchOnLabel = e.matchOnDescription = e.matchOnDetail = e.sortByLabel = !1;
    const s = n.add(new ft());
    return s.value = this.doProvide(e, t), n.add(this.onDidActiveTextEditorControlChange(() => {
      s.value = void 0, s.value = this.doProvide(e, t);
    })), n;
  }
  doProvide(e, t) {
    var i;
    const n = new M(), s = this.activeTextEditorControl;
    if (s && this.canProvideWithTextEditor(s)) {
      const o = { editor: s }, a = $_(s);
      if (a) {
        let l = (i = s.saveViewState()) !== null && i !== void 0 ? i : void 0;
        n.add(a.onDidChangeCursorPosition(() => {
          var d;
          l = (d = s.saveViewState()) !== null && d !== void 0 ? d : void 0;
        })), o.restoreViewState = () => {
          l && s === this.activeTextEditorControl && s.restoreViewState(l);
        }, n.add(j_(t.onCancellationRequested)(() => {
          var d;
          return (d = o.restoreViewState) === null || d === void 0 ? void 0 : d.call(o);
        }));
      }
      n.add(pe(() => this.clearDecorations(s))), n.add(this.provideWithTextEditor(o, e, t));
    } else
      n.add(this.provideWithoutTextEditor(e, t));
    return n;
  }
  /**
   * Subclasses to implement if they can operate on the text editor.
   */
  canProvideWithTextEditor(e) {
    return !0;
  }
  gotoLocation({ editor: e }, t) {
    e.setSelection(t.range), e.revealRangeInCenter(
      t.range,
      0
      /* ScrollType.Smooth */
    ), t.preserveFocus || e.focus();
    const i = e.getModel();
    i && "getLineContent" in i && zs(`${i.getLineContent(t.range.startLineNumber)}`);
  }
  getModel(e) {
    var t;
    return U_(e) ? (t = e.getModel()) === null || t === void 0 ? void 0 : t.modified : e.getModel();
  }
  addDecorations(e, t) {
    e.changeDecorations((i) => {
      const n = [];
      this.rangeHighlightDecorationId && (n.push(this.rangeHighlightDecorationId.overviewRulerDecorationId), n.push(this.rangeHighlightDecorationId.rangeHighlightId), this.rangeHighlightDecorationId = void 0);
      const s = [
        // highlight the entire line on the range
        {
          range: t,
          options: {
            description: "quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: !0
          }
        },
        // also add overview ruler highlight
        {
          range: t,
          options: {
            description: "quick-access-range-highlight-overview",
            overviewRuler: {
              color: Se(g_),
              position: ci.Full
            }
          }
        }
      ], [o, a] = i.deltaDecorations(n, s);
      this.rangeHighlightDecorationId = { rangeHighlightId: o, overviewRulerDecorationId: a };
    });
  }
  clearDecorations(e) {
    const t = this.rangeHighlightDecorationId;
    t && (e.changeDecorations((i) => {
      i.deltaDecorations([
        t.overviewRulerDecorationId,
        t.rangeHighlightId
      ], []);
    }), this.rangeHighlightDecorationId = void 0);
  }
}
class gc extends BC {
  constructor() {
    super({ canAcceptInBackground: !0 });
  }
  provideWithoutTextEditor(e) {
    const t = g("cannotRunGotoLine", "Open a text editor first to go to a line.");
    return e.items = [{ label: t }], e.ariaLabel = t, P.None;
  }
  provideWithTextEditor(e, t, i) {
    const n = e.editor, s = new M();
    s.add(t.onDidAccept((l) => {
      const [d] = t.selectedItems;
      if (d) {
        if (!this.isValidLineNumber(n, d.lineNumber))
          return;
        this.gotoLocation(e, { range: this.toRange(d.lineNumber, d.column), keyMods: t.keyMods, preserveFocus: l.inBackground }), l.inBackground || t.hide();
      }
    }));
    const o = () => {
      const l = this.parsePosition(n, t.value.trim().substr(gc.PREFIX.length)), d = this.getPickLabel(n, l.lineNumber, l.column);
      if (t.items = [{
        lineNumber: l.lineNumber,
        column: l.column,
        label: d
      }], t.ariaLabel = d, !this.isValidLineNumber(n, l.lineNumber)) {
        this.clearDecorations(n);
        return;
      }
      const c = this.toRange(l.lineNumber, l.column);
      n.revealRangeInCenter(
        c,
        0
        /* ScrollType.Smooth */
      ), this.addDecorations(n, c);
    };
    o(), s.add(t.onDidChangeValue(() => o()));
    const a = $_(n);
    return a && a.getOptions().get(
      68
      /* EditorOption.lineNumbers */
    ).renderType === 2 && (a.updateOptions({ lineNumbers: "on" }), s.add(pe(() => a.updateOptions({ lineNumbers: "relative" })))), s;
  }
  toRange(e = 1, t = 1) {
    return {
      startLineNumber: e,
      startColumn: t,
      endLineNumber: e,
      endColumn: t
    };
  }
  parsePosition(e, t) {
    const i = t.split(/,|:|#/).map((s) => parseInt(s, 10)).filter((s) => !isNaN(s)), n = this.lineCount(e) + 1;
    return {
      lineNumber: i[0] > 0 ? i[0] : n + i[0],
      column: i[1]
    };
  }
  getPickLabel(e, t, i) {
    if (this.isValidLineNumber(e, t))
      return this.isValidColumn(e, t, i) ? g("gotoLineColumnLabel", "Go to line {0} and character {1}.", t, i) : g("gotoLineLabel", "Go to line {0}.", t);
    const n = e.getPosition() || { lineNumber: 1, column: 1 }, s = this.lineCount(e);
    return s > 1 ? g("gotoLineLabelEmptyWithLimit", "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", n.lineNumber, n.column, s) : g("gotoLineLabelEmpty", "Current Line: {0}, Character: {1}. Type a line number to navigate to.", n.lineNumber, n.column);
  }
  isValidLineNumber(e, t) {
    return !t || typeof t != "number" ? !1 : t > 0 && t <= this.lineCount(e);
  }
  isValidColumn(e, t, i) {
    if (!i || typeof i != "number")
      return !1;
    const n = this.getModel(e);
    if (!n)
      return !1;
    const s = { lineNumber: t, column: i };
    return n.validatePosition(s).equals(s);
  }
  lineCount(e) {
    var t, i;
    return (i = (t = this.getModel(e)) === null || t === void 0 ? void 0 : t.getLineCount()) !== null && i !== void 0 ? i : 0;
  }
}
gc.PREFIX = ":";
var CE = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, SE = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let qr = class extends gc {
  constructor(e) {
    super(), this.editorService = e, this.onDidActiveTextEditorControlChange = De.None;
  }
  get activeTextEditorControl() {
    var e;
    return (e = this.editorService.getFocusedCodeEditor()) !== null && e !== void 0 ? e : void 0;
  }
};
qr = CE([
  SE(0, _e)
], qr);
let vp = class VC extends D {
  constructor() {
    super({
      id: VC.ID,
      label: q_.gotoLineActionLabel,
      alias: "Go to Line/Column...",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 2085,
        mac: {
          primary: 293
          /* KeyCode.KeyG */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e) {
    e.get(Ei).quickAccess.show(qr.PREFIX);
  }
};
vp.ID = "editor.action.gotoLine";
x(vp);
hi.as(ra.Quickaccess).registerQuickAccessProvider({
  ctor: qr,
  prefix: qr.PREFIX,
  helpEntries: [{ description: q_.gotoLineActionLabel, commandId: vp.ID }]
});
const UC = [void 0, []];
function Gc(r, e, t = 0, i = 0) {
  const n = e;
  return n.values && n.values.length > 1 ? wE(r, n.values, t, i) : zC(r, e, t, i);
}
function wE(r, e, t, i) {
  let n = 0;
  const s = [];
  for (const o of e) {
    const [a, l] = zC(r, o, t, i);
    if (typeof a != "number")
      return UC;
    n += a, s.push(...l);
  }
  return [n, yE(s)];
}
function zC(r, e, t, i) {
  const n = R_(e.original, e.originalLowercase, t, r, r.toLowerCase(), i, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
  return n ? [n[0], ad(n)] : UC;
}
function yE(r) {
  const e = r.sort((n, s) => n.start - s.start), t = [];
  let i;
  for (const n of e)
    !i || !xE(i, n) ? (i = n, t.push(n)) : (i.start = Math.min(i.start, n.start), i.end = Math.max(i.end, n.end));
  return t;
}
function xE(r, e) {
  return !(r.end < e.start || e.end < r.start);
}
function Im(r) {
  return r.startsWith('"') && r.endsWith('"');
}
const $C = " ";
function qu(r) {
  typeof r != "string" && (r = "");
  const e = r.toLowerCase(), { pathNormalized: t, normalized: i, normalizedLowercase: n } = Dm(r), s = t.indexOf(rh) >= 0, o = Im(r);
  let a;
  const l = r.split($C);
  if (l.length > 1)
    for (const d of l) {
      const c = Im(d), { pathNormalized: h, normalized: u, normalizedLowercase: p } = Dm(d);
      u && (a || (a = []), a.push({
        original: d,
        originalLowercase: d.toLowerCase(),
        pathNormalized: h,
        normalized: u,
        normalizedLowercase: p,
        expectContiguousMatch: c
      }));
    }
  return { original: r, originalLowercase: e, pathNormalized: t, normalized: i, normalizedLowercase: n, values: a, containsPathSeparator: s, expectContiguousMatch: o };
}
function Dm(r) {
  let e;
  nd ? e = r.replace(/\//g, rh) : e = r.replace(/\\/g, rh);
  const t = Hy(e).replace(/\s|"/g, "");
  return {
    pathNormalized: e,
    normalized: t,
    normalizedLowercase: t.toLowerCase()
  };
}
function km(r) {
  return Array.isArray(r) ? qu(r.map((e) => e.original).join($C)) : qu(r.original);
}
var LE = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Nm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Bs;
let ni = Bs = class extends BC {
  constructor(e, t, i = /* @__PURE__ */ Object.create(null)) {
    super(i), this._languageFeaturesService = e, this._outlineModelService = t, this.options = i, this.options.canAcceptInBackground = !0;
  }
  provideWithoutTextEditor(e) {
    return this.provideLabelPick(e, g("cannotRunGotoSymbolWithoutEditor", "To go to a symbol, first open a text editor with symbol information.")), P.None;
  }
  provideWithTextEditor(e, t, i) {
    const n = e.editor, s = this.getModel(n);
    return s ? this._languageFeaturesService.documentSymbolProvider.has(s) ? this.doProvideWithEditorSymbols(e, s, t, i) : this.doProvideWithoutEditorSymbols(e, s, t, i) : P.None;
  }
  doProvideWithoutEditorSymbols(e, t, i, n) {
    const s = new M();
    return this.provideLabelPick(i, g("cannotRunGotoSymbolWithoutSymbolProvider", "The active text editor does not provide symbol information.")), (async () => !await this.waitForLanguageSymbolRegistry(t, s) || n.isCancellationRequested || s.add(this.doProvideWithEditorSymbols(e, t, i, n)))(), s;
  }
  provideLabelPick(e, t) {
    e.items = [{
      label: t,
      index: 0,
      kind: 14
      /* SymbolKind.String */
    }], e.ariaLabel = t;
  }
  async waitForLanguageSymbolRegistry(e, t) {
    if (this._languageFeaturesService.documentSymbolProvider.has(e))
      return !0;
    const i = new L_(), n = t.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
      this._languageFeaturesService.documentSymbolProvider.has(e) && (n.dispose(), i.complete(!0));
    }));
    return t.add(pe(() => i.complete(!1))), i.p;
  }
  doProvideWithEditorSymbols(e, t, i, n) {
    var s;
    const o = e.editor, a = new M();
    a.add(i.onDidAccept((h) => {
      const [u] = i.selectedItems;
      u && u.range && (this.gotoLocation(e, { range: u.range.selection, keyMods: i.keyMods, preserveFocus: h.inBackground }), h.inBackground || i.hide());
    })), a.add(i.onDidTriggerItemButton(({ item: h }) => {
      h && h.range && (this.gotoLocation(e, { range: h.range.selection, keyMods: i.keyMods, forceSideBySide: !0 }), i.hide());
    }));
    const l = this.getDocumentSymbols(t, n);
    let d;
    const c = async (h) => {
      d == null || d.dispose(!0), i.busy = !1, d = new Oe(n), i.busy = !0;
      try {
        const u = qu(i.value.substr(Bs.PREFIX.length).trim()), p = await this.doGetSymbolPicks(l, u, void 0, d.token);
        if (n.isCancellationRequested)
          return;
        if (p.length > 0) {
          if (i.items = p, h && u.original.length === 0) {
            const f = zy(p, (m) => !!(m.type !== "separator" && m.range && S.containsPosition(m.range.decoration, h)));
            f && (i.activeItems = [f]);
          }
        } else
          u.original.length > 0 ? this.provideLabelPick(i, g("noMatchingSymbolResults", "No matching editor symbols")) : this.provideLabelPick(i, g("noSymbolResults", "No editor symbols"));
      } finally {
        n.isCancellationRequested || (i.busy = !1);
      }
    };
    return a.add(i.onDidChangeValue(() => c(void 0))), c((s = o.getSelection()) === null || s === void 0 ? void 0 : s.getPosition()), a.add(i.onDidChangeActive(() => {
      const [h] = i.activeItems;
      h && h.range && (o.revealRangeInCenter(
        h.range.selection,
        0
        /* ScrollType.Smooth */
      ), this.addDecorations(o, h.range.decoration));
    })), a;
  }
  async doGetSymbolPicks(e, t, i, n) {
    var s, o;
    const a = await e;
    if (n.isCancellationRequested)
      return [];
    const l = t.original.indexOf(Bs.SCOPE_PREFIX) === 0, d = l ? 1 : 0;
    let c, h;
    t.values && t.values.length > 1 ? (c = km(t.values[0]), h = km(t.values.slice(1))) : c = t;
    let u;
    const p = (o = (s = this.options) === null || s === void 0 ? void 0 : s.openSideBySideDirection) === null || o === void 0 ? void 0 : o.call(s);
    p && (u = [{
      iconClass: p === "right" ? oe.asClassName(j.splitHorizontal) : oe.asClassName(j.splitVertical),
      tooltip: p === "right" ? g("openToSide", "Open to the Side") : g("openToBottom", "Open to the Bottom")
    }]);
    const f = [];
    for (let v = 0; v < a.length; v++) {
      const C = a[v], w = By(C.name), y = `$(${Vy.toIcon(C.kind).id}) ${w}`, I = y.length - w.length;
      let k = C.containerName;
      i != null && i.extraContainerLabel && (k ? k = `${i.extraContainerLabel}  ${k}` : k = i.extraContainerLabel);
      let N, J, te, ve;
      if (t.original.length > d) {
        let et = !1;
        if (c !== t && ([N, J] = Gc(y, {
          ...t,
          values: void 0
          /* disable multi-query support */
        }, d, I), typeof N == "number" && (et = !0)), typeof N != "number" && ([N, J] = Gc(y, c, d, I), typeof N != "number"))
          continue;
        if (!et && h) {
          if (k && h.original.length > 0 && ([te, ve] = Gc(k, h)), typeof te != "number")
            continue;
          typeof N == "number" && (N += te);
        }
      }
      const be = C.tags && C.tags.indexOf(
        1
        /* SymbolTag.Deprecated */
      ) >= 0;
      f.push({
        index: v,
        kind: C.kind,
        score: N,
        label: y,
        ariaLabel: Uy(C.name, C.kind),
        description: k,
        highlights: be ? void 0 : {
          label: J,
          description: ve
        },
        range: {
          selection: S.collapseToStart(C.selectionRange),
          decoration: C.range
        },
        strikethrough: be,
        buttons: u
      });
    }
    const m = f.sort((v, C) => l ? this.compareByKindAndScore(v, C) : this.compareByScore(v, C));
    let _ = [];
    if (l) {
      let y = function() {
        C && typeof v == "number" && w > 0 && (C.label = fg(Xc[v] || Zc, w));
      }, v, C, w = 0;
      for (const I of m)
        v !== I.kind ? (y(), v = I.kind, w = 1, C = { type: "separator" }, _.push(C)) : w++, _.push(I);
      y();
    } else
      m.length > 0 && (_ = [
        { label: g("symbols", "symbols ({0})", f.length), type: "separator" },
        ...m
      ]);
    return _;
  }
  compareByScore(e, t) {
    if (typeof e.score != "number" && typeof t.score == "number")
      return 1;
    if (typeof e.score == "number" && typeof t.score != "number")
      return -1;
    if (typeof e.score == "number" && typeof t.score == "number") {
      if (e.score > t.score)
        return -1;
      if (e.score < t.score)
        return 1;
    }
    return e.index < t.index ? -1 : e.index > t.index ? 1 : 0;
  }
  compareByKindAndScore(e, t) {
    const i = Xc[e.kind] || Zc, n = Xc[t.kind] || Zc, s = i.localeCompare(n);
    return s === 0 ? this.compareByScore(e, t) : s;
  }
  async getDocumentSymbols(e, t) {
    const i = await this._outlineModelService.getOrCreate(e, t);
    return t.isCancellationRequested ? [] : i.asListOfDocumentSymbols();
  }
};
ni.PREFIX = "@";
ni.SCOPE_PREFIX = ":";
ni.PREFIX_BY_CATEGORY = `${Bs.PREFIX}${Bs.SCOPE_PREFIX}`;
ni = Bs = LE([
  Nm(0, V),
  Nm(1, fa)
], ni);
const Zc = g("property", "properties ({0})"), Xc = {
  5: g("method", "methods ({0})"),
  11: g("function", "functions ({0})"),
  8: g("_constructor", "constructors ({0})"),
  12: g("variable", "variables ({0})"),
  4: g("class", "classes ({0})"),
  22: g("struct", "structs ({0})"),
  23: g("event", "events ({0})"),
  24: g("operator", "operators ({0})"),
  10: g("interface", "interfaces ({0})"),
  2: g("namespace", "namespaces ({0})"),
  3: g("package", "packages ({0})"),
  25: g("typeParameter", "type parameters ({0})"),
  1: g("modules", "modules ({0})"),
  6: g("property", "properties ({0})"),
  9: g("enum", "enumerations ({0})"),
  21: g("enumMember", "enumeration members ({0})"),
  14: g("string", "strings ({0})"),
  0: g("file", "files ({0})"),
  17: g("array", "arrays ({0})"),
  15: g("number", "numbers ({0})"),
  16: g("boolean", "booleans ({0})"),
  18: g("object", "objects ({0})"),
  19: g("key", "keys ({0})"),
  7: g("field", "fields ({0})"),
  13: g("constant", "constants ({0})")
};
var IE = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Qc = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Ku = class extends ni {
  constructor(e, t, i) {
    super(t, i), this.editorService = e, this.onDidActiveTextEditorControlChange = De.None;
  }
  get activeTextEditorControl() {
    var e;
    return (e = this.editorService.getFocusedCodeEditor()) !== null && e !== void 0 ? e : void 0;
  }
};
Ku = IE([
  Qc(0, _e),
  Qc(1, V),
  Qc(2, fa)
], Ku);
class va extends D {
  constructor() {
    super({
      id: va.ID,
      label: ah.quickOutlineActionLabel,
      alias: "Go to Symbol...",
      precondition: b.hasDocumentSymbolProvider,
      kbOpts: {
        kbExpr: b.focus,
        primary: 3117,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "navigation",
        order: 3
      }
    });
  }
  run(e) {
    e.get(Ei).quickAccess.show(ni.PREFIX, { itemActivation: $y.NONE });
  }
}
va.ID = "editor.action.quickOutline";
x(va);
hi.as(ra.Quickaccess).registerQuickAccessProvider({
  ctor: Ku,
  prefix: ni.PREFIX,
  helpEntries: [
    { description: ah.quickOutlineActionLabel, prefix: ni.PREFIX, commandId: va.ID },
    { description: ah.quickOutlineByCategoryActionLabel, prefix: ni.PREFIX_BY_CATEGORY }
  ]
});
function Yc(r, e) {
  return e && (r.stack || r.stacktrace) ? g("stackTrace.format", "{0}: {1}", Pm(r), Rm(r.stack) || Rm(r.stacktrace)) : Pm(r);
}
function Rm(r) {
  return Array.isArray(r) ? r.join(`
`) : r;
}
function Pm(r) {
  return r.code === "ERR_UNC_HOST_NOT_ALLOWED" ? `${r.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.` : typeof r.code == "string" && typeof r.errno == "number" && typeof r.syscall == "string" ? g("nodeExceptionMessage", "A system error occurred ({0})", r.message) : r.message || g("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
function jC(r = null, e = !1) {
  if (!r)
    return g("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
  if (Array.isArray(r)) {
    const t = Ii(r), i = jC(t[0], e);
    return t.length > 1 ? g("error.moreErrors", "{0} ({1} errors in total)", i, t.length) : i;
  }
  if (m_(r))
    return r;
  if (r.detail) {
    const t = r.detail;
    if (t.error)
      return Yc(t.error, e);
    if (t.exception)
      return Yc(t.exception, e);
  }
  return r.stack ? Yc(r, e) : r.message ? r.message : g("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
function DE(r) {
  var e;
  const t = /* @__PURE__ */ new Map();
  for (const i of r)
    t.set(i, ((e = t.get(i)) !== null && e !== void 0 ? e : 0) + 1);
  return t;
}
class cr {
  constructor() {
    this.chunkCount = 0, this.chunkOccurrences = /* @__PURE__ */ new Map(), this.documents = /* @__PURE__ */ new Map();
  }
  calculateScores(e, t) {
    const i = this.computeEmbedding(e), n = /* @__PURE__ */ new Map(), s = [];
    for (const [o, a] of this.documents) {
      if (t.isCancellationRequested)
        return [];
      for (const l of a.chunks) {
        const d = this.computeSimilarityScore(l, i, n);
        d > 0 && s.push({ key: o, score: d });
      }
    }
    return s;
  }
  /**
   * Count how many times each term (word) appears in a string.
   */
  static termFrequencies(e) {
    return DE(cr.splitTerms(e));
  }
  /**
   * Break a string into terms (words).
   */
  static *splitTerms(e) {
    const t = (i) => i.toLowerCase();
    for (const [i] of e.matchAll(new RegExp("\\b\\p{Letter}[\\p{Letter}\\d]{2,}\\b", "gu"))) {
      yield t(i);
      const n = i.replace(/([a-z])([A-Z])/g, "$1 $2").split(/\s+/g);
      if (n.length > 1)
        for (const s of n)
          s.length > 2 && new RegExp("\\p{Letter}{3,}", "gu").test(s) && (yield t(s));
    }
  }
  updateDocuments(e) {
    var t;
    for (const { key: i } of e)
      this.deleteDocument(i);
    for (const i of e) {
      const n = [];
      for (const s of i.textChunks) {
        const o = cr.termFrequencies(s);
        for (const a of o.keys())
          this.chunkOccurrences.set(a, ((t = this.chunkOccurrences.get(a)) !== null && t !== void 0 ? t : 0) + 1);
        n.push({ text: s, tf: o });
      }
      this.chunkCount += n.length, this.documents.set(i.key, { chunks: n });
    }
    return this;
  }
  deleteDocument(e) {
    const t = this.documents.get(e);
    if (t) {
      this.documents.delete(e), this.chunkCount -= t.chunks.length;
      for (const i of t.chunks)
        for (const n of i.tf.keys()) {
          const s = this.chunkOccurrences.get(n);
          if (typeof s == "number") {
            const o = s - 1;
            o <= 0 ? this.chunkOccurrences.delete(n) : this.chunkOccurrences.set(n, o);
          }
        }
    }
  }
  computeSimilarityScore(e, t, i) {
    let n = 0;
    for (const [s, o] of Object.entries(t)) {
      const a = e.tf.get(s);
      if (!a)
        continue;
      let l = i.get(s);
      typeof l != "number" && (l = this.computeIdf(s), i.set(s, l));
      const d = a * l;
      n += d * o;
    }
    return n;
  }
  computeEmbedding(e) {
    const t = cr.termFrequencies(e);
    return this.computeTfidf(t);
  }
  computeIdf(e) {
    var t;
    const i = (t = this.chunkOccurrences.get(e)) !== null && t !== void 0 ? t : 0;
    return i > 0 ? Math.log((this.chunkCount + 1) / i) : 0;
  }
  computeTfidf(e) {
    const t = /* @__PURE__ */ Object.create(null);
    for (const [i, n] of e) {
      const s = this.computeIdf(i);
      s > 0 && (t[i] = n * s);
    }
    return t;
  }
}
function kE(r) {
  var e, t;
  const i = r.slice(0);
  i.sort((s, o) => o.score - s.score);
  const n = (t = (e = i[0]) === null || e === void 0 ? void 0 : e.score) !== null && t !== void 0 ? t : 0;
  if (n > 0)
    for (const s of i)
      s.score /= n;
  return i;
}
var Ts;
(function(r) {
  r[r.NO_ACTION = 0] = "NO_ACTION", r[r.CLOSE_PICKER = 1] = "CLOSE_PICKER", r[r.REFRESH_PICKER = 2] = "REFRESH_PICKER", r[r.REMOVE_ITEM = 3] = "REMOVE_ITEM";
})(Ts || (Ts = {}));
function Jc(r) {
  const e = r;
  return Array.isArray(e.items);
}
function Mm(r) {
  const e = r;
  return !!e.picks && e.additionalPicks instanceof Promise;
}
class NE extends P {
  constructor(e, t) {
    super(), this.prefix = e, this.options = t;
  }
  provide(e, t, i) {
    var n;
    const s = new M();
    e.canAcceptInBackground = !!(!((n = this.options) === null || n === void 0) && n.canAcceptInBackground), e.matchOnLabel = e.matchOnDescription = e.matchOnDetail = e.sortByLabel = !1;
    let o;
    const a = s.add(new ft()), l = async () => {
      var d;
      const c = a.value = new M();
      o == null || o.dispose(!0), e.busy = !1, o = new Oe(t);
      const h = o.token;
      let u = e.value.substring(this.prefix.length);
      !((d = this.options) === null || d === void 0) && d.shouldSkipTrimPickFilter || (u = u.trim());
      const p = this._getPicks(u, c, h, i), f = (_, v) => {
        var C;
        let w, y;
        if (Jc(_) ? (w = _.items, y = _.active) : w = _, w.length === 0) {
          if (v)
            return !1;
          (u.length > 0 || e.hideInput) && (!((C = this.options) === null || C === void 0) && C.noResultsPick) && (jy(this.options.noResultsPick) ? w = [this.options.noResultsPick(u)] : w = [this.options.noResultsPick]);
        }
        return e.items = w, y && (e.activeItems = [y]), !0;
      }, m = async (_) => {
        let v = !1, C = !1;
        await Promise.all([
          // Fast Picks: if `mergeDelay` is configured, in order to reduce
          // amount of flicker, we race against the slow picks over some delay
          // and then set the fast picks.
          // If the slow picks are faster, we reduce the flicker by only
          // setting the items once.
          (async () => {
            typeof _.mergeDelay == "number" && (await vg(_.mergeDelay), h.isCancellationRequested) || C || (v = f(
              _.picks,
              !0
              /* skip over empty to reduce flicker */
            ));
          })(),
          // Slow Picks: we await the slow picks and then set them at
          // once together with the fast picks, but only if we actually
          // have additional results.
          (async () => {
            e.busy = !0;
            try {
              const w = await _.additionalPicks;
              if (h.isCancellationRequested)
                return;
              let y, I;
              Jc(_.picks) ? (y = _.picks.items, I = _.picks.active) : y = _.picks;
              let k, N;
              if (Jc(w) ? (k = w.items, N = w.active) : k = w, k.length > 0 || !v) {
                let J;
                if (!I && !N) {
                  const te = e.activeItems[0];
                  te && y.indexOf(te) !== -1 && (J = te);
                }
                f({
                  items: [...y, ...k],
                  active: I || N || J
                });
              }
            } finally {
              h.isCancellationRequested || (e.busy = !1), C = !0;
            }
          })()
        ]);
      };
      if (p !== null)
        if (Mm(p))
          await m(p);
        else if (!(p instanceof Promise))
          f(p);
        else {
          e.busy = !0;
          try {
            const _ = await p;
            if (h.isCancellationRequested)
              return;
            Mm(_) ? await m(_) : f(_);
          } finally {
            h.isCancellationRequested || (e.busy = !1);
          }
        }
    };
    return s.add(e.onDidChangeValue(() => l())), l(), s.add(e.onDidAccept((d) => {
      const [c] = e.selectedItems;
      typeof (c == null ? void 0 : c.accept) == "function" && (d.inBackground || e.hide(), c.accept(e.keyMods, d));
    })), s.add(e.onDidTriggerItemButton(async ({ button: d, item: c }) => {
      var h, u;
      if (typeof c.trigger == "function") {
        const p = (u = (h = c.buttons) === null || h === void 0 ? void 0 : h.indexOf(d)) !== null && u !== void 0 ? u : -1;
        if (p >= 0) {
          const f = c.trigger(p, e.keyMods), m = typeof f == "number" ? f : await f;
          if (t.isCancellationRequested)
            return;
          switch (m) {
            case Ts.NO_ACTION:
              break;
            case Ts.CLOSE_PICKER:
              e.hide();
              break;
            case Ts.REFRESH_PICKER:
              l();
              break;
            case Ts.REMOVE_ITEM: {
              const _ = e.items.indexOf(c);
              if (_ !== -1) {
                const v = e.items.slice(), C = v.splice(_, 1), w = e.activeItems.filter((I) => I !== C[0]), y = e.keepScrollPosition;
                e.keepScrollPosition = !0, e.items = v, w && (e.activeItems = w), e.keepScrollPosition = y;
              }
              break;
            }
          }
        }
      }
    })), s;
  }
}
var qC = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, kn = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, In, me;
let ts = In = class extends NE {
  constructor(e, t, i, n, s, o) {
    super(In.PREFIX, e), this.instantiationService = t, this.keybindingService = i, this.commandService = n, this.telemetryService = s, this.dialogService = o, this.commandsHistory = this._register(this.instantiationService.createInstance(_n)), this.options = e;
  }
  async _getPicks(e, t, i, n) {
    var s, o, a, l;
    const d = await this.getCommandPicks(i);
    if (i.isCancellationRequested)
      return [];
    const c = j_(() => {
      const v = new cr();
      v.updateDocuments(d.map((w) => ({
        key: w.commandId,
        textChunks: [this.getTfIdfChunk(w)]
      })));
      const C = v.calculateScores(e, i);
      return kE(C).filter((w) => w.score > In.TFIDF_THRESHOLD).slice(0, In.TFIDF_MAX_RESULTS);
    }), h = [];
    for (const v of d) {
      const C = (s = In.WORD_FILTER(e, v.label)) !== null && s !== void 0 ? s : void 0, w = v.commandAlias && (o = In.WORD_FILTER(e, v.commandAlias)) !== null && o !== void 0 ? o : void 0;
      if (C || w)
        v.highlights = {
          label: C,
          detail: this.options.showAlias ? w : void 0
        }, h.push(v);
      else if (e === v.commandId)
        h.push(v);
      else if (e.length >= 3) {
        const y = c();
        if (i.isCancellationRequested)
          return [];
        const I = y.find((k) => k.key === v.commandId);
        I && (v.tfIdfScore = I.score, h.push(v));
      }
    }
    const u = /* @__PURE__ */ new Map();
    for (const v of h) {
      const C = u.get(v.label);
      C ? (v.description = v.commandId, C.description = C.commandId) : u.set(v.label, v);
    }
    h.sort((v, C) => {
      if (v.tfIdfScore && C.tfIdfScore)
        return v.tfIdfScore === C.tfIdfScore ? v.label.localeCompare(C.label) : C.tfIdfScore - v.tfIdfScore;
      if (v.tfIdfScore)
        return 1;
      if (C.tfIdfScore)
        return -1;
      const w = this.commandsHistory.peek(v.commandId), y = this.commandsHistory.peek(C.commandId);
      if (w && y)
        return w > y ? -1 : 1;
      if (w)
        return -1;
      if (y)
        return 1;
      if (this.options.suggestedCommandIds) {
        const I = this.options.suggestedCommandIds.has(v.commandId), k = this.options.suggestedCommandIds.has(C.commandId);
        if (I && k)
          return 0;
        if (I)
          return -1;
        if (k)
          return 1;
      }
      return v.label.localeCompare(C.label);
    });
    const p = [];
    let f = !1, m = !0, _ = !!this.options.suggestedCommandIds;
    for (let v = 0; v < h.length; v++) {
      const C = h[v];
      v === 0 && this.commandsHistory.peek(C.commandId) && (p.push({ type: "separator", label: g("recentlyUsed", "recently used") }), f = !0), m && C.tfIdfScore !== void 0 && (p.push({ type: "separator", label: g("suggested", "similar commands") }), m = !1), _ && C.tfIdfScore === void 0 && !this.commandsHistory.peek(C.commandId) && (!((a = this.options.suggestedCommandIds) === null || a === void 0) && a.has(C.commandId)) && (p.push({ type: "separator", label: g("commonlyUsed", "commonly used") }), f = !0, _ = !1), f && C.tfIdfScore === void 0 && !this.commandsHistory.peek(C.commandId) && !(!((l = this.options.suggestedCommandIds) === null || l === void 0) && l.has(C.commandId)) && (p.push({ type: "separator", label: g("morecCommands", "other commands") }), f = !1), p.push(this.toCommandPick(C, n));
    }
    return this.hasAdditionalCommandPicks(e, i) ? {
      picks: p,
      additionalPicks: (async () => {
        var v;
        const C = await this.getAdditionalCommandPicks(d, h, e, i);
        if (i.isCancellationRequested)
          return [];
        const w = C.map((y) => this.toCommandPick(y, n));
        return m && ((v = w[0]) === null || v === void 0 ? void 0 : v.type) !== "separator" && w.unshift({ type: "separator", label: g("suggested", "similar commands") }), w;
      })()
    } : p;
  }
  toCommandPick(e, t) {
    if (e.type === "separator")
      return e;
    const i = this.keybindingService.lookupKeybinding(e.commandId), n = i ? g("commandPickAriaLabelWithKeybinding", "{0}, {1}", e.label, i.getAriaLabel()) : e.label;
    return {
      ...e,
      ariaLabel: n,
      detail: this.options.showAlias && e.commandAlias !== e.label ? e.commandAlias : void 0,
      keybinding: i,
      accept: async () => {
        var s, o;
        this.commandsHistory.push(e.commandId), this.telemetryService.publicLog2("workbenchActionExecuted", {
          id: e.commandId,
          from: (s = t == null ? void 0 : t.from) !== null && s !== void 0 ? s : "quick open"
        });
        try {
          !((o = e.args) === null || o === void 0) && o.length ? await this.commandService.executeCommand(e.commandId, ...e.args) : await this.commandService.executeCommand(e.commandId);
        } catch (a) {
          go(a) || this.dialogService.error(g("canNotRun", "Command '{0}' resulted in an error", e.label), jC(a));
        }
      }
    };
  }
  // TF-IDF string to be indexed
  getTfIdfChunk({ label: e, commandAlias: t, commandDescription: i }) {
    let n = e;
    return t && t !== e && (n += ` - ${t}`), i && i.value !== e && (n += ` - ${i.value === i.original ? i.value : `${i.value} (${i.original})`}`), n;
  }
};
ts.PREFIX = ">";
ts.TFIDF_THRESHOLD = 0.5;
ts.TFIDF_MAX_RESULTS = 5;
ts.WORD_FILTER = qy(Zy, Gy, Ky);
ts = In = qC([
  kn(1, q),
  kn(2, xe),
  kn(3, Fe),
  kn(4, ui),
  kn(5, yg)
], ts);
let _n = me = class extends P {
  constructor(e, t) {
    super(), this.storageService = e, this.configurationService = t, this.configuredCommandsHistoryLength = 0, this.updateConfiguration(), this.load(), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.updateConfiguration(e))), this._register(this.storageService.onWillSaveState((e) => {
      e.reason === sg.SHUTDOWN && this.saveState();
    }));
  }
  updateConfiguration(e) {
    e && !e.affectsConfiguration("workbench.commandPalette.history") || (this.configuredCommandsHistoryLength = me.getConfiguredCommandHistoryLength(this.configurationService), me.cache && me.cache.limit !== this.configuredCommandsHistoryLength && (me.cache.limit = this.configuredCommandsHistoryLength, me.hasChanges = !0));
  }
  load() {
    const e = this.storageService.get(
      me.PREF_KEY_CACHE,
      0
      /* StorageScope.PROFILE */
    );
    let t;
    if (e)
      try {
        t = JSON.parse(e);
      } catch {
      }
    const i = me.cache = new Yr(this.configuredCommandsHistoryLength, 1);
    if (t) {
      let n;
      t.usesLRU ? n = t.entries : n = t.entries.sort((s, o) => s.value - o.value), n.forEach((s) => i.set(s.key, s.value));
    }
    me.counter = this.storageService.getNumber(me.PREF_KEY_COUNTER, 0, me.counter);
  }
  push(e) {
    me.cache && (me.cache.set(e, me.counter++), me.hasChanges = !0);
  }
  peek(e) {
    var t;
    return (t = me.cache) === null || t === void 0 ? void 0 : t.peek(e);
  }
  saveState() {
    if (!me.cache || !me.hasChanges)
      return;
    const e = { usesLRU: !0, entries: [] };
    me.cache.forEach((t, i) => e.entries.push({ key: i, value: t })), this.storageService.store(
      me.PREF_KEY_CACHE,
      JSON.stringify(e),
      0,
      0
      /* StorageTarget.USER */
    ), this.storageService.store(
      me.PREF_KEY_COUNTER,
      me.counter,
      0,
      0
      /* StorageTarget.USER */
    ), me.hasChanges = !1;
  }
  static getConfiguredCommandHistoryLength(e) {
    var t, i;
    const s = (i = (t = e.getValue().workbench) === null || t === void 0 ? void 0 : t.commandPalette) === null || i === void 0 ? void 0 : i.history;
    return typeof s == "number" ? s : me.DEFAULT_COMMANDS_HISTORY_LENGTH;
  }
};
_n.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
_n.PREF_KEY_CACHE = "commandPalette.mru.cache";
_n.PREF_KEY_COUNTER = "commandPalette.mru.counter";
_n.counter = 1;
_n.hasChanges = !1;
_n = me = qC([
  kn(0, vn),
  kn(1, he)
], _n);
class RE extends ts {
  constructor(e, t, i, n, s, o) {
    super(e, t, i, n, s, o);
  }
  getCodeEditorCommandPicks() {
    const e = this.activeTextEditorControl;
    if (!e)
      return [];
    const t = [];
    for (const i of e.getSupportedActions())
      t.push({
        commandId: i.id,
        commandAlias: i.alias,
        label: Xy(i.label) || i.id
      });
    return t;
  }
}
var PE = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, bs = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Kr = class extends RE {
  get activeTextEditorControl() {
    var e;
    return (e = this.codeEditorService.getFocusedCodeEditor()) !== null && e !== void 0 ? e : void 0;
  }
  constructor(e, t, i, n, s, o) {
    super({ showAlias: !1 }, e, i, n, s, o), this.codeEditorService = t;
  }
  async getCommandPicks() {
    return this.getCodeEditorCommandPicks();
  }
  hasAdditionalCommandPicks() {
    return !1;
  }
  async getAdditionalCommandPicks() {
    return [];
  }
};
Kr = PE([
  bs(0, q),
  bs(1, _e),
  bs(2, xe),
  bs(3, Fe),
  bs(4, ui),
  bs(5, yg)
], Kr);
class ba extends D {
  constructor() {
    super({
      id: ba.ID,
      label: K_.quickCommandActionLabel,
      alias: "Command Palette",
      precondition: void 0,
      kbOpts: {
        kbExpr: b.focus,
        primary: 59,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "z_commands",
        order: 1
      }
    });
  }
  run(e) {
    e.get(Ei).quickAccess.show(Kr.PREFIX);
  }
}
ba.ID = "editor.action.quickCommand";
x(ba);
hi.as(ra.Quickaccess).registerQuickAccessProvider({
  ctor: Kr,
  prefix: Kr.PREFIX,
  helpEntries: [{ description: K_.quickCommandHelp, commandId: ba.ID }]
});
var ME = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, i);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Cs = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Gu = class extends dn {
  constructor(e, t, i, n, s, o, a) {
    super(!0, e, t, i, n, s, o, a);
  }
};
Gu = ME([
  Cs(1, ee),
  Cs(2, _e),
  Cs(3, Je),
  Cs(4, q),
  Cs(5, vn),
  Cs(6, he)
], Gu);
Z(
  dn.ID,
  Gu,
  4
  /* EditorContributionInstantiation.Lazy */
);
class EE extends D {
  constructor() {
    super({
      id: "editor.action.toggleHighContrast",
      label: Qy.toggleHighContrast,
      alias: "Toggle High Contrast Theme",
      precondition: void 0
    }), this._originalThemeName = null;
  }
  run(e, t) {
    const i = e.get(z_), n = i.getColorTheme();
    gr(n.type) ? (i.setTheme(this._originalThemeName || (Zp(n.type) ? Yy : Jy)), this._originalThemeName = null) : (i.setTheme(Zp(n.type) ? e0 : t0), this._originalThemeName = n.themeName);
  }
}
x(EE);
const wA = (() => {
  let r = !1;
  const e = () => {
    if (r)
      return;
    r = !0, self.MonacoEnvironment = {
      getWorker(i, n) {
        return n === "json" ? import("./json.worker-pROYwcYw.js").then((s) => new s.default()) : n === "css" || n === "scss" || n === "less" ? import("./css.worker-CdiLxZP3.js").then((s) => new s.default()) : n === "html" || n === "handlebars" || n === "razor" ? import("./html.worker-DZfRQTu0.js").then((s) => new s.default()) : n === "typescript" || n === "javascript" ? import("./ts.worker-__T1P6nU.js").then((s) => new s.default()) : import("./editor.worker-D7wy7PqX.js").then((s) => new s.default());
      }
    };
    const t = ed.typescript;
    t.typescriptDefaults.setEagerModelSync(!0), t.typescriptDefaults.setCompilerOptions({
      ...t.typescriptDefaults.getCompilerOptions(),
      experimentalDecorators: !0,
      target: t.ScriptTarget.ESNext,
      module: t.ModuleKind.ESNext,
      moduleResolution: t.ModuleResolutionKind.Classic,
      pretty: !0,
      strict: !0,
      noUncheckedIndexedAccess: !0,
      noPropertyAccessFromIndexSignature: !0,
      strictPropertyInitialization: !1,
      forceConsistentCasingInFileNames: !0,
      allowSyntheticDefaultImports: !0,
      noImplicitOverride: !0,
      useDefineForClassFields: !1,
      noEmitOnError: !0,
      incremental: !1,
      verbatimModuleSyntax: !0,
      esModuleInterop: !0,
      skipLibCheck: !0,
      resolveJsonModule: !0,
      noUnusedLocals: !1,
      noUnusedParameters: !1,
      noFallthroughCasesInSwitch: !0,
      strictNullChecks: !0,
      emitDecoratorMetadata: !0,
      noImplicitReturns: !1,
      noImplicitAny: !0,
      noImplicitThis: !0,
      isolatedModules: !0
    });
  };
  return e(), e;
})();
export {
  wA as s,
  hv as t
};
